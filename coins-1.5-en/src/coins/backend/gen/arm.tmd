;; -----------------------------------------------------------------------
;;%   Copyright (C) 2007 Association for the COINS Compiler Infrastructure 
;;%       (Read COPYING for detailed information.)             
;;------------------------------------------------------------------------ 
;;-*-Lisp-*-
;;; Target machine description  for ARM/elf using clcvn
; Ver.2.10
; $Id: arm.tmd,v 2.26 2008/09/18 19:05:47 kitamura Exp $

;;; References
; ARM DUI0068B, DDI0180A

;;; NB
; * DUI0068B uses not "asl" but "lsl" as left shift. (gcc uses asl.)
; * suffix rule.
;   w: word (32bit)
;   h: half word (16bit)
;   b: byte (8bit)
;   d: double (64bit)
;   f: float (32bit)

(include "common.tmd")
(use-convuf-fu)
(use-call)

;;;;;; common macros
(defmacro (xcat @a @b) @a@b)
(defmacro (cat a b) (xcat a b))

;;; (subreg I8 I32 "%r") -> (SUBREG I8 (REG I32 "%r") 0)
(defmacro (subreg s t r) ( (@if (@eq s t) (REG t r) (SUBREG s (REG t r) 0)) ))

;;;;;; machine dependent macros
;; generate regw, regh, regb, regf, regd
(defmacro (regX t)
  (cat reg (@if (@eq t I32) (w)
		((@if (@eq t I16) (h)
		      ((@if (@eq t I8) (b)
			    ((@if (@eq t F32) (f) (d)))))))) ))

;; generate xregw, xregh, xregb, xregf, xregd
(defmacro (xregX t)
  (cat xreg (@if (@eq t I32) (w)
		((@if (@eq t I16) (h)
		      ((@if (@eq t I8) (b)
			    ((@if (@eq t F32) (f) (d)))))))) ))

;; generate floating instruction suffix
(defmacro (suf_sd base t) 
  (@if (@eq t F64) ((cat base d)) ((cat base s)) ))


;;; Machine types
(def *type-address* I32)
(def *type-bool* I32)


;; __builtin_va_start: body of va_start
(defrewrite (CALL (STATIC I32 "__builtin_va_start") (LIST _) (LIST _))
  (to (SET I32 $2 (ADD I32 (REG I32 "%fp")
                       (INTCONST I32 (eval "makeVaStart($1)")))))
  (phase early))

;; alloca: allocate memory on stack
(defrewrite (CALL (STATIC I32 "alloca") (LIST _) (LIST _))
  (to
   (pre (SET I32 (REG I32 "%sp")
             (SUB I32 (REG I32 "%sp")
                  (BAND I32 (ADD I32 $1 (INTCONST I32 3)) (INTCONST I32 -4)))))
   (SET I32 $2 (REG I32 "%sp")))
  (phase early))


;; soft div/mod
(foreach (@op @func @n) 
  ( (MODS modsi3 2) (MODU umodsi3 2) (DIVS divsi3 2) (DIVU udivsi3 2) )
  (defrewrite (@op _ _)
    (cond "Type.tag($0.type) == Type.INT")
    (to (norescan
	 (eval "rewriteRtlCall($0, pre, \"__@func\", @n)")))
    (phase early))
)


;;; Prologue
;(defrewrite (PROLOGUE)
;  (to (norescan (eval "rewritePrologue($0, post)")))
;  (phase late))
;
;;; Epilogue
;(defrewrite (EPILOGUE)
; (to (norescan (eval "rewriteEpilogue($0, pre)")))
;  (phase late))
;
;;; Call
;(defrewrite (CALL)
;  (to (eval "rewriteCall($0, pre, post)"))
;  (phase late))

;; JUMPN
(defrewrite (JUMPN)
  (to (eval "rewriteJumpn($0, pre)"))
  (phase late) )
 
;; Aggregate copy
(defrewrite (SET)
  (cond "Type.tag($0.type) == Type.AGGREGATE")
  (to (eval "rewriteAggregateCopy($0, pre)"))
  (phase late))

;; Rewrite ASM
;(defrewrite (ASM)
;  (to (norescan (eval "rewriteAsm($0, pre, post)")))
;  (phase late))

;(foreach @t (F32 F64)
; (defrewrite (SET @t (MEM @t _) (MEM @t _))
;  (to (norescan (eval "rewriteFloatingCopy($0, pre)")))
;  (phase late)) 
; )



;;;;;; Real registers
;;; integer register
(defmacro (int-reg-call-clobbers) %r0 %r1 %r2 %r3 %ip %lr)
(defmacro (callee-save-int-regs) %r4 %r5 %r6 %r7 %r8 %r9 %r10)
(defmacro (int32-regs) (int-reg-call-clobbers) (callee-save-int-regs))
(defmacro (int-regs) %r0 %r1 %r2 %r3 %r4 %r5 %r6 %r7 %r8 %r9 %r10)
(defmacro (float-reg-call-clobbers) %f0 %f1 %f2 %f3)
(defmacro (callee-save-float-regs) %f4 %f5 %f6 %f7)
(defmacro (float-regs) (float-reg-call-clobbers) (callee-save-float-regs))

(def *real-reg-symtab*
     ;; symbol table entry of in-core register.
     (SYMTAB
      (foreach @r ( (int32-regs) %fp %vfp %sp %pc) ("@r" REG I32 4 0))
      (foreach @r ( (float-regs) ) ("@r" REG F64 8 0)) )
)

(def *cmplib-xref-symtab*
     (SYMTAB
	(foreach @rtl (modsi3 umodsi3 divsi3 udivsi3) 
	  ("__@rtl" STATIC UNKNOWN 4 "text" XREF))
      ;; void *memcpy(void *to, void *from, size_t n)
      ("memcpy" STATIC UNKNOWN 4 "text" XREF)))
  
(def *reg-I32* ( (foreach @r ( (int32-regs) ) (REG I32 "@r")) ))

(foreach @T (I16 I8)
  (def *reg-@T* ( (foreach @r ( (int-regs) ) (subreg @T I32 "@r")) ) )
)
  
;; Actually, f0-f3 can be used.
(foreach @T (F64 F32)
  (def *reg-@T* (
		  (foreach @n (0 1) (subreg @T F64 "%f@n"))))
)

;; used by runtime library
(def *reg-r0-I32* ((REG I32 "%r0")))
(def *reg-r1-I32* ((REG I32 "%r1")))
;(def *reg-lr-I32* ((REG I32 "%lr")))
(def *reg-ip-I32* ((REG I32 "%ip")))

;; used by indirect call, orr, eor
(def *reg-nlr-I32* (
    (foreach @r ( (int-regs) ) (REG I32 "@r"))
    (REG I32 "%ip")
))
  
;; regset clobbered by CALL
(def *reg-call-clobbers* (
	(foreach @r ( (int-reg-call-clobbers) ) (REG I32 "@r"))
	(foreach @r ( (float-reg-call-clobbers) ) (REG F64 "@r")) ))
  
(def *reg-callee-saves* (
	(foreach @r ( (callee-save-int-regs) ) (REG I32 "@r"))))
; In case of float, call clobber in any case. 
  
;; Default register set for each nonterminals.
;; 32bit register, signedness is undefined
;; unsigned 16, 8bit, upper bits are 0
(defregset (regX I32) *reg-nlr-I32*)
(foreach @T (I16 I8 F32 F64)
  (defregset (regX @T) *reg-@T*)
)


;; Default register set for register variables.
(defregsetvar
  (I32 *reg-nlr-I32*) (I16 *reg-I16*) (I8 *reg-I8*)
  (F64 *reg-F64*) (F32 *reg-F32*)
  )

;;; --- rules start here ---
;; Start symbol
(defstart void)

;; label
(defrule label (LABEL _))

;;; non-terminals for register
;;  xreg* can appear on first operand of SET. (l-value)
;;  reg* appear only on right side hand
(foreach @T (I32 I16 I8 F32 F64)
  (defrule (xregX @T) (REG @T))
  (defrule (xregX @T) (SUBREG @T))
  (defrule (regX @T) (xregX @T))
)
  
;; Constant

; byte
(defrule cbu (INTCONST _)
  (cond "Type.bits(((LirIconst)$0).type) == 8" /* "&& 0 <= ((LirIconst)$0).signedValue()" */)
)

;(defrule cbs (INTCONST _)
;  (cond "Type.bits(((LirIconst)$0).type) == 8 && 0 > ((LirIconst)$0).signedValue()")
;)

;; cnst used by addressing-mode
(defrule cnst cbu)
;(defrule cnst cbs)

; half-word, word
(foreach (@C @N) ((ch 16) (cw 32))
  (defrule @C (INTCONST _)
    (cond "Type.bits(((LirIconst)$0).type) == @N")
  )
  (defrule cnst @C)
)

(defrule sta (STATIC I32))

;; constant or static
(defrule asmcnst cnst)
(defrule asmcnst (ADD I32 asmcnst cnst) (value (+ $1 $2)))
(defrule asmcnst (SUB I32 asmcnst cnst) (value (- $1 $2)))

;; decomposable immdiate
;; decompose to mov + orr
(defrule ximm1 (INTCONST _)
  (cond "nofBytes(((LirIconst)$0).signedValue()) == 1"))

(defrule xmimm (INTCONST _)
  (cond "nofBytes(-((LirIconst)$0).signedValue()) <= 4"))

(defrule ximm (INTCONST _))

;;; rules for addressing mode 2/3
;; base register
(defrule base regw)

;; flexible offset parts.
(defrule imm8  (INTCONST _)		; mode3 (signed byte, half word)
  (cond "-255 <= ((LirIconst)$0).signedValue() && ((LirIconst)$0).signedValue() <= 255"))

(defrule imm12  (INTCONST _)		; mode2 (unsigned byte, word)
  (cond "-4095 <= ((LirIconst)$0).signedValue() && ((LirIconst)$0).signedValue() <= 4095"))


;; index
(defrule index imm8)
(defrule index imm12)
(defrule index regw)

;; scaled index (mode2)
(foreach @N (1 2 3 4 5 6 7 8)
  (defrule sindex (LSHS I32 regw (INTCONST I32 @N))
    (value (lsl $1 (hash @N)))
  )
)

;;; addressing mode 2
;; [base]
(defrule addr2 base
  (value (amode2 $1 ()))
)

;; [base, #imm], [base, #-imm]

; special rule for rewriting virtual frame
(defrule addr2 (ADD I32 base imm12)
  (cond "isVirtual($1)")
  (value (amode2 "%fp" (hash (adjDisp (pls $2)))))
)

(foreach (@OP @PM) ((ADD pls) (SUB neg))
	 (defrule addr2 (@OP I32 base imm12)
	   (value (amode2 $1 (hash (@PM $2))))
	   )
	 )

(foreach (@OP @PM @INDEX) (
	(ADD pind index) (SUB mind index) ; [base, Rm]
	(ADD pind sindex) (SUB mind sindex))	; [base, Rm shift]
  (defrule addr2 (@OP I32 base @INDEX)
    (value (amode2 $1 (@PM $2)))
  )
)

;;; addressing mode 3
;; [base]
(defrule addr3 base
  (value (amode3 $1 ())))

;; [base, #imm], [base, #-imm]
; special rule for rewriting virtual frame
(defrule addr3 (ADD I32 base imm8)
  (cond "isVirtual($1)")
  (value (amode3 "%fp" (hash (adjDisp (pls $2)))))
)

(foreach (@OP @PM) ((ADD pls) (SUB neg))
  (defrule addr3 (@OP I32 base imm8)
    (value (amode3 $1 (hash (@PM $2))))
  )
)

; rules for amode2 ?

;;; memory operand
(defrule memw (MEM I32 addr2))
(defrule memw3 (MEM I32 addr3))
(defrule memb (MEM I8 addr2))
(defrule memh (MEM I16 addr3))		; half word
(defrule memsb (MEM I8 addr3))		; signed byte

;; LDR Rd, [Rn]
;; LDR Rd, [Rn, #{-}imm12]
;; LDR Rd, [Rn, {-}Rm]
;; LDR Rd, [Rn, {-}Rm, LSL n]

(defrule regw sta
  (code (ldr $0 (lit $1)))
  (cost 2 1)
)

(defrule regw asmcnst
  (code (ldr $0 (lit $1)))
  (cost 2 1)
)

;;; Jump Instructions
(defrule void (JUMP label)
  (code (b $1))
  (cost 3 1)
)

;;; load
;; naive load constant

; byte constant
(defrule regb cbu
  (code (mov $0 (u0 $1)))
  (cost 1)
)

;(defrule regb cbs
;  (code (mov $0 (hash $1)))
;  (cost 1)
;)

; 16bit constant
; NB: always generate decomposed sequence instead of ldrh, because
;     ldrh has only 8bit-disp.
(defrule regh ximm1
  (code (mov $0 (b0 $1)))
  (cost 1)
)

(defrule regh ch	; NB: not ximm2 !
  (code (mov $0 (h0 $1))
        (orr $0 $0 (b1 $1)))
  (cost 2)
)

; 32bit constant
(defrule regw cw
  (code (ldr $0 (lit $1)))
  (cost 2 1)
)

; decompose load immdiate
(defrule regw ximm
 (code (_mov $0 $1))
  (cost 1)
 )

;; naive load from mem
(foreach (@REG @MEM @INST)
	((regb memb ldrb) (regh memh ldrh) (regw memw ldr))
  (defrule @REG @MEM
    (code (@INST $0 $1))
    (cost (@if (@eq @REG regw) (2 1) (3 1)) )
  )
)

;; load with explicit extension from mem
; regw <- memb/memsb/memh
(foreach (@REG @MEM @OP @INST) 
	((regw memb CONVZX ldrb) (regw memh CONVZX ldrh)
         (regw memsb CONVSX ldrsb) (regw memh CONVSX ldrsh))
  (defrule @REG (@OP I32 @MEM)
    (code (@INST $0 $1))
    (cost 3 1)
  )
)

; regh <- memb
(foreach (@CONV @MEM @INST)
         ((CONVZX memb ldrb) (CONVSX memsb ldrsb))
  (defrule regh (@CONV I16 @MEM)
    (code (@INST $0 $1))
    (cost 3 1)
  )
)

;; load with explicit truncate from mem
; regh/regb <- memw3
(foreach (@TYPE @INST) ((I8 ldrb) (I16 ldrh))
  (defrule (regX @TYPE) (CONVIT @TYPE memw3)
    (code (@INST $0 $1))
    (cost 3 1)
  )
)

; regb <-memh
(defrule regb (CONVIT I8 memh)
  (code (ldrb $0 $1))
  (cost 3 1)
)

;;; store
;; naive store
(foreach (@TYPE @MEM @REG @INST)
	((I32 memw regw str) (I16 memh regh strh) (I8 memb regb strb))
  (defrule void (SET @TYPE @MEM @REG)
    (code (@INST $2 $1))
    (cost 1)
  )
)

;; store with explicit truncate
(foreach @REG (regw regh)
  (defrule void (SET I8 memb (CONVIT I8 @REG))
    (code (strb $2 $1))
    (cost 1)
  )
)

;; todo checkme
(defrule void (SET I16 memh (CONVIT I16 regw))
  (code (strh $2 $1))
  (cost 1)
)

;; 
;(defrule void regw)
;(defrule void memw)

(defrule void (SET I32 xregw regw)
  (code (mov $1 $2))
  (cost 1)
)

(defrule void (SET I16 xregh regh)
  (code (mov $1 $2))
  (cost 1)
)

(defrule void (SET I8 xregb regb)
  (code (mov $1 $2))
  (cost 1)
)

;;; type conversion on register
;;; NB: values on register are already zero extended

; zero extend
; regw <- regb/regw
; regh <- regb
(defrule regw (CONVZX I32 regh)
	(code (mov $0 $1))
	(cost 1))
(defrule regw (CONVZX I32 regb)
	(code (mov $0 $1))
	(cost 1))
(defrule regh (CONVZX I16 regb)
	(code (mov $0 $1))
	(cost 1))

; signed extend
; regw <- regb/regh
(foreach (@REG @N) ((regb 24) (regh 16))
  (defrule regw (CONVSX I32 @REG)
    (code (mov $0 (lsl $1 (hash @N)))
          (mov $0 (asr $0 (hash @N))))
    (cost 2)
  )
)

; regh <- regb
(defrule regh (CONVSX I16 regb)
   (code (mov $0 (lsl $1 (hash 24)))
         (mov $0 (asr $0 (hash 8)))
         (mov $0 (lsr $0 (hash 16))))
   (cost 3)
)

; truncate
; regb <- regw/regh
(foreach @REG (regw regh)
  (defrule regb (CONVIT I8 @REG)
    (code (and $0 $1 #255))
    (cost 1)
  )
)

; regh <- regw
(defrule regh (CONVIT I16 regw)
   (code (mov $0 (lsl $1 (hash 16)))
         (mov $0 (lsr $0 (hash 16))))
  (cost 2)
)

;;; rules for flexible second operand
(defrule imm8r (INTCONST _)
  (cond "isImm8r(((LirIconst)$0).signedValue())"))

;; used by add/sub
(defrule imm8rm (INTCONST _)
  (cond "isImm8r(-((LirIconst)$0).signedValue())"))

;; used by and/bic
(defrule imm8rn (INTCONST _)
  (cond "isImm8r(~((LirIconst)$0).signedValue())"))


;;; Binary Operations

;; special rule for rewriting virtual frame
;; vfp + virtual offset -> fp + real offset
;; redundant "sub r, r, 0" are eliminated later.
(defrule regw (ADD I32 regw xmimm)
 (cond "isVirtual($1)")
 (code (sub $0 "%fp" (vb0 $2))
  (sub $0 $0 (vb1 $2))
  (sub $0 $0 (vb2 $2))
  (sub $0 $0 (vb3 $2)))
 (cost 0)	;; NB: this isn't real value, bacause this rule is special.
 )

;; flexible second operand parts.
(foreach @N (1 2 3 4 5 6 7 8)
  (foreach (@OP @SHIFT) ((LSHS lsl) (RSHS asr) (RSHU lsr))
    (defrule sregw (@OP I32 regw (INTCONST I32 @N))
      (value (@SHIFT $1 (hash @N)))
    )
  )
)

(foreach (@OP @SHIFT) ((LSHS lsl) (RSHS asr) (RSHU lsr))
  (defrule sregw (@OP I32 regw regw)
    (value (@SHIFT $1 $2))
    (cost 1 0)
  )
)

;; operand of ORR/EOR, ADD/SUB/AND and TSTxx/CMP
(foreach (@TO @FROM) (
    (orop imm8r)		; ORR/EOR (plus value only)
    (opop imm8r) (opop imm8rm)	; ADD/SUB
    (logop imm8r) (logop imm8rn); AND/BIC
    (cmpop imm8r) (cmpop imm8rm) ; TSTxx/CMP
  )
  (defrule @TO @FROM
    (value (hash (pls $1)))
  )
)

(foreach (@TO @FROM) (
    (orop regw) (orop sregw)
    (opop regw) (opop sregw)
    (logop regw) (logop sregw)
    (cmpop regw) (cmpop sregw)
  )
  (defrule @TO @FROM)
)

;; add/sub
(foreach (@OP @INST) ((ADD add) (SUB sub))
  (defrule regw (@OP I32 regw opop)
    (code (@INST $0 $1 $2))
    (cost 1)
  )
)

(foreach (@OP @INST) ((BAND and))
  (defrule regw (@OP I32 regw logop)
    (code (@INST $0 $1 $2))
    (cost 1)
  )
)

;; reverse sub
(defrule regw (SUB I32 orop regw)
  (code (rsb $0 $2 $1))
  (cost 1)
)

;; or/xor
(foreach (@OP @INST) ((BOR orr) (BXOR eor))
  ; for negative value.
  (defrule regw (@OP I32 regw imm8rn)
;   (regset ($0 *reg-nlr-I32*)
;           ($1 *reg-nlr-I32*))
    (code 
       (mov "%lr" (hash $2))
       (@INST $0 $1 "%lr"))
;    (clobber
;	(REG I32 "%lr"))
    (cost 2)

  )

  ; for positive value.
  (defrule regw (@OP I32 regw orop)
    (code (@INST $0 $1 $2))
    (cost 1)
  )
 )

;;; decompose immediate.
;; or/xor
(foreach (@OP @INST) ((BOR orr) (BXOR eor))
  (defrule regw (@OP I32 regw ximm)
   (code (_or @INST $0 $1 $2))
   (cost 2); ;; If 2 is changed to 1, above imm8rm rule can not be applied. //##74
   )
 )

;; add/sub
(foreach (@OP @INST @MINST) ((ADD add sub) (SUB sub add))
  (defrule regw (@OP I32 regw ximm)
   (code (_add @INST @MINST $0 $1 $2))
    (cost 2)
  )
 )

;; decompose and -> bic
(defrule regw (BAND I32 regw ximm)
  (code (_bic bic $0 $1 $2))
  (cost 2)
)

;; mul
(defrule regw (MUL I32 regw regw)
;   (regset ($0 *reg-nlr-I32*)
;           ($1 *reg-lr-I32*)
;           ($2 *reg-nlr-I32*))
;  (code (mul $0 $1 $2))
  (code (mov "%lr" $1)
	(mul $0 "%lr" $2))
  (cost 4 1)
)

;; div/mod
; Implicit run time call causes a problem to generate conditional execution instruction.
;(foreach (@OP @FUNC) 
;	((DIVS __divsi3) (DIVU __udivsi3) (MODS __modsi3) (MODU __umodsi3))
;  (defrule regw (@OP I32 regw regw)
;    (regset ($0 *reg-r0-I32*)
;            ($1 *reg-r0-I32*)
;            ($2 *reg-r1-I32*))
;    (code
;        (bl @FUNC))
;    (clobber
;	(REG I32 "%r1")
;	(REG I32 "%r2")
;	(REG I32 "%r3")
;	(REG I32 "%ip")
;	(REG I32 "%lr"))
;    (cost 20 4)
    ; speed 20 is not actual clock count but represents sufficiently large number. //##74
    ; space 4 includes the cost of loading to r0-r2. //##74
;  )
;)

;; shift
(foreach (@OP @SHIFT) ((LSHS lsl) (RSHS asr) (RSHU lsr))
  (defrule regw (@OP I32 regw regw)
    (code (mov $0 (@SHIFT $1 $2)))
    (cost 2 1)
  )
)

;; unary
(defrule regw (BNOT I32 regw)
  (code (mvn $0 $1))
  (cost 1)
)

(defrule regw (NEG I32 regw)
  (code (rsb $0 $1 (hash 0)))
  (cost 1)
)

;; compare
(defrule regw (TSTEQ I32 regw cmpop)
  (code (cmp $1 $2))
  (cost 1)
)


;; conditinal
(foreach (@OP @INST)
	((TSTEQ beq) (TSTNE bne)
	 (TSTLTS blt) (TSTLES ble) (TSTGTS bgt) (TSTGES bge)
	 (TSTLTU blo) (TSTLEU bls) (TSTGTU bhi) (TSTGEU bhs))
  (defrule void (JUMPC (@OP I32 regw cmpop) label label)
    (code (cmp $1 $2)
          (@INST $3))
    (cost 4 2)
  )
)


;;; Call
(defrule void (CALL sta)
  (code (bl $1))
  (cost 3 1))

(foreach @callee (regw memw)
  (defrule void (CALL @callee)
;    (regset ($1 *reg-nlr-I32*))
    (code 
     (mov "%lr" "%pc")
     (mov "%pc" $1)
     )
    (cost (@if (@eq @callee regw) (4) (6)) 2)
  )
)


;;; rules for floating point

(foreach (@FD @n) ((f 32) (d 64))
 (defrule cnst@FD (FLOATCONST _)
   (cond "Type.bits(((LirFconst)$0).type) == @n"))
)

;; common part.
(foreach (@T @FD @SD) ((F32 f s) (F64 d d))
  ;; memory operand (memf/memd)
  (defrule mem@FD (MEM @T addr3))

  ;; load floating constant.
  (defrule reg@FD cnst@FD
    (code (ldf@SD $0 (lit@FD $1)))
    (cost 4)
    )

  ;; naive load from mem
  (defrule reg@FD mem@FD
    (code (ldf@SD $0 $1))
    (cost 4)
  )

  ;; naive store
  (defrule void (SET @T mem@FD reg@FD)
    (code (stf@SD $2 $1))
    (cost 3)
  )

  ;; unaop
  (defrule reg@FD (NEG @T reg@FD)
    (code (mnf@SD $0 $1))
    (cost 3))

  ;; binop
  (foreach (@OP @INST) ((ADD adf) (SUB suf) (MUL muf) (DIVS dvf))
    (defrule reg@FD (@OP @T reg@FD reg@FD)
      (code (@INST@SD $0 $1 $2))
      (cost 3))
  )

  ;; compare
  (foreach (@OP @INST)
	((TSTEQ beq) (TSTNE bne)
	 (TSTLTS blt) (TSTLES ble) (TSTGTS bgt) (TSTGES bge)
	 (TSTLTU blo) (TSTLEU bls) (TSTGTU bhi) (TSTGEU bhs))
    (defrule void (JUMPC (@OP I32 reg@FD reg@FD) label label)
      (code (cmfe $1 $2)
          (@INST $3))
      (cost 4)
    )
  )


  ;; convert to signed int.
  (defrule regw (CONVFS I32 reg@FD)
    (code (fixz $0 $1))
    (cost 1)
  )

  (defrule regh (CONVFS I16 reg@FD)
    (code (fixz $0 $1)
          (mov $0 (lsl $0 (hash 16)))
          (mov $0 (lsr $0 (hash 16))))
    (cost 3)
  )
  (defrule regb (CONVFS I8 reg@FD)
    (code (fixz $0 $1)
          (and $0 $0 #255))
    (cost 2)
  )

  ;; convert from signed int.
  (defrule reg@FD (CONVSF @T regw)
    (code (flt@SD $0 $1))
    (cost 1)
  )
)

;; F32 -> F64 and F64 -> F32
(foreach (@dst @src @INST) ((F64 F32 CONVFX) (F32 F64 CONVFT))
  (defrule (regX @dst) (@INST @dst (regX @src))
    (code ((suf_sd mvf @dst) $0 $1))
    (cost 1)
  )
)

; inter register copy
(foreach @T (F64 F32)
  (defrule void (SET @T (xregX @T) (regX @T))
    (code ((suf_sd mvf @T) $1 $2))
    (cost 1)
  )
)

; Rules used while development.
;(defrule void regf)
;(defrule void regd)

;;; special rules used rewriteCall().
; push float/double
(foreach (@T @SD @FD @N) ((F32 s f 4) (F64 d d 8))
 (defrule void 
  (PARALLEL
   (SET I32 (REG I32 "%sp") (SUB I32 (REG I32 "%sp") (INTCONST I32 @N)))
   (SET @T (MEM @T (REG I32 "%sp")) reg@FD))
  (code (stf@SD $1 (preinc sp -@N)))
  (cost 2)))

; pop float to one general register
(defrule void 
 (PARALLEL 
  (SET I32 regw (MEM I32 (REG I32 "%sp")))
  (SET I32 (REG I32 "%sp") (ADD I32 (REG I32 "%sp") (INTCONST I32 4))))
 (code (ldmfd sp! (regpair1 $1)))
 (cost 6))

; pop double to two general registers.
(defrule void 
 (PARALLEL 
  (SET I32 regw (MEM I32 (REG I32 "%sp")))
  (SET I32 regw (MEM I32 (ADD I32 (REG I32 "%sp") (INTCONST I32 4))))
  (SET I32 (REG I32 "%sp") (ADD I32 (REG I32 "%sp") (INTCONST I32 8))))
 (code (ldmfd sp! (regpair2 $1 $2)))
 (cost 6))

;;; special rules for memory copy of floating
(defrule void
  (SET F32 memf memf)
 (code 
  (ldr "%lr" $2)
  (str "%lr" $1))
;  (clobber (REG I32 "%lr"))
 (cost 1)
 )

; bug: this rule causes bad frame access.
;(defrule void
; (SET F64 (MEM F64 base) (MEM F64 base))
; (code 
;  (ldmia $2 "{%ip, %lr}")
;  (stmia $1 "{%ip, %lr}")
;  )
;  (clobber
;   (REG I32 "%ip")
;   (REG I32 "%lr"))
; (cost 1)
; )

%%

import coins.backend.asmpp.LiteralAndBranchProcessor;
import coins.backend.asmpp.CPU;
import coins.backend.CantHappenException;
import coins.backend.Function;
import coins.backend.Module;
import coins.backend.Op;
import coins.backend.Storage;
import coins.backend.SyntaxError;
import coins.backend.Type;
import coins.backend.lir.LirFconst;
import coins.backend.lir.LirIconst;
import coins.backend.lir.LirNode;
import coins.backend.lir.LirSymRef;
import coins.backend.sym.Label;
import coins.backend.sym.SymAuto;
import coins.backend.sym.SymStatic;
import coins.backend.sym.Symbol;
import coins.backend.util.BiLink;
import coins.backend.util.BiList;
import coins.backend.util.ImList;
import java.io.PrintWriter;

import java.io.OutputStream;
import java.io.OutputStreamWriter;
import coins.backend.cfg.BasicBlk;
import coins.backend.cfg.FlowGraph;	
import coins.backend.lir.LirLabelRef;

import coins.driver.CoinsOptions;
import coins.driver.CommandLine;
import coins.driver.CompileSpecification;
import coins.driver.CompileThread;
import coins.IoRoot;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import coins.backend.ana.SaveRegisters;
import coins.backend.util.NumberSet;

import coins.backend.LocalTransformer;
import coins.backend.Transformer;
import coins.backend.Data;

%State methods

%CodeGenerator methods
boolean isSimulate = false;

void initializeMachineDep() {
    peepHoleOpts.put("_mov", decompMov);
    peepHoleOpts.put("_add", decompAdd);
    peepHoleOpts.put("_or", decompOr);
    peepHoleOpts.put("_bic", decompBic);

    Thread th = Thread.currentThread();
    if (th instanceof CompileThread) {
      IoRoot io = ((CompileThread) th).getIoRoot();
      CompileSpecification spec = io.getCompileSpecification();
      CoinsOptions coinsOptions = spec.getCoinsOptions();
      if (coinsOptions.isSet("simulate")) {
        isSimulate = true;
      }
    }
}


/** Return late time pre-rewriting sequence. **/
public Transformer[] lateRewritingSequence() {
    return new Transformer[] {
	localLateRewritingTrig,
	testJumpcTrig,
	ProcessFramesTrig
    };
}


/** Examine conditional jump **/
final LocalTransformer testJumpcTrig = new LocalTransformer() {
	public boolean doIt(Function func, ImList args) {
	    FlowGraph cfg = func.flowGraph();

	    for (BiLink p = cfg.basicBlkList.first();
		 !p.atEnd();
		 p = p.next()) {
		BasicBlk blk = (BasicBlk) p.elem();
		for (BiLink inst = ((BiList) blk.instrList()).first();
		     !inst.atEnd(); inst = inst.next()) {
		    LirNode lir = (LirNode) inst.elem();
		    if (lir.opCode == Op.JUMPC) {
			examineJUMPC(p, lir);
		    }
		}
	    }
	    return true;
	}
	
	public boolean doIt(Data data, ImList args) { return true; }
      
	public String name() { return "TestJumpc"; }
	
	public String subject() { return "Examin conditional jump"; }
    };

// check bb has only one pred.
boolean checkPred(BiLink q, BasicBlk bb)
{
    BiList pred = ((BasicBlk) q.elem()).predList();

    if (pred.length() != 1) { // has incoming jump
	return false;
    }
    return ((BasicBlk) pred.first().elem()).id == bb.id;
}

boolean checkTarget(Label lab, BiLink q)
{
    if (!(q.elem() instanceof BasicBlk)) {
	return false;
    }
    return lab.name().equals(
			     ((BasicBlk) q.elem()).label().name()
			     );
}

boolean checkSucc(BiLink p, BasicBlk bb)
{
    BiList succ = ((BasicBlk) p.elem()).succList();

    if (succ.length() != 1) {
	return false;
    }
    return ((BasicBlk) succ.first().elem()).id == bb.id;
}

// todo: Check float ?
// maximum length of conditional execution.
private final static int MAX_COND_LEN = 8;
boolean checkBody(BasicBlk bb)
{
    int n = 0;

    BiList l = bb.instrList();
    for (BiLink p = l.first(); !p.atEnd(); p = p.next()) {
	LirNode tmp = (LirNode) p.elem();
	switch (tmp.opCode) {
	case Op.JUMPC:
	case Op.CALL:
	case Op.PARALLEL:
	case Op.DIVS:
	case Op.DIVU:
	case Op.MODS:
	case Op.MODU:
	    debug("::: too complex " + bb);
	    return false;
	default:
	    debug("OK: " + tmp);
	    break;
	}
	if (++n > MAX_COND_LEN) {
	    debug("::: too long " + bb);
	    return false;
	}
    }
    return true;
}


void examineJUMPC(BiLink p, LirNode node) {
    BasicBlk blk = (BasicBlk) p.elem();
    int op = node.kid(0).opCode;

    // NB: conditinal code is flipped somewhere, 
    LirNode y = node.kid(2);
    LirNode z = node.kid(1);

    Label falseTarget = ((LirLabelRef) y).label;
    Label trueTarget = ((LirLabelRef) z).label;
    
    debug2(" then target " + z + " -> " + trueTarget);
    debug2(" else target " + y + " -> " + falseTarget);

    BiLink q = null, r = null, s = null;
    if (!p.next().atEnd()) {
	q = p.next();
	if (!q.next().atEnd()) {
	    r = q.next();
	    if (!r.next().atEnd()) {
		s = r.next();
	    }
	}
    }
    
    if (q == null || r == null) {
	// bad lir ?
	debug("examineJUMPC: bad lir ?");
	return;
    }

    // check common condition
    if (!checkPred(q, blk)
	|| !checkTarget(trueTarget, q) 
	|| !checkTarget(falseTarget, r)
	|| !checkBody((BasicBlk) q.elem())) {
	debug2(" cexec no ");
	return;
    }
    // now ensured: trueTarget = q &&  falseTarget = r

    // if-then ?
    if (checkSucc(q, (BasicBlk) r.elem())) {
	debug2("if-then type: " + blk.label());
	debug2("  -> OK, target: " + trueTarget.name());
	jumpcInfo.put(trueTarget.name().intern(),
		      new JumpcEntry(op2cc(op), trueTarget.name()));
	return;
    }

    // if-then-else ?
    if (s == null
	|| !checkPred(r, blk)
	|| !checkSucc(q, (BasicBlk) s.elem())
	|| !checkSucc(r, (BasicBlk) s.elem())){
	debug2(" cexec no");
	return;
    }

    if (!checkBody((BasicBlk) r.elem())) {
	debug2("if-then-elseNG type: " + blk.label());
	debug2(" -> OK, target: " + trueTarget.name());
	jumpcInfo.put(trueTarget.name().intern(),
		      new JumpcEntry(op2cc(op), trueTarget.name(), null));
	return;
    }
    debug2("if-then-else type: " + blk.label());
    debug2(" -> OK, target: " + trueTarget.name() + ", " + falseTarget.name());
    jumpcInfo.put(trueTarget.name().intern(),
		  new JumpcEntry(op2cc(op), trueTarget.name(), falseTarget.name()));
    return;
}


private LiteralAndBranchProcessor pp;

final class Arm extends CPU {
    Arm() {
	bccRange = new int[] {-0x7ffffff0, 0x7ffffff0};
	braRange = new int[] {-0x7ffffff0, 0x7ffffff0};
	literalRange = new int[] {-800, 800};
	bccMnemo = new String[] { "beq", "bne",
				  "bhs", "blo", "bhi", "bls",
				  "bge", "blt", "bgt", "ble" };
	braMnemo = "b";
	braLength = 4;
	codeAlign = 2;
    }

    public int codeLength(String inst)
    {
	return 4;
    }

    public String toString() {
	return "Arm";
    }
}

/** Run Literal and Branch post processor after generating assembly code. **/
OutputStream insertPostProcessor(OutputStream out) {
   pp = LiteralAndBranchProcessor.postProcessor(out);
   pp.setCPU(new Arm());
   return pp.pipeTo();
}

void notifyEndToPostProcessor() {
   pp.notifyEnd();
}


ImList regCallClobbers = $def(*reg-call-clobbers*);
int decompMax = 4;			// maximum decompsition

int tmpCnt = 0;

Map conditionalExec = new HashMap();
Map jumpcInfo = new HashMap();

/** Arm's function attribute **/
static class ArmAttr extends FunctionAttr {
  /** Maximum stack space used by call. **/
  /** int stackRequired **/

  /** pretend value. */
  /* bytes count of register passed parameter which copied to stack on
     prologue. */
  /** int pretend; **/

  /* bytes count of register passed parameter which copied to stack on
     prologue on variadic argument. */
  /** int pretend2; **/

  /** pointer of aggregate return value. */
  /** LirNode hiddenPtr **/

  /** is variadic ? */
  /** boolean variadic **/

  /** callee save register */
  int adjustCalleeSaves;

  ArmAttr(Function func) {
    super(func);
    adjustCalleeSaves = -1;
  }
}

FunctionAttr newFunctionAttr(Function func) {
  ArmAttr attr = new ArmAttr(func);
  // in simulation mode, save all registers.
  if (isSimulate) {
    attr.adjustCalleeSaves = CALLEE_SAVE;
  }
  return attr;
}



/** Arm constant */
class ArmConst {
    private class RotatedValue {
	private long value;
	private int lsr;

	RotatedValue(long val, int n) {
	    value = val & UINT_MAX;
	    lsr = n;
	}
	RotatedValue(long val) {
	    this(val, 0);
	}

	long value() {
	    return value;
	}

	int lsr() {
	    return lsr;
	}

	private void incLsr() {
	    lsr++;
	    if (lsr >= 32) {
		lsr -= 32;
	    }
	}
	private void decLsr() {
	    lsr--;
	    if (lsr <= -1) {
		lsr += 32;
	    }
	}

	void ror() {
	    incLsr();
	    value = ((value << 31) | (value >>> 1)) & UINT_MAX;
	}

	void rol() {
	    decLsr();
	    value = ((value << 1) | (value >>> 31)) & UINT_MAX;
	}

	void ror2(int n) {
	    for (int i = 0; i < n; i++) {
		ror(); ror();
	    }
	}
	void rol2(int n) {
	    for (int i = 0; i < n; i++) {
		rol(); rol();
	    }
	}
	void shr8() {
	    lsr += 8;
	    if (lsr > 32) {
		lsr -= 32;
	    }
	    value = (value >>> 8) & UINT_MAX;
	}

	public String toString() {
	    return "0x" + 
                Long.toString((value << lsr) & UINT_MAX | (value >>> (32 - lsr)) & UINT_MAX, 16);
	    // return Long.toString(value << lsr, 10);
	}

	void minimize() {
	    int n = lsr;
	    long min = value;

	    for (int i = 1; i <= 16; i++) {
		ror2(1);
		if (value < min) {
		    min = value;
		    n = lsr;
		}
	    }
	    value = min;
	    lsr = n;
	}

    }

    private long rawValue;
    private RotatedValue val;

    private static final long UINT_MAX = 0xffffffffL;

    private String toHex(int val) {
	return toHex((long) val);
    }
    private String toHex(long val) {
	return Long.toString(val & UINT_MAX, 16);
    }

    public ArmConst(long val) {
	rawValue = val & UINT_MAX;
	this.val = new RotatedValue(rawValue);
    }

    RotatedValue b[] = new RotatedValue[4];
    int nofBytes = 0;
    int normalize() {
	int bi = 0;
	if (rawValue == 0) {
	    return nofBytes = 1;
	}
	while (val.value() != 0) {
	    val.minimize();

	    b[bi] = new RotatedValue(val.value() & 0xff, val.lsr());
	    bi++;
	    val.shr8();
	}
	if (false) {
	    System.out.println("-- result");
	    for (int i = 0; i < bi; i++) {
		System.out.println("  " + i + ": " + b[i]);
	    }
	}
	return nofBytes = bi;
    }
    public String get(int off) {
      if (rawValue == 0) {
        return "0";
      }
      if (b[off] == null) {
        return "0";
      }
      return String.valueOf(b[off]);
    }

    public void print() {
	System.out.println("value: " + toHex(rawValue));
	//	System.out.println("  = " + rotated + " lsl " + lsr);
	for (int i = 0; i < nofBytes; i++) {
	    System.out.println("  " + i + ": " + (b[i].value() + ":" + b[i].lsr()));
	}
    }
}

boolean isImm8r(long val) {
    ArmConst c = new ArmConst(val);
    c.normalize();
    return c.nofBytes == 1;
}

boolean isXimm(long val) {
    ArmConst c = new ArmConst(val);
    c.normalize();
    return c.nofBytes < 3;
}

int nofBytes(long val) {
    ArmConst c = new ArmConst(val);
    c.normalize();
    int n = c.nofBytes;
    debug("nofByte(" + val + ") = " + n);
    return n <= decompMax ? n : 5;
}

boolean isConv(int op)
{
    switch (op) {
    case Op.CONVSX:
    case Op.CONVFX:
	return true;
    default:
	return false;
    }
}

boolean equalArg(LirNode x, LirNode y) {
    if (x.opCode == Op.MEM || isConv(x.opCode)) {
	x = x.kid(0);
    }
    if (y.opCode == Op.MEM || isConv(y.opCode)) {
	y = y.kid(0);
    }
    if (x instanceof LirSymRef && y instanceof LirSymRef) {
	return ((LirSymRef)x).symbol == ((LirSymRef)y).symbol;
    }
    // System.out.println("equal ? " + x + " : "  + y);
    return false;
}

/** Return offset for va_start position. **/
int makeVaStart(LirNode arg) {
  ArmAttr at = (ArmAttr) getFunctionAttr(func);
  at.isVarArg = true;
  at.stackParamOffset = MAXREGPARAM;
  return paramOffset(arg) + 8;	// not 4
}

static final int I64 = Type.type(Type.INT, 64);
static final int I32 = Type.type(Type.INT, 32);
static final int I16 = Type.type(Type.INT, 16);
static final int I8 = Type.type(Type.INT, 8);
static final int F64 = Type.type(Type.FLOAT, 64);
static final int F32 = Type.type(Type.FLOAT, 32);

static final int MAXREGPARAM = 4;	// regs
static final int REGWIDTH = 4;		// bytes

static final int CALLEE_SAVE = 28;	// r4-r10
static final String NEED_OFFSET_REWRITE = "&vframe";


static final String[] paramRegv = new String[]{"%r0", "%r1", "%r2", "%r3"};

/** Return number of registers multiply word-size. **/
int clcvnRegLimit() {  return MAXREGPARAM * 4;  }

/** Return parameter word **/
LirNode clcvnParamWord(int type, int location, boolean caller) {
  ArmAttr at = (ArmAttr) getFunctionAttr(func);
  if (location < (caller ? MAXREGPARAM * 4 : at.stackParamOffset))
    return clcvnParamReg(type, location, caller);
  else
    return clcvnParamMem(type, location, caller);
}

/** Return parameter register **/
LirNode clcvnParamReg(int type, int location, boolean caller) {
  LirNode master = phyReg(paramRegv[location >> 2]);
  if (type == master.type)
    return master;
  else if (type == I16)
    return lir.node
      (Op.SUBREG, I16, master, lir.untaggedIconst(I32, 0));
  else if (type == I8)
    return lir.node
      (Op.SUBREG, I8, master, lir.untaggedIconst(I32, 0));
  else {
    throw new CantHappenException("type: " + type);
  }
}

/** Return parameter memory **/
LirNode clcvnParamMem(int type, int location, boolean caller) {
  ArmAttr at = (ArmAttr) getFunctionAttr(func);
  return lir.node
    (Op.MEM, type,
     lir.node
     (Op.ADD, I32, phyReg(caller ? "%sp" : "%fp"),
      lir.iconst(I32, (caller ? (location - 4*MAXREGPARAM)
                              : 4 + (location - at.stackParamOffset)))));
}

/** Return offset of parameter (callee side) **/
int clcvnParamOffset(int location) {
  ArmAttr at = (ArmAttr) getFunctionAttr(func);
  return 4 + (location - at.stackParamOffset);
}

/** Pass floating point number to register/ register and memory. **/
void clcvnPassFloatRegMem(int location, LirNode arg, BiLink memp, BiLink regp, BiList alist) {
  int w = Type.bytes(arg.type);
  LirNode sp = phyReg("%sp");

  LirNode r = phyReg(paramRegv[location >> 2]);
  if (location + w <= MAXREGPARAM * 4) {
    // pass by register
    // push float register on stack
    memp.addBefore
      (lir.node
       (Op.PARALLEL, Type.UNKNOWN, lir.node
        (Op.SET, I32, sp, lir.node
         (Op.SUB, I32, sp, lir.iconst(I32, w))), lir.node
        (Op.SET, arg.type, lir.node(Op.MEM, arg.type, sp), arg)));

    // pop Ixx
    if (w > 4) {
      LirNode r2 = phyReg(paramRegv[(location >> 2) + 1]);
      regp.addBefore
        (lir.node
         (Op.PARALLEL, Type.UNKNOWN, lir.node
          (Op.SET, I32, r, lir.node(Op.MEM, I32, sp)), lir.node
          (Op.SET, I32, r2, lir.node
           (Op.MEM, I32, lir.node(Op.ADD, I32, sp, lir.iconst(I32, 4)))), lir.node
          (Op.SET, I32, sp, lir.node(Op.ADD, I32, sp, lir.iconst(I32, 8)))));
    } else {
      regp.addBefore
        (lir.node
         (Op.PARALLEL, Type.UNKNOWN, lir.node
          (Op.SET, I32, r, lir.node(Op.MEM, I32, sp)), lir.node
          (Op.SET, I32, sp, lir.node(Op.ADD, I32, sp, lir.iconst(I32, 4)))));
    }
    
  } else {
    // load first half on register, last half on memory.
    if (w != 8)
      throw new CantHappenException("double expected");
    // store float register on stack
    memp.addBefore
      (lir.node
        (Op.SET, I32, sp, lir.node
         (Op.SUB, I32, sp, lir.iconst(I32, 4))));
    memp.addBefore
      (lir.node
       (Op.SET, arg.type, lir.node(Op.MEM, arg.type, sp), arg));

    // pop register
    regp.addBefore
      (lir.node
       (Op.PARALLEL, Type.UNKNOWN, lir.node
        (Op.SET, I32, r, lir.node(Op.MEM, I32, sp)), lir.node
        (Op.SET, I32, sp, lir.node(Op.ADD, I32, sp, lir.iconst(I32, 4)))));
  }
}

/** Return return register **/
LirNode clcvnReturnValue(int type) {
  if (Type.tag(type) == Type.INT) {
    return regnode(type, "%r0");
  } else {
    return regnode(type, "%f0");
  }
}

/** Return partial word of integer object **/
LirNode clcvnPartialWord(LirNode exp, int part) {
  if (exp.type == I64)
    return lir.node(Op.SUBREG, I32, exp, lir.untaggedIconst(I32, part));
  else
    return exp;
}

/** Set partial word of integer object **/
LirNode clcvnSetPartialWord(LirNode lhs, int part, LirNode rhs) {
  if (lhs.type == I64)
    return lir.node
      (Op.SET, I32, lir.node
       (Op.SUBREG, I32, lhs, lir.untaggedIconst(I32, part)), rhs);
  else
    return lir.node(Op.SET, lhs.type, lhs, rhs);
}

/** Return clobber list **/
ImList clcvnClobbers() {
  return regCallClobbers;
}

/** Return true if struct return address **/
boolean clcvnStructReturnAsFirst() { return true; }

/** clcvnStructReturnPtr(boolean caller): not neccesary **/
    






private void debug(String s)
{
    //System.out.println(s);
}

private void debug2(String s)
{
    //System.out.println(":::" + s);
}

private void bug()
{
  System.out.println("bug");
}


private void bug(String s)
{
  System.out.println("bug: " + s);
}

private LirNode setExp(int type, LirNode op1, LirNode op2) {
    return lir.node(Op.SET, type, op1, op2);
}

private LirNode memExp(int type, LirNode op1) {
    return lir.node(Op.MEM, type, op1);
}

private LirNode memExp(int type, LirNode op1, int align) {
    if (true) {
    return lir.operator(Op.MEM, type, op1,
		    ImList.list("&align", String.valueOf(align)));
    }
    return lir.operator(Op.MEM, type, op1, ImList.Empty);
}


private LirNode addExp(int type, LirNode op1, LirNode op2) {
    return lir.node(Op.ADD, type, op1, op2);
}

/*private LirNode addExp(int type, LirNode op1, LirNode op2, String opt) {
    if (false) {
	return lir.operator(Op.ADD, type, op1, op2, ImList.list(opt));
    }
    return lir.operator(Op.ADD, type, op1, op2, ImList.Empty);
}
*/

private LirNode setI32(LirNode op1, LirNode op2) {
    return lir.node(Op.SET, I32, op1, op2);
}

private LirNode memI32(LirNode op1) {
    return lir.node(Op.MEM, I32, op1);
}

private LirNode memI32Base(LirNode base, int disp) {
    return memI32(addI32(base, disp));
}

private LirNode addI32(LirNode op1, int n) {
    return lir.node(Op.ADD, I32, op1, lir.iconst(I32, n));
}


private LirNode regI32(int nth) {
    return lir.symRef(module.globalSymtab.get("%r" + nth));
}

/** Rewrite FRAME node to target machine form. **/
LirNode rewriteFrame(LirNode node) {
    Symbol fp = func.module.globalSymtab.get("%fp");
    Symbol vfp = func.module.globalSymtab.get("%vfp");

    //    System.out.println("func ; " + func);
	
  if (!(node instanceof LirSymRef)) {
      bug("rewriteFrame() requires LirSymRef: " + node);
      return node;
  }
  Symbol sym = ((LirSymRef)node).symbol;

  if (!(sym instanceof SymAuto)) {
      bug("rewriteFrame() requires SymAuto: " + sym);
  }

  int off = ((SymAuto) sym).offset();
  if (off < 0) {
      //      System.out.println("*** rewriting frame " + node + " offset = " + off);
      off -= 12 + CALLEE_SAVE;		// maximize off
      debug(" -> " + off);
      if (isSimulate) {
        // simulation mode
        return addExp(I32, lir.symRef(fp), lir.iconst(I32, (long)off));
      } else {
        // rewrite offset later, returns "vfp + disp" here.
        return addExp(I32, lir.symRef(vfp), lir.iconst(I32, (long)off));
      }
  }
  /* else */
  // offset is already fixed.
  return addExp(I32, lir.symRef(fp), lir.iconst(I32, (long)off));
}


private LirNode regnode(int type, String name) {
    LirNode master = lir.symRef(module.globalSymtab.get(name));
    switch (Type.tag(type)) {
    case Type.INT:
	if (type == I32)
	    return master;
	else if (type == I16)
	    return lir.node
		(Op.SUBREG, I16, master, lir.untaggedIconst(I32, 0));
	else if (type == I8)
	    return lir.node
		(Op.SUBREG, I8, master, lir.untaggedIconst(I32, 0));
    case Type.FLOAT:
	if (type == F64)
	    return master;
	else if (type == F32)
	    return lir.node
		(Op.SUBREG, F32, master, lir.untaggedIconst(I32, 0));
    default:
	return null;
    }
}




/***********/







class JumpcKey {
    Function func;
    int id;
    JumpcKey(Function f, int i) {
	func = f;
	id = i;
    }
}

class JumpcEntry {
    final String cc;
    final String trueTarget;
    final String falseTarget;
    final boolean ifThenElse;

    JumpcEntry(String cc, String trueTarget) {
	this.cc = cc;
	ifThenElse = false;
	this.trueTarget = trueTarget;
	this.falseTarget = "";
    }
    JumpcEntry(String cc, String trueTarget, String falseTarget) {
	this.cc = cc;
	ifThenElse = true;
	this.trueTarget = trueTarget;
	this.falseTarget = falseTarget;
    }
    public String toString() {
	return "[cc = " + cc
	    + ", label1 = " + trueTarget
	    + ", label1 = " + falseTarget + "]";
    }
}

static final Map flipCc = new HashMap();
static {
    flipCc.put("eq", "ne");
    flipCc.put("ne", "eq");
    flipCc.put("lt", "ge");
    flipCc.put("le", "gt");
    flipCc.put("gt", "le");
    flipCc.put("ge", "lt");
    flipCc.put("lo", "hs");
    flipCc.put("ls", "hi");
    flipCc.put("hi", "ls");
    flipCc.put("hs", "lo");
}

String op2cc(int op)
{
    switch (op) {
    case Op.TSTEQ:
	return "eq";
    case Op.TSTNE:
	return "ne";
    case Op.TSTLTS:
	return "lt";
    case Op.TSTLES:
	return "le";
    case Op.TSTGTS:
	return "gt";
    case Op.TSTGES:
	return "ge";
    case Op.TSTLTU:
	return "lo";
    case Op.TSTLEU:
	return "ls";
    case Op.TSTGTU:
	return "hi";
    case Op.TSTGEU:
	return "hs";
    default:
	return "badOp";
    }
}


/*
 * Code building macros.
 */

/* none */

/* Code emission macros.
 *  Patterns not defined below will be converted to:
 *   (foo bar baz) --> foo   bar,baz   or foo(bar,baz)
 */

/* literal */
%defemit(lit x) {
  return "=W" + x;
}

%defemit(litf x) {
  double value = Float.parseFloat(x);
  long bits = Float.floatToIntBits((float)value);
  return "=W" + Long.toString(bits & 0xffffffffL, 10) + " @ " + x;
}
  
%defemit(litd x) {
  double value = Double.parseDouble(x);
  long bits = Double.doubleToLongBits(value);
  return "=D0x" + Long.toString((bits >>> 32) & 0xffffffffL, 16)
       + "_0x"  + Long.toString(bits & 0xffffffffL, 16) + " @ " + x;
}


/* constant */
%defemit(pls x) {
  return "" + x;
}

%defemit(neg x) {
  return "-" + x;
}

%defemit(pind x) {
  return x;
}

%defemit(mind x) {
  return "-" + x;
}


/* shift */
%defemit(lsl x y) {
  return x + ", lsl " + y;
}
%defemit(asr x y) {
  return x + ", asr " + y;
}
%defemit(lsr x y) {
  return x + ", lsr " + y;
}

/* amode */
%defemit(amode2 x y ) {
    if (y.length() > 0) {
	return "[" + x + ", " + y + "]";
    }
    return "[" + x + "]";
}

%defemit(amode3 x y) {
    if (y.length() > 0) {
	return "[" + x + ", " + y + "]";
    }
    return "[" + x + "]";
}

%defemit(hash x) { return "#" + x; }

%defemit(adjDisp x) {
    ArmAttr attr = (ArmAttr) getFunctionAttr(func);
    // System.out.println(" adjDisp " + x + " <- callee save " + attr.adjustCalleeSaves);
    long off = Long.parseLong(x) + CALLEE_SAVE - attr.adjustCalleeSaves;
    // System.out.println(" -> " + off);
    return String.valueOf(off);
}

%defbuild(vb0 x) {
    ArmAttr attr = (ArmAttr) getFunctionAttr(func);
    if (attr.adjustCalleeSaves < 0) {
	SaveRegisters saveList = (SaveRegisters)func.require(SaveRegisters.analyzer);
	attr.adjustCalleeSaves = 0;
	for (NumberSet.Iterator it = saveList.calleeSave.iterator(); it.hasNext(); ) {
	    int reg = it.next();
	    attr.adjustCalleeSaves += REGWIDTH;
	}
    }
    long off = Long.parseLong(x.toString()) + CALLEE_SAVE - attr.adjustCalleeSaves;
    ximm = new ArmConst(-off);
    ximm.normalize();
    return ImList.list("#" + ximm.get(0));
}
%defbuild(vb1 x) {
    return ImList.list("#" + ximm.get(1));
}
%defbuild(vb2 x) {
    return ImList.list("#" + ximm.get(2));
}
%defbuild(vb3 x) {
    return ImList.list("#" + ximm.get(3));
}

/** decompose immediate **/
ArmConst ximm = null;	// working temporal.

%defemit(b0 x) {
  debug("decomposing " + x);
  ximm = new ArmConst(Long.parseLong(x));
  ximm.normalize();

  return "#" + ximm.get(0);
}

%defemit(b1 x) {
  return "#" + ximm.get(1);
}


%defemit(h0 x) {
  debug("decomposing " + x);

  ximm = new ArmConst(Long.parseLong(x) & 0xffff);
  ximm.normalize();

  return "#" + ximm.get(0);
}

%defemit(u0 x) {
  return "#" + (Long.parseLong(x) & 0xff);
}


/* special rules */
%defemit(preinc x y) {
    return "[" + x + ", #" + y + "]!";
}

%defemit(regpair2 x y) {
    return "{" + x + ", " + y + "}";
}

%defemit(regpair1 x) {
    return "{" + x + "}";
}


/** Return lower half register name. **/
%defemit(regwlow x) { return "%" + x.substring(2); }

/** Return lowest byte register name. **/
%defemit(regblow x) { return "%" + x.substring(2, 3) + "l"; }

/** Generate prologue sequence. **/
%defemit(prologue =f) {
    Function func = (Function)f;
    SaveRegisters saveList = (SaveRegisters)func.require(SaveRegisters.analyzer);
    int size = frameSize(func);
    ArmAttr attr = (ArmAttr) getFunctionAttr(func);
    if (!isSimulate) {
      attr.adjustCalleeSaves = 0;
    }

    int forCall = attr.requiredStack;
    forCall -= 4*MAXREGPARAM;
    if (forCall < 0) forCall = 0;
    size += forCall;

    debug("**** defemit prologue: frame size " + size);

    size = (size + 3) & -4; // round up to 4byte boundary !!
    // fixme ? (armgcc aligns 8 byte boundary ?)

    String seq = "\n@ prologue\n\tmov\tip, sp";

    if (false) {
      if (attr.stackParamOffset < 4*MAXREGPARAM) {
	seq += "\n\tstmfd\tsp!, {";
	for (int i = attr.stackParamOffset/4; i < 4*MAXREGPARAM; i++) {
          seq += "r" + i;
          if (i == MAXREGPARAM - 1) {
            seq += "}";
          } else {
            seq += ", ";
          }
	}
      }
    }

    /* String seq2 = "\n\tstmfd\tsp!, {fp, ip, lr, pc}";*/
    /* push all callee save registers. */
    String seq2 = "\n\tstmfd\t%sp!, {";
    if (isSimulate) { //
      // save all registers.
      seq2 += "%r4,%r5,%r6,%r7,%r8,%r9,%r10,";
    } else {
      for (NumberSet.Iterator it = saveList.calleeSave.iterator(); it.hasNext(); ) {
	int reg = it.next();
	seq2 += machineParams.registerToString(reg) + ", ";
	attr.adjustCalleeSaves += REGWIDTH;
      }
    }
    //System.out.println("*** " + attr);
    //System.out.println("*** callee save " + attr.adjustCalleeSaves);
    seq2 += "%fp, %ip, %lr, %pc}";
    
    if (attr.stackParamOffset < 4*MAXREGPARAM) {
	// saving some register value onto stack in prologue of
	// non-variadic function
	seq += "\n\tsub\tsp, sp, #" + (4*MAXREGPARAM - attr.stackParamOffset);
    }
    seq2 += "\n\tsub\tfp, ip, #" + (4 + (4*MAXREGPARAM - attr.stackParamOffset));

    if (size > 0) {
	// NB: need constant rewrite.
	if (size + attr.adjustCalleeSaves > 1024) {
	    seq2 += "\n\tldr\tlr, =W" +  (size + attr.adjustCalleeSaves) + "\n\tsub\tsp, sp, lr";
	} else {
	    seq2 += "\n\tsub\tsp, sp, #" + (size + attr.adjustCalleeSaves) + "\t@frame 2";
	}
    } else if (size == 0) {
	// do nothing
    } else {
	/* bug */
    }

    return seq + seq2;
}

/** Generate epilogue sequence. **/
%defemit(epilogue =f rettype) {
    Function func = (Function)f;
    SaveRegisters saveList = (SaveRegisters)func.require(SaveRegisters.analyzer);
    // pop all callee save registers.
    String seq = "\n@ epilgue\n\tldmea\t%fp, {";
    if (isSimulate) { ////
      seq += "%r4,%r5,%r6,%r7,%r8,%r9,%r10,";
    } else {
      for (NumberSet.Iterator it = saveList.calleeSave.iterator(); it.hasNext(); ) {
	int reg = it.next();
	seq += machineParams.registerToString(reg) + ", ";
      }
    }
    seq += "%fp, %sp, %pc}\n";
    seq += ".ltorg\n";
    return seq;
}


%defemit(deflabel x) { return x + ":"; }

%defemit(line x) { return "@line " + x; }

%defemit(genasm format =args) { return emitAsmCode(format, (ImList)args); }

void emitComment(PrintWriter out, String comment) {
    out.println("@ " + comment);
}

void emitBeginningOfSegment(PrintWriter out, String segment) {
    out.println("\t.section \"" + segment + "\"");
}

void emitEndOfSegment(PrintWriter out, String segment) {
  /* do nothing */
}

void emitDataLabel(PrintWriter out, String label) {
    out.println(label + ":");
}

void emitCodeLabel(PrintWriter out, String label) {
    out.println(label + ":");
}


/** Emit data align **/
void emitAlign(PrintWriter out, int align) {
    int n = 0;
    while ((1 << n) < align) {
       n++;
    }
    // n - 1 < log2(align) < n
    if (n > 0) {
      out.println("\t.align\t" + n);
    }
}

/** Emit data common **/
void emitCommon(PrintWriter out, SymStatic symbol, int bytes) {
    if (symbol.linkage == "LDEF")
	out.println("\t.local\t" + symbol.name);
    out.println("\t.common\t" + symbol.name + "," + bytes + ","
		+ symbol.boundary);
}

/** Emit linkage information of symbol */
void emitLinkage(PrintWriter out, SymStatic symbol) {
    if (symbol.linkage == "XDEF")
	out.println("\t.global\t" + symbol.name);
}


/** Emit data zeros **/
void emitZeros(PrintWriter out, int bytes) {
    if (bytes > 0) {
        out.println("\t.skip\t" + bytes);
    }
}


/** Emit data **/
void emitData(PrintWriter out, int type, LirNode node) {
    if (type == I32) {
        out.println("\t.word\t" + lexpConv.convert(node));
    }
    else if (type == I16) {
	out.println("\t.short\t" + ((LirIconst)node).signedValue());
    }
    else if (type == I8) {
	out.println("\t.byte\t" + ((LirIconst)node).signedValue());
    }
    else if (type == F64) {
	double value = ((LirFconst)node).value;
	long bits = Double.doubleToLongBits(value);
	out.println("\t.long\t0x" + Long.toString((bits >> 32) & 0xffffffffL, 16)
		    + " @ " + value);
	out.println("\t.long\t0x" + Long.toString(bits & 0xffffffffL, 16));
    }
    else if (type == F32) {
	double value = ((LirFconst)node).value;
	long bits = Float.floatToIntBits((float)value);
	out.println("\t.long\t0x" + Long.toString(bits & 0xffffffffL, 16)
		    + " @ " + value);
    }
    else {
	throw new CantHappenException("unknown type: " + type);
    }
}

/** Emit asm instruction. **/
String emitAsmCode(String format, ImList args) {
  StringBuffer buf = new StringBuffer();
  int n = format.length();
  for (int i = 0; i < n; ) {
    char c = format.charAt(i++);
    if (c == '%' && i < n) {
      c = format.charAt(i++);
      if (c == '%')
	buf.append(c);
      else if (Character.isDigit(c)) {
	if (args.elem(c - '1') instanceof Long) { // adjust disp
	  Long tmp = (Long) args.elem(c - '1');
	  ArmAttr attr = (ArmAttr) getFunctionAttr(func);
	  long off = tmp.longValue() + CALLEE_SAVE - attr.adjustCalleeSaves;
	  buf.append(Long.toString(off));
	} else {
	  buf.append(args.elem(c - '1').toString());
	}
      }
      else {
	buf.append('%');
	buf.append(c);
      }
    } else
      buf.append(c);
  }
  return buf.toString();
}

// delete redundant sub r, r, #0
private Object car(Object l) {
    return ((ImList) l).elem();
}
private Object cdr(Object l) {
    return ((ImList) l).next();
}

private boolean isDelSub(ImList tmp) {
    String dst = (String) car(cdr(tmp));
    String src = (String) car(cdr(cdr(tmp)));
    if (dst.equals(src)) {
	Object imm = car(cdr(cdr(cdr(tmp))));
	if (imm.equals("#0")) {
	    return true;
	}
    }
    return false;
}


ImList addCc(Object cc, ImList inst) {
    String oldinst = car(inst).toString();
    String newinst = oldinst + cc; // default

    if (oldinst.equals("bl")) {
	System.err.println("bl in conditional execution sequence. " + inst);
    } else if (oldinst.startsWith("ldr")
	|| oldinst.startsWith("str")
	|| oldinst.startsWith("ldm")
	|| oldinst.startsWith("stm")
	|| oldinst.startsWith("ldf")
	|| oldinst.startsWith("stf")
	|| oldinst.startsWith("adf")
	|| oldinst.startsWith("suf")
	|| oldinst.startsWith("rsf")
	|| oldinst.startsWith("muf")
	|| oldinst.startsWith("dvf")
	|| oldinst.startsWith("mvf")
	|| oldinst.startsWith("mnf")
	|| oldinst.startsWith("flt")
	|| oldinst.startsWith("fix")
	) {
	newinst = oldinst.substring(0, 3) + cc + oldinst.substring(3);
    }

    return new ImList(newinst, (ImList) cdr(inst));
}

ImList toComment(String prefix, ImList inst) {
    StringBuffer tmp = new StringBuffer(prefix);
    do {
	tmp.append(' ').append(car(inst));
	inst = (ImList) cdr(inst);
    } while (inst != ImList.Empty);
    return new ImList(tmp.toString(), ImList.Empty);
}

boolean isOp(String op, ImList inst) {
    String tmp = (String) car(inst);
    return op.equals(tmp);
}

boolean rewriteCondExec(BiLink p) {
    ImList cexec = ImList.Empty;
    ImList tmp = (ImList) p.elem();
    JumpcEntry t = (JumpcEntry) jumpcInfo.get(car(cdr(tmp)).toString());

    // todo?: address of floating constant
    if (t == null) {
	return false;
    }
    
    // comment out conditional jump.
    BiLink bcc = p.prev();
    bcc.addBefore(".ltorg2");	// for asmpp
    bcc.setElem(toComment("@", (ImList) bcc.elem()));
    
    // comment out this label
    p.setElem(toComment("@", tmp));
    
    // add condition (then-part)
    BiLink q;
    for (q = p.next(); !q.atEnd(); q = q.next()) {
	ImList old = (ImList) q.elem();
	if (isOp("deflabel", old)) {
	    break;
	} else {
	    if (false && ((String) car(old)).startsWith("b")) {
		// delete needless last branch of then-part
		p.addBefore(toComment("@", old));
	    } else {
		p.addBefore(addCc(t.cc, old));
	    }
	    q.unlink();
	    // q.setElem(addCc(t.cc, old));
	}
    }
    
    // optional process for if-then-else
    if (t.ifThenElse && t.falseTarget != null) { 
	// conditinal execute else-part
	// comment out this label
	q.setElem(toComment("@", (ImList) q.elem()));

	// add condition (else-part)
	for (q = q.next(); !q.atEnd(); q = q.next()) {
	    ImList old = (ImList) q.elem();
	    if (isOp("deflabel", old)) {
		break;
	    } else {
		p.addBefore(addCc(flipCc.get(t.cc), old));
		q.unlink();
	    }
	}
    }
    return true;
}

Object nth(ImList l, int n)
{
    for (int i = 0 ; i < n; i++) {
	l = (ImList) cdr(l);
    }
    return (Object) car(l);
}


/* ** constant decompsition */
private Map peepHoleOpts = new HashMap();

abstract class PeepHoleOp {
    abstract boolean doIt(ImList inst, BiLink l);
    void addBefore(ImList inst, BiLink l) {
	l.addBefore(inst);
	// System.out.println("  +-> " + inst);
    }
}

PeepHoleOp decompMov = new PeepHoleOp() {
	boolean doIt(ImList inst, BiLink l) {
	    //System.out.println("inst " + inst);

	    long imm = ((Long) nth(inst, 2)).longValue();
	    Object dst = car(cdr(inst));
	    ArmConst val = new ArmConst(imm);
	    ArmConst val2 = new ArmConst(~imm);
	    val.normalize();
	    val2.normalize();

	    if (val2.nofBytes == 1) {
		addBefore(ImList.list("mvn", dst, "#" + val2.get(0)), l);
	    } else {
		addBefore(ImList.list("mov", dst, "#" + val.get(0)), l);
		for (int i = 1; i < val.nofBytes; i++) {
		    addBefore(ImList.list("orr", dst, dst, "#" + val.get(i)), l);
		}
	    }
	    return true;
	}
    };

PeepHoleOp decompAdd = new PeepHoleOp() {
	boolean doIt(ImList inst, BiLink l) {
	    //System.out.println("inst " + inst);

	    Object mnemo = nth(inst, 1);
	    Object mnemo2 = nth(inst, 2);
	    Object dst = nth(inst, 3);
	    Object src = nth(inst, 4);
	    long imm = ((Long) nth(inst, 5)).longValue();
	    ArmConst val = new ArmConst(imm);
	    ArmConst val2 = new ArmConst(-imm);
	    val.normalize();
	    val2.normalize();
    
	    if (val2.nofBytes < val.nofBytes) {
		val = val2;
		mnemo = mnemo2;
	    }
	    
	    for (int i = 0; i < val.nofBytes; i++) {
		addBefore(ImList.list(mnemo, dst, src, "#" + val.get(i)), l);
		src = dst;
	    }
	    return true;
	}

    };

void logop(ImList inst, BiLink l, boolean cpl) {
    //System.out.println("inst " + inst);
    Object mnemo = nth(inst, 1);
    Object dst = nth(inst, 2);
    Object src = nth(inst, 3);
    long imm = ((Long) nth(inst, 4)).longValue();
    ArmConst val = new ArmConst(cpl ? ~imm : imm);
    val.normalize();
    
    for (int i = 0; i < val.nofBytes; i++) {
	ImList tmp = ImList.list(mnemo, dst, src, "#" + val.get(i));
	l.addBefore(tmp);
	// System.out.println("  +-> " + tmp);	
	src = dst;
    }
}


PeepHoleOp decompOr = new PeepHoleOp() {
	boolean doIt(ImList inst, BiLink l) {
	    logop(inst, l, false);
	    return true;
	}
    };

PeepHoleOp decompBic = new PeepHoleOp() {
	boolean doIt(ImList inst, BiLink l) {
	    logop(inst, l, true);
	    return true;
	}
    };


void peepHoleOpt(BiList list) {

    // phase 1: trivial optimize and constant decomposition.
    for (BiLink p = list.first(); !p.atEnd(); p = p.next()) {
	ImList tmp = (ImList) p.elem();
	//	System.out.println("p1: " + tmp);

	String op = "";
	if (car(tmp) instanceof String) {
	    op = (String) car(tmp);
	} else {
	    System.out.println("*** " + tmp);
	    continue;
	}

	PeepHoleOp opt;

	if ((opt = (PeepHoleOp) peepHoleOpts.get(op)) != null) {
	    if (opt.doIt(tmp, p)) {
		p.unlink();
		continue;
	    }
	}

	// eliminate sub r, r, 0
        if (op.equals("sub") && isDelSub(tmp)) {
	    p.unlink();
	    continue;
        }
    }

    // pass 2: check conditional execution
if (true) {
    for (BiLink p = list.first(); !p.atEnd(); p = p.next()) {
	ImList tmp = (ImList) p.elem();
        String op = (String) car(tmp);

	//	System.out.println("p2: " + tmp);
        if (op.equals("deflabel")) {
	    if (rewriteCondExec(p)) {
		// skip cexec node
		p = p.next();
	    }
	}
    }
}
}


// check virtual frame pointer
boolean isVirtual(LirNode node)
{
    Symbol vfp = func.module.globalSymtab.get("%vfp");
    if (node instanceof LirSymRef) {
	Symbol sym = ((LirSymRef)node).symbol;
	return sym == vfp;
    }
    return false;
}

// rewrite implicit runtime library call to explicit call-exp
LirNode rewriteRtlCall(LirNode node, BiList pre, String rtl, int n) {
    debug("rewriteRtlCall: $0 = " + node);

    // make temporal
    LirNode tmp = func.newTemp(node.type);
    // resultant exp.
    LirNode list;

    // rewrite rtl-call to explicit call-exp.
    LirNode rtl_func = lir.symRef(func.module.globalSymtab.get(rtl));

    debug("op = " + node.opCode);
    // setup parameter
    LirNode[] args = new LirNode[n];
    for (int i = 0; i < n; i++) {
	args[i] = node.kid(i);
    }
    
    list = lir.operator(Op.CALL, Type.UNKNOWN, rtl_func,
			lir.node(Op.LIST, Type.UNKNOWN, args),
			lir.node(Op.LIST, Type.UNKNOWN, tmp),
			ImList.list());
    pre.add(list);
    return tmp;
}
