<?xml version="1.0" encoding="Shift_JIS"?>

<!DOCTYPE html 
  PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<!--
  $Id: htmlpage.tmpl,v 1.1.1.1 2003/02/26 13:07:29 ko1 Exp $
  paper index
  -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja">
  <head>
	<meta http-equiv="Content-Type" content="text/html;charset=Shift_JIS" />
	<meta http-equiv="Content-Style-Type" content="text/css" />
	
	<link rel="stylesheet" type="text/css" href="./contents.css" />

    <title>How to use COINS infrastructure</title>

  </head>
  <body>
	<h1>1. How to use COINS compiler infrastructure</h1>
    
	<h2>Contents</h2>
    
<ul>
<li><a href='#i-1-1'>1.1. Getting Overview of the Compiler Infrastructure</a></li>
<li><a href='#i-1-2'>1.2. Structure of COINS Compiler Infrastructure</a></li>
<ul>
<li><a href='#i-1-2-1'>1.2.1. Overall Structure</a></li>
<li><a href='#i-1-2-2'>1.2.2. Classes and Interfaces</a></li>
</ul>
<li><a href='#i-1-3'>1.3. Construction of a Compiler based on the COINS infrastructure</a></li>
<ul>
<li><a href='#i-1-3-1'>1.3.1. Compiler Control</a></li>
<li><a href='#i-1-3-2'>1.3.2. Getting Triggers of Intermediate Representation</a></li>
<li><a href='#i-1-3-3'>1.3.3. Symbol Handling</a></li>
<ul>
<li><a href='#i-1-3-3-1'>1.3.3.1. Factory Methods</a></li>
<li><a href='#i-1-3-3-2'>1.3.3.2. Subprograms, Variables, Constants</a></li>
<li><a href='#i-1-3-3-3'>1.3.3.3. Symbol Table</a></li>
<li><a href='#i-1-3-3-4'>1.3.3.4. Scope of Symbols</a></li>
<li><a href='#i-1-3-3-5'>1.3.3.5. SymRoot</a></li>
<li><a href='#i-1-3-3-6'>1.3.3.6. Type</a></li>
<li><a href='#i-1-3-3-7'>1.3.3.7. Generation of Temporal Variables and Labels</a></li>
<li><a href='#i-1-3-3-8'>1.3.3.8. Representation of Symbol in Text Form</a></li>
</ul>
<li><a href='#i-1-3-4'>1.3.4. HIR Handling</a></li>
<ul>
<li><a href='#i-1-3-4-1'>1.3.4.1. Getting Information of HIR</a></li>
<li><a href='#i-1-3-4-2'>1.3.4.2. Representation of HIR in Text Form</a></li>
<li><a href='#i-1-3-4-3'>1.3.4.3. Normal Construction of HIR</a></li>
<li><a href='#i-1-3-4-4'>1.3.4.4. Top down Construction of HIR</a></li>
<li><a href='#i-1-3-4-5'>1.3.4.5. Construction by Sequence of Statements</a></li>
<li><a href='#i-1-3-4-6'>1.3.4.6. Note on HIR Construction and Transformation</a></li>
<li><a href='#i-1-3-4-7'>1.3.4.7. Indispensable Items and Optional Items</a></li>
</ul>
</ul>


<li><a href='#i-1-4'>1.4. Test Program Suite</a></li>
<ul>
<li><a href='#i-1-4-1'>1.4.1. Overview</a></li>
<li><a href='#i-1-4-2'>1.4.2. Automatic test</a></li>
<ul>
<li><a href='#i-1-4-2-1'>1.4.2.1. On Sparc machine</a></li>
<li><a href='#i-1-4-2-2'>1.4.2.2. On Intel x86 machine and others</a></li>
</ul>
<li><a href='#i-1-4-3'>1.4.3. Preparation of expected results</a></li>
<ul>
<li><a href='#i-1-4-3-1'>1.4.3.1. On Sparc machine</a></li>
<li><a href='#i-1-4-3-2'>1.4.3.2. On Intel x86 machine and others</a></li>
</ul>
</ul>

</ul>

<h3 id='i-1-1'>1.1. Getting Overview of the Compiler Infrastructure</h3>
The COINS compiler infrastructure is composed of 
<ul>
<li>parsers to translate source language to HIR 
        (High-level Intermediate Representation)</li>
<li>control flow and data flow analyzers</li>
<li>optimizers</li>
<li>parallelizers</li>
<li>HIR to LIR (Low-level Intermediate Representation) converter</li>
<li>HIR manager</li>
<li>symbol manager</li>
<li>target machine descriptions </li>
<li>back-end with code generator generator based on the target machine descriptions</li>
<li>visualizer for compiling process </li>
<li>etc.</li>
</ul>
At present, the compiler infrastructure contains two parsers,
for C and Fortran77, and 6 code generators, for SPARC, x86, x86_64, 
ARM, MIPS, SH-4, PowerPC, Alpha, MicroBlaze, and Thumb. Thus, it has
2*10 = 20 compilers. <p>

Compilation with debug-print option will show how the compiling 
process proceeds and how a source program is transformed into 
intermediate representation (HIR and LIR). It is the shortest way 
of understanding how the compiler infrastructure works and 
understanding HIR, LIR, and symbol table that are used as
interfaces between compiler components.<p>

Please try to compile several short programs specifying 
debug-print option in such way as
<pre>
java -classpath ./classes coins.driver.Driver -S -coins:trace=HIR.1/LIR.1/Sym.1 sample.c
</pre>
(See <a href='./driver.html'>2. How to use the Compiler Driver</a>
and 
<a href='./cc.html'>3. How to use C Compiler</a>.) 


<h3 id='i-1-2'>1.2. Structure of the COINS Compiler Infrastructure</h3>

<h4 id='i-1-2-1'>1.2.1. Overall Structure</h4>

The COINS compiler infrastructure is composed of 3 major parts.<br>
The front-end part translates the source program into HIR (High-level 
Intermediate Representation).<br> The middle part converts HIR into LIR 
(Low-level Intermediate Representation) and also does optimization and 
parallelization transformations on HIR or LIR.<br> The back-end part generates
the assembler code of the target machine from LIR.<br>
Additional management 
part contains miscellaneous functions such as compiler control,
HIR management, and symbol management.<br>
The overall structure of COINS is shown in Fig.1-1.
<center>
<img src="COINSstruct.en.jpg" ><br>
<font size=3>Fig.1-1 Overall Structure of COINS</font><p>
</center>

The concrete representation of HIR is a tree.
An HIR tree is an abstract representation of a source program. It reflects 
logical structure of the source program such as subprogram, 
block, statement, expression, compound variable, simple variable, 
constant, and so on. Every language constructs in HIR has a type
such as int, float, vector, struct, union, and so on.
HIR is designed so as to be able to represent programs of various 
languages such as C, Fortran, Pascal.<p>

LIR is an abstract representation of machine language program.
In LIR, operations are decomposed into elementary operations 
such as SET, JUMP, CALL, etc. with simple or compound operands.
The operands may represent memory, register, or expression.
Data type of LIR corresponds to data type handled in machines 
such as integer, float of some bit length.<p>
 LIR is a language 
that can represents not only operations but also the entire program 
providing features to describe a module (a collection of functions), memory area, and data.
Semantics of LIR is defined rigorously according to the
denotational semantics to avoid misunderstanding.<p>

<h4 id='i-1-2-2'>1.2.2. Classes and Interfaces</h4>

The compiler infrastructure is entirely written in Java. <br> 

 The intermediate language managers (HIR), symbol table
 manager (Sym), and flow analyzer (Flow) are described in 
 interface modules such as HIR0.java (plain HIR interface), HIR.java (full HIR interface), Sym0.java (plain Symbol table interface), Sym.java (full Symbol table interface), Flow.java.<br>
 Their implementation modules are HIR_Impl.java,
 SymImpl.java, and FlowImpl.java. <br>
 Detailed specifications of access methods are described
 in the interface modules so that it is not necessary to see
 implementation modules except for some special cases.<p>
  
 In order to make a compiler based on the COINS infrastructure
 or to modify a compiler based on the infrastructure, 
 it is necessary to read
<ul>
<li>Driver.java  :&emsp;&emsp; Compiler control 
<li>HIR0.java  :&emsp;&emsp;  Plain HIR interface
<li>Sym0.java  :&emsp;&emsp;   Plain Symbol table interface
<li>Flow.java  :&emsp;&emsp;   Control flow analyzer, data flow analyzer interface
</ul>
 and then their sub-interfaces, if you cannot get sufficient
 information. Some important sub-interfaces to be read are
<ul>
<li>HIR.java  :&emsp;&emsp;   Full HIR interface (under HIR0)</li>
<li>Sym.java   :&emsp;&emsp;    Full Symbol table interface (under Sym0)</li>
<li>Type.java  :&emsp;&emsp;    Type interface (under Sym)</li>
<li>Subp.java  :&emsp;&emsp;     Subprogram interface (under Sym)</li>
<li>SubpDefinition.java  :&emsp;&emsp;  Subprogram definition interface (under HIR)</li>
<li>Stmt.java   :&emsp;&emsp;   Statement interface (under HIR)</li>
<li>SubpFlow.java  :&emsp;&emsp; Subprogram flow interface (under Flow)</li>
<li>BBlock.java  :&emsp;&emsp;  Basic block interface (under Flow)</li>
</ul>
 Machine dependent parameters and methods are concentrated in
<ul>
<li>coins.MachineParam.java.</li>
</ul>
 Source language dependent parameters and methods are concentrated in
<ul>
<li>coins.SourceLanguage.java.</li>
</ul>
 Information requiring mutual exclusion between individual compilers
 are concentrated in
<ul>
<li>coins.Registry.java.</li>
</ul>
<p>
 Usage of methods is usually described in upper interfaces 
 so that it is not necessary to read lower interfaces.
 Methods are interrelated and there may be restrictions
 in invoking them. In upper interfaces, many upper methods are 
 provided to make the use of access methods simple.
 You will misuse the access methods if you read lower interfaces
 or read implementation modules before reading upper interfaces.<p>
 
 There are several classes that contains global information
 and methods available to all over the compiler infrastructure. 
 They are placed in "coins" package. Some of them are 
<ul>
<li>IoRoot.java:&emsp;&emsp;    Root of I/O file and all internal information. </li>
<li>SymRoot.java:&emsp;&emsp;  Root of symbol information.</li>
<li>IrRoot.java :&emsp;&emsp;     Root of IR information.</li>
<li>HirRoot.java :&emsp;&emsp;    Root of HIR information</li>
<li>FlowRoot.java:&emsp;&emsp;    Root of control flow and data flow information.</li>
<li>CompileError.java:&emsp;&emsp; Compiler error handling class.</li>
<li>FatalError.java:&emsp;&emsp;  Fatal error handling class.</li>
<li>Debug.java:&emsp;&emsp;      Compiler debug control class.</li>
<li>Registry.java :&emsp;&emsp;   Information requiring mutual exclusion between individual compilers.</li>
</ul>
The package structure of the infrastructure is the following, 
where "*" means
  language dependent packages, and "**" means machine dependent packages. 
<pre>
    *cfront    -- C parser converting C to AST (abstract syntax tree for C)
    *ast       -- Classes to generate AST for C
      *expr    -- AST expression generation
      *stmnt   -- AST statement generation
    *ffront    -- Fortran77 parser translating Fortran77 to HIR 
    coins      -- Infrastructure of the COINS compiler
      driver     -- Compiler driver
      *casttohir -- C AST to HIR translator
      ir         -- Intermediate representation IR
        hir      -- High level intermediate representation HIR
        lir      -- Obsolete 
      sym        -- Symbol table
      hir2lir    -- HIR to old LIR converter 
      aflow      -- Control flow and data flow analyzer for HIR
      flow       -- Obsolete
      alias      -- Alias analyzer
      opt        -- Basic optimizer
      ssa        -- SSA form optimizer for LIR 
      lparallel  -- loop parallelizer
      mdf        -- Coarse grain parallelizing module (SMP parallelizer)
      simd       -- SIMD parallelizer
      snapshot   -- Make snap shot file (XML file) for the visualizer
      back-end   -- Back-end
        ana      -- Control flow analyzer for LIR
        cfg      -- Control flow graph builder for LIR
        **gen    -- Code generator and target machine descriptions
                    other than SPARC and x86
        lir      -- LIR manager
        opt      -- Backend optimizer
        regalo   -- Register allocator
        sched    -- Instruction scheduler
        sym      -- LIR symbol manager
        **targets -- Machine parameter table interface
        **tmd    -- Target machine description (SPARC and x86)
        util     -- Backend utility
      hir2c      -- HIR to C translator
      lir2c      -- LIR to C translator
</pre>

<h3 id='i-1-3'>1.3. Construction of a Compiler based on the COINS Infrastructure</h3>

<h4 id='i-1-3-1'>1.3.1. Compiler Control</h4>

The compiler driver described in coins.driver.Driver.java controls the execution 
of the COINS C compiler. It contains definitions of compiler options and 
invocation statements for compiler components. 
The procedure of component invocation is described in the method 
compile(....) in Driver.java. 
See <a href="./driver.html">2. How to use the Compiler Driver</a> for details.<p>
To change the 
sequence of component invocations and to add, replace, delete 
some compiler components, Driver.java may be changed.
It would be better to make a subclass of Driver.java and 
override some of Driver's methods appropriately.
See, for example, <a href="http://www.coins-project.org/international/advanceduse/compilerDevelopE.html">
http://www.coins-project.org/international/advanceduse/compilerDevelopE.html</a>.<p>

The infrastructure does not use static fields except for 
"static final" in order to make it possible to develop a compiler where
its components can be executed in concurrent. All methods except 
for some ones in Root classes (classes such as IoRoot, SymRoot, 
HirRoot, LirRoot, etc.) are non-static methods and should be 
applied to instances.<p>

The compiler driver instantiates IoRoot first and supplies
source file, object file, print file, etc. (See getSourceFile(),
printOut, objectFile, msgOut, etc. in IoRoot.java). All compiler
components should convey the instance of IoRoot (ioRoot) directly 
or indirectly and make it protected or public so that it can be 
accessed directly or indirectly from methods in the component. <p>
In more detail, objects of other Root classes include a reference to 
the instance of IoRoot in order to enable input/output operations.
All Sym objects include a reference to SymRoot object,
all HIR objects include a reference to HirRoot,
and so on. In this way, almost all classes has a link to
the IoRoot directly or indirectly in order to enable
input/output operations in their methods. 
IoRoot has such methods as  
<pre>
  getSourceFile(), getSourceFilePath(), getCompileSpecification() 
</pre>
to access files and compile specifications given by command line.
<p>

As the next step, the compiler driver instantiates SymRoot to 
make symbol information be shared between compiler components.
All Sym objects such as symbol table and entries in the symbol
table (variable, subprogram, constant, type, etc.) contain a
reference to the SymRoot object so that methods of Sym class
and IoRoot class can be invoked. The symbol tables are nested
reflecting scope of symbols and organized into tree structure.<p>

The root of the symbol tables is named as symTableRoot. The 
symbol table currently effective is called current symbol table
and named as symTableCurrent. They are accessed from SymRoot
object. Built-in symbols representing basic types, etc. are
registered in symTableRoot and can be accessed from SymRoot
object, hence they can be accessed from all methods under 
Sym and its subclasses. <p>

The compiler driver instantiates HirRoot and then invokes
some parser such as C parser that translates source program
into HIR. The parser should convey the instance of HirRoot
to its components so that they can access I/O files, symbol
tables, and HIR information. The super class of HirRoot is
IrRoot where the root of intermediate representation (IR) of 
input source program is recorded as programRoot. 
The IrRoot is also the super class of HirRoot. 
HIR representation of input program can be traced 
starting from programRoot. <p>

The compiler driver may either parse all subprograms in a source 
file before code generation, or repeat parsing and code generation 
for each subprogram in the source file. In the former case, 
inter-procedural optimization and parallelization may be 
possible but consumes large memory space. In the later case, 
required memory space is relatively small but the possibility 
of inter-procedural optimization is limited.<p>

Error messages and warning messages are issued by invoking
put method of Message class in "coins" package.
The number of messages issued is counted for each group
of messages. Compiler implementers may prepare their own
error handlers that invokes the put method in order to provide
some information peculiar to each component such as source program
line number. (See Message.java.)<p>

It is often required to see the status of compiler for debugging.
The method 
<pre>
   void print(int pLevel, String pAt, String pMessage) 
</pre>
in the class Debug in coins package prints pAt and pMessage if 
pLevel is less or equal to the debug level specified by command line. 
Its usage is illustrated by
<pre>
    hirRoot.ioRoot.dbgHir.print(4, "subpNode", pSubp.getName());
</pre>
(See Debug.java.)<p>

<h4 id='i-1-3-2'>1.3.2. Getting Triggers of Intermediate Representation</h4>

In the process of parsing, the list of subprogram definitions will
be constructed (by addSubpDefinition() of coins.ir.hir.Program
called in the parser). Each subprogram definition can be get by
using iterator in such way as
<pre>
    coins.ir.IrList lSubpDefList
      = ((Program)hirRoot.programRoot).getSubpDefinitionList();
    Iterator lSubpDefIterator = lSubpDefList.iterator();
    while (lSubpDefIterator.hasNext()) {
      SubpDefinition lSubpDef = (SubpDefinition)(lSubpDefIterator.next());
      ....
    }
</pre>
where, hirRoot refers to the HirRoot object.<br>
The subprogram defined by the subprogram definition is get by
<pre>
    Subp lSubp = lSubpDef.getSubpSym();
</pre>
The symbol table local to the subprogram is get by
<pre>
    SymTable lSymTable = lSubp.getSymTable();
</pre>
or
<pre>
    SymTable lSymTable = lSubpDef.getSymTable();
</pre>
The procedural body of the subprogram is get by
<pre>
    HIR lHirSubpBody = lSubp.getHirBody();
</pre>
or 
<pre>
    HIR lHirSubpBody = lSubpDef.getHirBody();
</pre>
(See IrLisr of coins.ir, SubpDefinition, HirIterator of coins.ir.hir, 
Subp of coins.sym)<p>

Every HIR nodes of the subprogram lSubp can be traversed by using
HirIterator in such a way as
<pre>
    for (HirIterator lHirIterator 
           = hirRoot.hir.hirIterator(lSubp.getHirBody());
         lHirIterator.hasNext(); ) {
      HIR lNode = lHirIterator.next();
      ....
    }
</pre>
All statements in the subprogram can be traversed by a coding sequence
such as
<pre>
    for (HirIterator lHirIterator 
          = hirRoot.hir.hirIterator(lSubp.getHirBody());
         lHirIterator.hasNextStmt(); ) {
      Stmt lStmt = lHirIterator.getNextStmt();
      ....
    }
</pre>
Note that some node or statement may be null and it is better to do
null-check before applying methods to them.<p>

To catch node or statement of some particular class during the
traversing procedure, such coding as
<pre>
    if (lNode instanceof VarNode) { .... }
    if (lNode instanceof SubpNode) { .... }
    if (lStmt instanceof AssignStmt) { .... }
</pre>
will be convenient. They may be also caught by such coding as
<pre>
    if (lStmt.getOperator() == HIR.OP_VAR) { .... }
</pre>
Another way of coding is to use HirVisitor in such a way as
<pre>
    public class 
    ProcessHirNode extends coins.ir.hir.HirVisitorModel1
    {
      public final HirRoot
      hirRoot;

      public 
      ProcessSymNode( HirRoot pHirRoot )
      {
        super(pHirRoot);
        hirRoot = pHirRoot;
      }

      public void
      processSymNode( Subp pSubp )
      {
        hirRoot.symRoot.subpCurrent = pSubp;
        visit(pSubp.getHirBody());
      }

      protected void
      atVarNode( VarNode pVarNode )
      {
        ....
      }

      protected void
      atSubpNode( SubpNode pSubpNode )
      {
        ....
      }
      ....
    }
</pre>
(See HIR, HirVisitor, HirVisitorModel1, HirVisitorModel2 in 
coins.ir.hir.)<p>

To scan all symbols recorded in symbol tables, iterators are
provided in SymTable interface. A coding sequence
<pre>
    for (SymIterator lIterator = lSymTable.getSymIterator();
         lIterator.hasNext(); ) {
      Sym lSym = lIterator.next();
      .....
    }
</pre>
traverses all symbols recorded in the symbol table lSymTable.
If SymIterator is applied to symTableRoot, all global symbols 
in the given program unit are traversed.<p>

Another coding sequence
<pre>
    for (SymNestIterator lIterator = lSymTable.getSymIterator();
         lIterator.hasNext(); ) {
      Sym lSym = lIterator.next();
      .....
    }
</pre>
traverses all symbols recorded in the symbol table lSymTable and
its descendent symbol tables. If SymNestIterator is applied to
symTableCurrentSubp, all symbols local to the current subprogram
are traversed. If SymNestIterator is applied to symTableRoot,
all symbols recorded in the given program unit except constants
in symTableConst are traversed. <p>

The next coding sequence 
<pre>
    for (SymTableIterator lTableIterator = lSymTable.getSymTableIterator();
         lTableIterator.hasNext(); ) {
      SymTable lSymTableCurr = lTableIterator.next();
      for (SymIterator lSymIterator = lSymTableCurr.getSymIterator();
         lSymIterator.hasNext(); ) {
        Sym lSym = lSymIterator.next();
        ......
      }
    }
</pre>
will traverse all symbol tables under lSymTable and all symbols 
in the traversed symbol tables examining attributes of the traversed
symbol tables. <p>


<h4 id='i-1-3-3'>1.3.3. Symbol Handling</h4>

<h5 id='i-1-3-3-1'>1.3.3.1. Factory Methods</h5>

Construction of Sym and HIR are done by factory methods, 
that is, objects of Sym and HIR are not usually 
constructed by invoking constructors directly but by invoking 
factory methods. The factory methods of Sym are described
in the Sym interface (Sym.java). Examples of the usage of
factory methods are shown in <a href='./SimpleMain.java'>SimpleMain.java</a>.

<h5 id='i-1-3-3-2'>1.3.3.2. Subprograms, Variables, Constants</h5>

A subprogram symbol can be constructed in such coding as
<pre>
Subp lSubp = symRoot.sym.defineSubp("sub1".intern(), symRoot.sym.typeInt);
</pre>
where, the first parameter specifies subprogram name and
the second parameter specifies return value type. 
symRoot refers to SymRoot object. If symRoot is not 
accessible directly but hirRoot is accessible, replace 
symRoot in the above coding by hirRoot.symRoot.
String parameters for Sym, HIR methods should have
.intern() in order to make unique String object that 
can be compared by "==" operator instead of the "equals" method.
All String objects returned by Sym, HIR methods
are unique String object and need not to have .intern().
(See Sym0.java, Sym.java, HIR0.java, HIR.java.)<p>

Similarly, a variable symbol can be constructed by
<pre>
Var lVar = symRoot.defineVar("var1".intern(), symRoot.typeFloat);
</pre>
Integer constant, long int constant can be made by
<pre>
IntConst lIntConst1 = symRoot.sym.intConst(123, symRoot.typeInt);
IntConst lLongConst1= symRoot.sym.intConst(123, symRoot.typeLong);
IntConst lIntConst2 = symRoot.sym.intConst("123".intern(), symRoot.typeInt);
</pre>
and floating constant can be made by
<pre>
FloatConst lPai = symRoot.sym.floatConst(3.14, symRoot.typeFloat);
FloatConst lDoubleConst1 = symRoot.sym.floatConst(1.2, symRoot.typeDouble);
</pre>
For mode detail, see the Sym interface (Sym0.java and Sym.java).<p>

Care should be taken in making a string constant because the 
representation of character string differs by language. For example,
a string constant in C has trailing "\0" and may contain preceding
escape character for some special characters. A string constant is 
recorded as a pure string (processing escape characters by 
makeStringBody of coins.SourceLanguage) that is language independent. 
To make a string for C language from the pure string, makeCstring method 
is provided, for Java language, makeJavaString method is provided, 
and so on.<p>

<h5 id='i-1-3-3-3'>1.3.3.3. Symbol Table</h5>

All symbols are recorded in some symbol table.
The interface of the symbol table is SymTable (SymTable.java).
An instance of SymTable is created for each scope
of symbols corresponding such language constructs
as program, subprogram, struct, etc.<p>

Several symbol tables are constructed according to the
structure of given source program.
At first, a global symbol table is created by initiate()
of SymRoot and symbols inherent to the COINS infrastructure
are recorded in it. The symbols inherent to the COINS compiler
infrastructure are such ones as basic types and bool constants.
Types of each source language are mapped to the corresponding
types of the COINS compiler infrastructure in such way as
<pre>
    C int            COINS int
    C array          COINS vector
    Fortran INTEGER  COINS int
    Fortran REAL     COINS float
</pre>
When a new scope of symbols is opened, a new symbol table is
to be created and linked to ancestor symbol table that contains
symbols to be inherited by the new scope (pushSymTable()).
When the current scope is closed, the current symbol table is
to be closed by which the ancestor symbol table becomes the 
current symbol table again (by using popSymTable()).<p>

Symbols are searched in the current symbol table 
(symTableCurrent of SymRoot) and its ancestors in the reverse 
order of scope addition. The methods pushSymTable and popSymTable 
changes symTableCurrent when they are called.
Popped symbol table is not discarded unless it is empty but
made invisible for search procedures so as to make
inter-procedure optimization and parallelization can be done.
A symbol table usually has corresponding program construct
such as subprogram and it is called as the owner of the symbol
table. There are links between such constructs (owner) and 
corresponding symbol table to show their correspondence (getOwner). 
Anonymous construct (anonymous Struct, BlockStmt, etc.) may have 
name generated by the compiler.

<h5 id='i-1-3-3-4'>1.3.3.4. Scope of Symbols</h5>

Source program symbols (symbols appearing in source program)
have their scope as defined by the grammar of the language.
Each Struct and Union opens a new scope.
Scope of constants is the entire compile unit.
Scope of temporal variables generated by the compiler
is the subprogram within which the temporal variables
are defined.<p>

Symbols may have indication of scope (extern, public, private,
compile_unit, etc.) and variables may have indication of
storage class (static, automatic, etc.). In storage allocation
and symbol treatment in code generation, these indications and
nesting of symbol tables should be properly treated. Care should
be taken that one subprogram may have nested symbol tables.
Nesting of subprograms is treated as the nesting of corresponding
symbol tables.<p>

<h5 id='i-1-3-3-5'>1.3.3.5. SymRoot</h5>

SymRoot class is used to access Sym (symbol) information and
information prepared by other classes such as IoRoot, HIR, etc.
All Sym objects contain a reference to the SymRoot object
from which symbol information and methods can be quickly accessed. 
The SymRoot object contains a reference to IoRoot.
Thus, every Sym objects can access input/output methods, too.
SymRoot contains SymTable references:
<pre>
    symTableRoot    // Root of SymTable.
    symTableConst   // Constant table.
    symTableUnique  // SymTable that contains generated unique name.
    symTableCurrent // Referes to the symbol table for subprogram, 
                    // etc. under construction or under processing.
    symTableCurrentSubp // Symbol table of current subprogram. Some kinds of
                        // symbols (Type, Label, tmporal variable, etc.) are
                        // registered not in symTableCurrent
                        // but in symTableCurrentSubp.
</pre>
The subprogram under construction or processing is recorded in
subpCurrent of SymRoot.<p>
In parsing, flow analysis, optimization, code generation, etc.,
it is strongly recommended to set SymTableCurrent, subpCurrent,
symTableCurrentSubp as it is exemplified 
in <a href='./SimpleMain.java'>SimpleMain.java</a>. <p>
They are used in searching/generating symbols.
If new symbols are to be created in such processing, 
SymTableCurrent and subpCurrent should be set properly.
Several methods such as sym/pushSymTable, sym/popSymTable, 
aflow/subpFlow keeps such consistency automatically as
it is described in explanations of these methods.<p>
pushSymTalbe/popSymTable methods should be used in parsers but 
should not be used in optimization, code generation, etc. because 
pushSymTable creates a new SymTable corresponding to a new scope
in input source program.<p>

SymRoot contains type symbols of base types such as
typeBool, typeChar, typeInt, etc. as predefined symbols.<p>

<h5 id='i-1-3-3-6'>1.3.3.6. Type</h5>

Symbols such as variables, subprograms, constants have type.
The type is represented by a type symbol.
Types used in HIR are classified into base type and introduced
type. 
<pre>
    Base type (type intrinsic to HIR):
      int        represented by typeInt   of SymRoot
      float      represented by typeFloat of SymRoot
      ....       (see SymRoot)
    Introduced type (type introduced by the input program):
      pointer type     represented by the class PointerType
      vector type      represented by the class VectorType
      structure type   represented by the class StructType
      union type       represented by the class UnionType 
      enumeration type represented by the class EnumType
      subprogram type  represented by the class SubpType
      defined type     represented by the class DefinedType 
</pre>
A pointer type is defined by pointer indication (* in C) and
the type of the target of the pointer.<br>
A vector type is derived from element type by specifying the type
of vector element and the number of elements in the vector.<br>
A structure type is defined by specifying its elements
that may represent object different with each other.<br>
A union type is defined by specifying overlaid elements.<br>
A subprogram type is defined by specifying type of parameters
and the type of return value.<br>
An enumeration type is defined by specifying enumeration
literals representing some integer value.<br>
Defined types may be a renaming of base type or a compound
type that is derived from base type or defined type.<p>

Type symbols are created by factory methods in Sym interface. 
The factory methods for type creation are baseType, pointerType, 
vectorType, structType, unionType, enumType, subpType
and definedType.<p>

The structure of SubpType, StructType, UnionType, and EnumType 
are a little complicated. It is not recommended to use subpType
directly but it is recommended to use defineSubp of Sym interface
that defines both subprogram symbol and subprogram type.
For making type instance of StructType, UnionType, or EnumType,
read carefully the explanation of the corresponding method
structType, unionType, or enumType of Sym interface.<p>

In order to define a subprogram symbol,
<pre>
    make the subprogram symbol by defineSubp(...),
    add formal parameters by addParam(....),
    close the subprogram declaration by closeSubpHeader(....)
</pre>
in such a way as
<pre>
    Subp lSubp = symRoot.sym.defineSubp("name".intern(), returnType);
    SymTable lSubpSymTable = symRoot.symTableCurrent.pushSymTable(lSubp);
    lSubp.addParam(param1);
    lSubp.addParam(param2);
    ....
    lSubp.setOptionalParam(); // Not required if it has no optional parameter.
    lSubp.closeSubpHeader();
    Var lVar1 = lSubpSymTable.defineVar("a".intern(), symRoot.typeInt);
    ....
    symRoot.symTableCurrent.popSymTable();
</pre>
Above procedure will make a subprogram object with
inevitable fields such as parameter list,
return value type, and subprogram type.<br>
closeSubpHeader() will make subprogram type of the form
<pre>
  &lt;SUBP &lt; paramType_1 paramType_2 ... > returnValueType
        optionalParam >
</pre>
where, paramType_1, paramType_2, ... are parameter type,
returnValueType is return value type,
optionalParam is true or false depending on whether optional
parameter ("..." in C) is specified or not.<br>
pushSymTable(lSubp) makes new symbol table owned by the subprogram
lSubp and makes it symTableCurrent. lSubpSymTable.defineVar( .... )
defines a variable as an element of lSubpSymTable. popSymTable()
makes lSubpSymTable invisible form symbol serach procedure and makes
the previous symbol table as symTableCurrent.<p>

To make a structure type, structType method is provided in Sym
interface. Users may understand how to use it by following example:
    As for
<pre>
       struct listNode {
         int nodeValue;
         struct listNode *next;
        } listAnchor, listNode1;
</pre>
    following coding will make corresponding StructType.
<pre>
      Sym lTag = symRoot.symTableCurrent.generateTag("listNode".intern());
      StructType lListStruct = sym.structType(null, lTag); // Incomplete type.
      PointerType lListPtrType = sym.pointerType(lListStruct);
      PointerType lIntPtrType = sym.pointerType(symRoot.typeInt);
      symRoot.symTableCurrent.pushSymTable(lListStruct);
      Elem lValue = sym.defineElem("nodeValue".intern(), symRoot.typeInt);
      Elem lNext  = sym.defineElem("next".intern(), lListPtrType);
      lListStruct.addElem(lValue);
      lListStruct.addElem(lNext);
      lListStruct.finishStructType(true);
      symRoot.symTableCurrent.popSymTable();
</pre>
Methods are provided to get information of introduced types:
<pre>
    getSizeValue     of Sym interface
    getPointedValue  of Sym interface
    getElemCount     of VectorType interface
    getElemList      of StructType interface
    getParameterTypeList of SubpType interface
    ....
</pre>

<h5 id='i-1-3-3-7'>1.3.3.7. Generation of Temporal Variables and Labels</h5>

In compilers, temporal variables are often required to be generated 
for optimization, code generation, etc.
A method 
<pre>
    public Var generateVar( Type pType );
</pre>
is provided in the SymTable interface to generate a temporal variable
in the symbol table local to the current subprogram (symTableCurrentSubp).<p>

In order to generate labels, a method 
<pre>
    public Label generateLabel();
</pre>
is provided in the SymTable interface. It generates a label
in the symbol table local to the current subprogram (symTableCurrentSubp).<p>

<h5 id='i-1-3-3-8'>1.3.3.8. Representation of Symbol in Text Form</h5>

The method toString() gives the representation of a symbol 
in text form. It may be used for debug purpose, etc.
toStringShort() shows short description and toStrindDetail()
shows full description of the symbol.<p>

<h4 id='i-1-3-4'>1.3.4. HIR Handling</h4>

<h5 id='i-1-3-4-1'>1.3.4.1. Getting Information of HIR</h5>

HIR can be instantiated and handled mostly by using methods in
HIR0 (plain HIR interface). Simple compilers can be constructed 
by using methods in HIR0 and Sym0 interfaces. In constructing 
more complicated compiler, use methods in HIR and Sym. HIR inherits HIR0
and Sym inherits Sym0. In the following explanations, HIR may be read as
HIR0 in most cases.
<p>

Most of HIR constructs have correspondence to some source language
constructs, e.g.
<pre>
    SubpDefinition - subprogram definition
    Stmt           - statement
    AssignStmt     - assign statement
    LoopStmt       - loop statement
    BlockStmt      - block statement
    Exp            - expression
    VarNode        - variable
    ConstNode      - constant
</pre>

Subcomponent of HIR constructs can be get by methods provided
in each HIR subclass (interface that extends HIR). For example,
<pre>
    getLeftSide(), getRightSide() of AssignStmt
    getIfCondition(), getThenPart(), getElsePart() of IfStmt
    getLoopStartCondition(), getLoopBodyPart() of 
      ForStmt, WhileStmt, UntilStmt that extend LoopStmt
    getExp1(), getExp2() of Exp
    getSymNodeSym() of VarNode, ElemNode, ConstNode that extend SymNode
</pre>
As for detail, see corresponding interfaces that extend HIR.<p>

The subcomponents can be get also by specifying child number
by getChild1(), getChild2(), and getChild(int pChildNumber). 
In such coding, exact knowledge of HIR data structure is required. 
getChildCount of IR interface gives the number of children of HIR nodes.
(getChild1() and getChild2() have less overhead than getChild(1) and 
getChild(2).)
<p>

All HIR nodes have type attribute. It can be get by the method
getType. Some HIR nodes may have flags set during parsing, 
analysis, etc. The method getFlag(int pFlagNumber) returns 
the status of the flag indicated by pFlagNumber.

<h5 id='i-1-3-4-2'>1.3.4.2. Representation of HIR in Text Form</h5>

The method toString() gives the representation of an HIR node
in text form. It may be used for debug purpose, etc.
toStringShort() shows short description and toStrindDetail()
shows full description of the node.<p>

The method print(....) of HIR prints the subtree stemming from the 
specified node, that is, all subtrees of the specified node are 
printed recursively.<p>

<h5 id='i-1-3-4-3'>1.3.4.3. Normal Construction of HIR</h5>

HIR nodes can be constructed by methods defined in HIR interface.
Leafs of HIR tree are symbol node, list, etc. In HIR, symbols
are represented by symbol nodes having reference to some 
symbol table entry such as variable and subprogram.<p>

A Symbol node can be generated by factory methods of HIR.
<pre>
    VarNode lVarNode1     = hirRoot.hir.varNode(lVar1);
    SubpNode lSubpNode1   = hirRoot.hir.subpNode(lSubp);
    ConstNode lConstNode1 = hirRoot.hir.constNode(lIntConst1);
</pre>
will instantiate VarNode, SubpNode, ConstNode, each respectively.
hirRoot.hir, hirRoot.symRoot.sym, etc. may be shortened by local 
declarations
<pre>
    HIR hir = hirRoot.hir;
    Sym sym = hirRoot.symRoot.sym;
</pre>
Arithmetic expressions can be built by such coding as
<pre>
    Exp lExp1 = hir.exp(HIR.OP_ADD, lVarNode1, lConstNode1);
    Exp lExp2 = hir.exp(HIR.OP_MULT, lExp1, hir.varNode(lVar2));
</pre>
Assign-statement, if-statement, etc. are built by
<pre>
    Stmt lAssign1 = hir.assignStmt(lVarNode1, lExp1);
    Stmt lAssign2 = hir.assignStmt(lVarNode1, lExp2);
    Stmt lIf1 = hir.ifStmt(hir.exp(HIR.OP_CMP_EQ, lExp1,
               hir.constNode(0, symRoot.typeInt)), lAssign1, lAssign2);
</pre>
etc. <p>

<h5 id='i-1-3-4-4'>1.3.4.4. Top down Construction of HIR</h5>

HIR tree is usually constructed in bottom up manner starting from 
leafs and combining them as above. Top down construction is also
possible by attaching a subtree (leaf node or nonleaf node) to parent 
tree as its child.
<pre>
    setChild1( IR pChild1 ), setChild2( IR pChild2 ),
    setChild( int pChildNumber, IR pChild )
</pre>
of IR interface are available for such construction. The top down
construction requires knowledge of detailed structure of HIR tree.
Recommended way is bottom up construction by using the prepared
factory methods.<p>
 
In some cases, strict bottom up construction is difficult. For
example, in the construction of block statement and subprogram 
definition, most of their children are not known at first.
Several methods are provided to construct such subtrees.
They are explained in the next section.<p>
 
<h5 id='i-1-3-4-5'>1.3.4.5. Construction by Sequence of Statements</h5>
 
Block statement can be constructed by a statement sequence such as
<pre>
    BlockStmt lBlockStmt = hir.blockStmt(null);
    lBlockStmt.addLastStmt(lAssign1);
    lBlockStmt.addLastStmt(lIf1);
    ....
</pre>
(See HIR, BlockStmt in coins.ir.hir.)<p>

Subprogram can be constructed by such statement sequence as
<pre>
    Subp lMain = symRoot.sym.defineSubp("main".intern(), symRoot.typeInt);
    SymTable lSymTable = symRoot.symTableRoot.pushSymTable(lMain);
    lMain.closeSubpHeader();
    SubpDefinition lMainDef = hir.subpDefinition(lMain, lSymTable);
    BlockStmt lBlockStmt = hir.blockStmt(null);
    lMainDef.setHirBody(lBlockStmt);
    ....
    lBlockStmt.addLastStmt(lAssign1);
    ....
    symRoot.symTableCurrent.popSymTable();
</pre>
(In case of prototype declaration, use closeSubpPrototype instead of 
 closeSubpHeader.  See HIR, SubpDefinition, Subp, 
<a href='./SimpleMain.java'>SimpleMain</a>, etc.)<p>

IrList, HirList can be constructed by such statement sequence as
<pre>
    HirList lList = hir.irList();
    lList.add(....);
    ....
</pre>
(See HIR in coins.ir.hir, IrList in coins.ir.)<p>

<h5 id='i-1-3-4-6'>1.3.4.6. Note on HIR Construction and Transformation</h5>

An example of HIR generation is shown by <a href='./SimpleMain.java'>SimpleMain.java</a>.
 Readers can see how
to construct symbol table and HIR tree of a program. It may
be useful in coding new parser.<p>

It is possible to build Sym objects and HIR objects by invoking 
constructors of VarImpl, SubpImpl, VarNodeImpl, ConstNodeImpl, 
AssignStmtImpl, IfStmtImpl, etc. but such coding is not recommended.
Such coding may cause many errors because there are some hidden 
parameters supplied by factory methods and there are some preparatory 
methods to be applied to parameters.<p>

It should be noted that the structure of HIR is tree. Every 
nodes in the HIR tree should be created newly  and should not 
be shared because sharing of nodes violates the data structure
rule of tree. If a subtree same as some subtree X is required,
X should be copied by the method
<pre>
    X.copyWithOperands()
</pre>
if X is an expression or
<pre>
    X.copyWithOperandsChangingLabels()
</pre>
if X is a statement that may include label definitions.
The HIR method "isTree" checks whether the rule of tree structure
is violated or not. The method "isTree" is invoked automatically
if debug-print level of HIR is greater than 1 in Driver.java.<p>

When entire HIR subtree of a subprogram is constructed, finishHir()
should be called in such way as 
<pre>
    lSubpDefinition.finishHir();
</pre>
where lSubpDefinition represents SubpDefinition node of the subprogram.
The method finishHir() does such operations as giving index number to HIR 
nodes under the subtree, checking tree structure conformance, certificating
getHirPosition() for labels, and so on. When the HIR subtree of a subprogram
was changed in optimization and parallelization, then finishHir() should
also be called for the subtree. This method is not required to call for each
modification of statements ans expressions of SubpDefinition but at the end 
of creation or transformation of the entire SubpDefinition subtree.
<p>

<h5 id='i-1-3-4-7'>1.3.4.7. Indispensable Items and Optional Items</h5>

Syntactic structure of HIR is shown in HIR0.java and in HIR.java as comment lines.
Nonterminals that do not derive to null are indispensable items.
Nonterminals that derive to null are optional items.
There may be some exceptional nonterminal that derives to null
but represents indispensable item. Such case may happen in 
avoiding BNF productions to become too much verbose but such
case can be clearly discriminated by considering semantics.<p>


<h3 id='i-1-4'>1.4. Test Program Suite</h3>

<h4 id='i-1-4-1'>1.4.1. Overview</h4>

Under the directory &quot;test&quot; there are many small programs written
to test the COINS compiler infrastructure. The directory &quot;test/c&quot;
contains C test program suite composed of more than 1000 small C programs 
which are available to test C front-end and basic features of the COINS 
compiler infrastructure. The C test programs are grouped under many 
sub-directories such as Assign, Exp, If, Loop, etc.
(See &quot;README.c.txt&quot;, &quot;README.c-result-may-differ.txt&quot;, 
&quot;README.c-not-for-auto-test.txt&quot; under the &quot;test&quot; directory.)<br>

The C test program suite also contains expected execution results 
corresponding to each test program so that automatic test is possible
by compiling and executing the test programs and comparing the result
of execution for them. There are test programs that are not suitable 
for execution test, for example, programs to test syntax error detection,
programs to test implementation dependent features, and so on. Such
test programs are placed under the sub-directories named 
&quot;test/c/unsupported&quot; and &quot;test/c-result-may-differ&quot;.<br>

When some component of the COINS compiler infrastructure is modified
or added, it is recommended to test whether it is correctly executed
or not by using the test suite.

<h4 id='i-1-4-2'>1.4.2. Automatic test</h4>

<h5 id='i-1-4-2-1'>1.4.2.1. On Sparc machine</h5>

The test script
<pre>
    test/c/testdriver.sh
</pre>
is available to do automatic test for the C test program suite.
It can automatically compile and execute the programs in the
test program suite and compare the results with the corresponding
expected results. Following is an example of command sequence to do
such automatic test.
<pre>
    cd ./classes   -- Type at the root of the COINS compiler infrastructure.
    ../test/c/testdriver.sh -v ../test/c/*/*.c
    ../test/c/testdriver.sh -v ../test/c/*/*/*.c
</pre>
The first and the second invocations of &quot;testdriver.sh&quot; will do test by using 
test programs under the first level and the second level sub-directories, 
respectively. The result of the test will be shown by files which will be 
located under 
<pre>
    testdriver-yymmdd-hhmmss
</pre>
that is a directory created during the test.<br>

If &quot;Arg list too long&quot; message is issued in your environment by the command
<pre>
    ../test/c/testdriver.sh -v ../test/c/*/*.c
</pre>
then make a temporal directory such as &quot;test/c2&quot; and move several 
sub-directories such as TestFnami2, WhiteBox1, WhiteBox2 (that contain 
many files) to the temporal directory and execute
<pre>
    ../test/c/testdriver.sh -v ../test/c2/*/*.c
</pre>
as additional command.<br>

There is a command line
<pre>
    if ! java coins.driver.Driver -coins:${TARGET}preprocessor=\
      'cpp -I../lang/c/include' -S -o $CCCOUT $i &>$CCCLOG
</pre>

in &quot;testdriver.sh&quot;. You can change compile option by changing this line in such 
way as
<pre>
    if ! java coins.driver.Driver -coins:${TARGET},hirOpt=cse,preprocessor=\
       'cpp -I../lang/c/include' -S -o $CCCOUT $i &>$CCCLOG
</pre>
You can do automatic test by using test programs under some sub-directory only.
For example, if you want to do test by using test programs under 
Loop sub-directory only, give following command:
<pre>
    ../test/c/testdriver.sh -v ../test/c/Loop/*.c
</pre>
Some test programs under sub-directories &quot;test/c/unsupported&quot; and 
&quot;test/c-result-may-differ&quot; will cause error but it may be normal because 
each of them may be a test program to cause error. Result of these test
programs should be examined individually.<br>

Some test programs may require further investigation even if &quot;OK&quot; sign
is issued for them. For example, &quot;test/c/Opt&quot;, 
&quot;test/c/OptAdd&quot; and &quot;test/c/TestSsa&quot;
contain test programs for optimization and it is required to examine object 
codes generated.

<h5 id='i-1-4-2-2'>1.4.2.2. On Intel x86 machine and others </h5>  

If test is to be done on x86-cygwin, use &quot;test/c/testdriverw.sh&quot; 
instead of &quot;testdriver.sh&quot;. Its usage is the same as the 
&quot;testdriver.sh&quot; but it is required
to prepare expected results on x86 machine as explained in the next section.<br>
<br>
Note.<br>
  Target machine can be changed by command option in such way as
<pre>
    ../test/c/testdriver.sh -v -t x86-cygwin ../test/c/Loop/*.c
</pre>
but this command option is not yet reliable and in some environment,
this may not correctly work. It is better to use the test script
<pre>
   test/c/testdriverw.sh
</pre>
for x86-cygwin.<br>

As for other machine, please adjust the &quot;testdriver.sh&quot; to the machine.

<h4 id='i-1-4-3'>1.4.3. Preparation of expected results</h4>

<h5 id='i-1-4-3-1'>1.4.3.1. On Sparc machine</h5>

Currently, the expected results of the test programs are prepared by
using gcc compiler on Sparc machine. You can renew the expected results by 
the following command sequence:
<pre>
    cd ./classes
    ../test/c/testprepare.sh ../test/c/*/*.c
    ../test/c/testprepare.sh ../test/c/*/*/*.c
</pre>    
When you added or modified test programs, you should also renew the expected
results of the test programs added or modified.

<h5 id='i-1-4-3-2'>1.4.3.2. On Intel x86 machine and others</h5>

If you want to do test on a machine other than Sparc, you should renew
the expected results by using gcc compiler or some other existing compiler
on the machine. <br>

If test is to be done on x86-cygwin, use &quot;test/c/testpreparew.sh&quot; 
instead of &quot;testprepare.sh&quot;. Its usage is the same as the 
&quot;testdprepare.sh&quot;.<br>

As for other machine, please adjust the &quot;testprepare.sh&quot; to the machine.


  </body>
</html>
