<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.4.2_12) on Fri Sep 12 11:04:59 JST 2008 -->
<TITLE>
GlobalReform
</TITLE>

<META NAME="keywords" CONTENT="coins.opt.GlobalReform class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="GlobalReform";
}
</SCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../coins/opt/DeadCodeElim.html" title="class in coins.opt"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="GlobalReform.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
coins.opt</FONT>
<BR>
Class GlobalReform</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../resources/inherit.gif" ALT="extended by"><B>coins.opt.GlobalReform</B>
</PRE>
<HR>
<DL>
<DT>public class <B>GlobalReform</B><DT>extends java.lang.Object</DL>

<P>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Nested Class Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The class MatchingData represents various matching insormation
 and provides methods to set/refer them.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This class holds information for the instance of
 a nonterminal or a pattern and provides methods for them.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.OptInf.html" title="class in coins.opt">GlobalReform.OptInf</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OptInf is used to represent an object instanciated
 for each pattern and nonterminal.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.PatternCodeRange.html" title="class in coins.opt">GlobalReform.PatternCodeRange</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PatternCodeRange represents
 pattern code range including upper value and lower value.</TD>
</TR>
</TABLE>
&nbsp;
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fChanged">fChanged</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fCodeIndexFrom">fCodeIndexFrom</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fCodeIndexTo">fCodeIndexTo</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/driver/CoinsOptions.html" title="class in coins.driver">CoinsOptions</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fCoinsOptions">fCoinsOptions</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Set</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fCompileTimeEval">fCompileTimeEval</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/sym/Subp.html" title="interface in coins.sym">Subp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fCurrentPatternSym">fCurrentPatternSym</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/ir/hir/Stmt.html" title="interface in coins.ir.hir">Stmt</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fCurrentStmt">fCurrentStmt</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fDbgLevel">fDbgLevel</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fDontCareCode">fDontCareCode</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fExpandedNonterm">fExpandedNonterm</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fExpandedNontermInstance">fExpandedNontermInstance</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Set</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fFittingSet">fFittingSet</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Set</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fFitToAnyCall">fFitToAnyCall</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Set[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fFormalParams">fFormalParams</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fGlobalPatternParamMap">fGlobalPatternParamMap</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fHirCodeLim">fHirCodeLim</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fHirCodeLim2">fHirCodeLim2</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fHirCodeLim3">fHirCodeLim3</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fHirCodeLim4">fHirCodeLim4</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fHirCodeLim5">fHirCodeLim5</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fHirCodeLim6">fHirCodeLim6</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Set</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fHirKeys">fHirKeys</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fInPatternMap">fInPatternMap</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fInstanceNumberForNonterminals">fInstanceNumberForNonterminals</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fLastMatchingDataForNonterm">fLastMatchingDataForNonterm</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fLocalVarListMap">fLocalVarListMap</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fMatchingDataForNonterm">fMatchingDataForNonterm</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fMatchingDataForNontermInstance">fMatchingDataForNontermInstance</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fMaxStmtsInPattern">fMaxStmtsInPattern</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/ir/hir/Stmt.html" title="interface in coins.ir.hir">Stmt</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fNextStmt">fNextStmt</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fNextStmtCode">fNextStmtCode</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Set</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fNoFurtherChange">fNoFurtherChange</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.List</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fNonterminalList">fNonterminalList</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Set</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fNonterminalParameters">fNonterminalParameters</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Set</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fNonterminalSet">fNonterminalSet</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fNontermInstanceInPattern">fNontermInstanceInPattern</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/sym/Subp.html" title="interface in coins.sym">Subp</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fNontermPat">fNontermPat</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fNontermPatCount">fNontermPatCount</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fNontermPatInstanceOfCurrentPattern">fNontermPatInstanceOfCurrentPattern</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fOptionMap">fOptionMap</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fOriginalVarMap">fOriginalVarMap</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fOutPatternMap">fOutPatternMap</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fPatternCodeLower">fPatternCodeLower</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fPatternCodeUpper">fPatternCodeUpper</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fPatternCount">fPatternCount</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.List</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fPatternList">fPatternList</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Set</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fPatternParameters">fPatternParameters</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fProductionCount">fProductionCount</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fProductionMap">fProductionMap</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fProductionsInNonterminal">fProductionsInNonterminal</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fStmt1CodeIndexFrom">fStmt1CodeIndexFrom</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fStmt1CodeIndexTo">fStmt1CodeIndexTo</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fStmt2CodeIndexFrom">fStmt2CodeIndexFrom</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fStmt2CodeIndexTo">fStmt2CodeIndexTo</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Set</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fStmtParamSet">fStmtParamSet</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fStmtsInPattern">fStmtsInPattern</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.List</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fSubpToReform">fSubpToReform</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fSubrootCount">fSubrootCount</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/ir/hir/Stmt.html" title="interface in coins.ir.hir">Stmt</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fTailStmtMatched">fTailStmtMatched</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fTransparentMap">fTransparentMap</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fUsedAsPatternRoot">fUsedAsPatternRoot</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#fUsedAsSubRoot">fUsedAsSubRoot</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#hir">hir</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/HirRoot.html" title="class in coins">HirRoot</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#hirRoot">hirRoot</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/IoRoot.html" title="class in coins">IoRoot</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#ioRoot">ioRoot</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/SymRoot.html" title="class in coins">SymRoot</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#symRoot">symRoot</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#GlobalReform(coins.HirRoot)">GlobalReform</A></B>(<A HREF="../../coins/HirRoot.html" title="class in coins">HirRoot</A>&nbsp;pHirRoot)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructor GlobalTransform.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#adjustMatchingData(coins.opt.GlobalReform.MatchingData, java.util.Map)">adjustMatchingData</A></B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                   java.util.Map&nbsp;pParamCorresp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the HIR corresponding to pattern parameters
 that are given as keys of pParamCorresp which
 maps pattern parameters to primary HIR that may contain
 parameters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#adjustNonterminal(coins.opt.GlobalReform.MatchingData, coins.opt.GlobalReform.NontermPatInstance, coins.ir.hir.HIR, java.util.Set, int, boolean)">adjustNonterminal</A></B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                  <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A>&nbsp;pNontermPatInstance,
                  <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pCallNode,
                  java.util.Set&nbsp;pTraversedMatchingData,
                  int&nbsp;pNthInstance,
                  boolean&nbsp;pRevisedMatchingData)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Change a nonterminal call to a plain HIR subtree
 that has resolved parameters and nonterminal calls
 by executing following steps:
 (1) Get the instance of MatchingData lData1
   corresponding to the nonterminal call pCallNode.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#adjustOutPattern(coins.opt.GlobalReform.MatchingData, coins.ir.hir.HIR, java.util.Set, int)">adjustOutPattern</A></B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                 <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pOutHir,
                 java.util.Set&nbsp;pTraversedMatchingData,
                 int&nbsp;pNthInstance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adjust the out pattern pOutHir corresponding to the pattern/nonterminal
 represented by pData, that is,
 If pOutHir is a pattern/nonterminal param node, then
   replace it by the HIR corresponding to it;
 If pOutHir represents a nonterminal, then
   replace it by the expanded HIR corresponding to it
   invoking adjustNonterminal with a
   MachingData obtained by copying pData;
 If pOutHir represents
   _reform(n_th_instance, patternParam, replacementExp,
           nonterminalCallExp),
   then expand the nonterminal and then replace the pattern
   parameter (patternParam) contained in it with
   replacementExp and then replace the pattern parameters
   according to the correspondence given in pData.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#adjustType(coins.ir.hir.Exp, coins.sym.Type)">adjustType</A></B>(<A HREF="../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pExp,
           <A HREF="../../coins/sym/Type.html" title="interface in coins.sym">Type</A>&nbsp;pType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#checkConsistency(coins.sym.Subp, java.util.List, coins.ir.hir.HIR, coins.ir.hir.HIR)">checkConsistency</A></B>(<A HREF="../../coins/sym/Subp.html" title="interface in coins.sym">Subp</A>&nbsp;pPattern,
                 java.util.List&nbsp;pLocalVarList,
                 <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pInPattern,
                 <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pOutPattern)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Check the consistency of parameters in in-pattern
 and out-pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#computePatternCodeRange()">computePatternCodeRange</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;computePatternCodeRange
 compute pattern code range (fPatternCodeUpper and fPatternCodeLower)
 of all patterns.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/opt/GlobalReform.PatternCodeRange.html" title="class in coins.opt">GlobalReform.PatternCodeRange</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#computePatternCodeRangeOf(coins.ir.hir.HIR)">computePatternCodeRangeOf</A></B>(<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pHir)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;computePatternCodeRangeOf(.....) computes pattern code range
 of pHir and set upper to pUpper[0], loper to pLower[0].</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#dbgMap(java.util.Map)">dbgMap</A></B>(java.util.Map&nbsp;pMap)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;make the text string showing the contents of the map pMap.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#dbgOut(int, java.lang.String)">dbgOut</A></B>(int&nbsp;pLevel,
       java.lang.String&nbsp;pMessage)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#dbgOut(int, java.lang.String, java.lang.String)">dbgOut</A></B>(int&nbsp;pLevel,
       java.lang.String&nbsp;pMessageClass,
       java.lang.String&nbsp;pMessage)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#dbgSet(java.util.Set)">dbgSet</A></B>(java.util.Set&nbsp;pSet)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#doReform(java.util.List)">doReform</A></B>(java.util.List&nbsp;pReformPatternList)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doReform transforms subprograms listed up in
   #pragma globalReform target subp1 subp2 ...</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#evaluateReform(coins.opt.GlobalReform.MatchingData, coins.ir.hir.HIR, java.util.Set)">evaluateReform</A></B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
               <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pOutHir,
               java.util.Set&nbsp;pTraversedMatchingData)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Evaluate the special function _reform
 by calling reformByChangingParam( ...</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#expandExp(coins.opt.GlobalReform.MatchingData, coins.ir.hir.HIR, coins.opt.GlobalReform.NontermPatInstance)">expandExp</A></B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
          <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pExp,
          <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A>&nbsp;pParentNonterm)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Expand all nonterminal calls in pExp to the
 the expandedExp of the nonterminal instance corresponding
 to the nonterminal call.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#expandNonterminal(coins.opt.GlobalReform.MatchingData, coins.opt.GlobalReform.NontermPatInstance, coins.ir.hir.HIR, java.util.Set)">expandNonterminal</A></B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                  <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A>&nbsp;pNontermPatInstance,
                  <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pCallExp,
                  java.util.Set&nbsp;pTraversedNonterminals)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expandNonterminal expands the right hand side of the
 selected productin of the nonterminal pNontermPatInstance
 and return it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#expandOutPattern(coins.opt.GlobalReform.MatchingData, coins.ir.hir.HIR, java.util.Set)">expandOutPattern</A></B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                 <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pOutHir,
                 java.util.Set&nbsp;pTraversedNonterminals)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expandOutPattern expands pOutHir according to pData.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#getExpandedHir(coins.ir.hir.HIR, coins.opt.GlobalReform.NontermPatInstance)">getExpandedHir</A></B>(<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pCallExp,
               <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A>&nbsp;pNontermInstance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the expanded HIR corresponding to pCallExp
 calling pNonterminal.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#getFormalActualParamCorrespondence(coins.opt.GlobalReform.MatchingData, coins.opt.GlobalReform.NontermPatInstance, coins.ir.hir.HIR, boolean)">getFormalActualParamCorrespondence</A></B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                                   <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A>&nbsp;pNontermPat,
                                   <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pCallNode,
                                   boolean&nbsp;pAdjustPhase)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get formal-actual parameter correspondence for the nonterminal
 pNontermPat that is called by the node pCallNode and return the
 correspondence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#getIndex(coins.sym.Subp)">getIndex</A></B>(<A HREF="../../coins/sym/Subp.html" title="interface in coins.sym">Subp</A>&nbsp;pSubp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the index number of a pattern or a nonterminal.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Set</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#getLeafOperands(coins.ir.hir.HIR)">getLeafOperands</A></B>(<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pHir)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the set of leaf operands of pHir.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#getNontermInstance(coins.sym.Subp, coins.ir.hir.HIR, coins.opt.GlobalReform.NontermPatInstance)">getNontermInstance</A></B>(<A HREF="../../coins/sym/Subp.html" title="interface in coins.sym">Subp</A>&nbsp;pNonterm,
                   <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pCallExp,
                   <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A>&nbsp;pParentInstance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the instance of the nonterminal pNonterm corresponding
 to the nonterminal call expression pCallExp
 seeing callToNontermInstanceMap of the parent nonterminal
 pParentInstance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/sym/Param.html" title="interface in coins.sym">Param</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#getOriginalParam(coins.sym.Param)">getOriginalParam</A></B>(<A HREF="../../coins/sym/Param.html" title="interface in coins.sym">Param</A>&nbsp;pParam)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the original parameter from which pParam is instanciated.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/sym/Var.html" title="interface in coins.sym">Var</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#getOriginalVar(coins.sym.Var)">getOriginalVar</A></B>(<A HREF="../../coins/sym/Var.html" title="interface in coins.sym">Var</A>&nbsp;pVar)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the original variable from which pVar is instanciated.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#getParamCorrespForArgWithNonterm(coins.opt.GlobalReform.MatchingData, coins.ir.hir.HIR, coins.sym.Sym, coins.opt.GlobalReform.NontermPatInstance, boolean)">getParamCorrespForArgWithNonterm</A></B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                                 <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pArgExp,
                                 <A HREF="../../coins/sym/Sym.html" title="interface in coins.sym">Sym</A>&nbsp;pCallerFormalParam,
                                 <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A>&nbsp;pParentNonterm,
                                 boolean&nbsp;pAdjustPhase)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get formal-actual parameter correspondence for the formal parameter
 pCallerFormalParam and actual parameter pArgExp that calls
 child nonterminal.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/sym/Param.html" title="interface in coins.sym">Param</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#getParamInstance(coins.sym.Param, coins.opt.GlobalReform.NontermPatInstance)">getParamInstance</A></B>(<A HREF="../../coins/sym/Param.html" title="interface in coins.sym">Param</A>&nbsp;pParam,
                 <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A>&nbsp;pNontermInstance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the parameter instanciated from pParam for the
 instance of the nonterminal pNontermInstance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/sym/Var.html" title="interface in coins.sym">Var</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#getVarInstance(coins.sym.Var, coins.opt.GlobalReform.NontermPatInstance)">getVarInstance</A></B>(<A HREF="../../coins/sym/Var.html" title="interface in coins.sym">Var</A>&nbsp;pVar,
               <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A>&nbsp;pNontermInstance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the variable instanciated from pVar for the
 instance of the nonterminal pNontermInstance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#hirToString(coins.ir.hir.HIR)">hirToString</A></B>(<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pHir)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/sym/Param.html" title="interface in coins.sym">Param</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#instanciateParam(coins.sym.Subp, coins.sym.Param, int)">instanciateParam</A></B>(<A HREF="../../coins/sym/Subp.html" title="interface in coins.sym">Subp</A>&nbsp;pNonterm,
                 <A HREF="../../coins/sym/Param.html" title="interface in coins.sym">Param</A>&nbsp;pParam,
                 int&nbsp;pInstanceNumber)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a new instance of the parameter pParam used in
 the nonterminal pnonterm.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/sym/Var.html" title="interface in coins.sym">Var</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#instanciateVar(coins.sym.Subp, coins.sym.Var, int, int)">instanciateVar</A></B>(<A HREF="../../coins/sym/Subp.html" title="interface in coins.sym">Subp</A>&nbsp;pNonterm,
               <A HREF="../../coins/sym/Var.html" title="interface in coins.sym">Var</A>&nbsp;pVar,
               int&nbsp;pKind,
               int&nbsp;pInstanceNumber)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the new instance of the variable pVar.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#isFittingSym(coins.sym.Sym)">isFittingSym</A></B>(<A HREF="../../coins/sym/Sym.html" title="interface in coins.sym">Sym</A>&nbsp;pSym)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If pSym is a fitting symbol or an instance of a
 fitting symbol, then return true, else return false.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#isMatchedArray(coins.opt.GlobalReform.MatchingData, coins.ir.hir.HIR, coins.ir.hir.HIR, coins.opt.GlobalReform.NontermPatInstance)">isMatchedArray</A></B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
               <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pSubPattern,
               <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pHir,
               <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A>&nbsp;pAncestorNontermPatInstance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isMatchedArray discriminates whether HIR subtree pHir
 matches with the pattern pSubPattern (in-pattern or
 part of in-pattern) comparing pHir with pSubPattern
 where pHir or pSubPattern may be an expression
 representing an array (vector) or array element.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#isMatchedAssignStmt(coins.opt.GlobalReform.MatchingData, coins.opt.GlobalReform.NontermPatInstance, coins.ir.hir.HIR, coins.ir.hir.HIR, coins.opt.GlobalReform.NontermPatInstance)">isMatchedAssignStmt</A></B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                    <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A>&nbsp;pNontermInstance,
                    <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pNontermCall,
                    <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pHir,
                    <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A>&nbsp;pAncestorNontermPatInstance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Examine whether the assign statement pHir matches with
 the pattern specified by _assignStmt.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#isMatchedCondition(coins.opt.GlobalReform.MatchingData, coins.ir.hir.HIR, coins.ir.hir.HIR, coins.opt.GlobalReform.NontermPatInstance)">isMatchedCondition</A></B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                   <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pSubPattern,
                   <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pHir,
                   <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A>&nbsp;pAncestorNontermPatInstance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isMatchedCondition: Check comparison expression having different
 operation code, where either pSubPattern or pHir have
 comparison operator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#isMatchedNonterminal(coins.opt.GlobalReform.MatchingData, coins.opt.GlobalReform.NontermPatInstance, coins.ir.hir.HIR, coins.ir.hir.HIR, coins.opt.GlobalReform.NontermPatInstance)">isMatchedNonterminal</A></B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                     <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A>&nbsp;pNontermInstance,
                     <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pNontermCall,
                     <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pHir,
                     <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A>&nbsp;pAncestorNontermPatInstance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isMatchedNonterminal discriminates whether the nonterminal
 (pMetaSym) refered by pNonterminalCall matches with
 the input HIR tree pHir.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#isMatchedPattern(coins.opt.GlobalReform.MatchingData, coins.ir.hir.HIR, coins.ir.hir.HIR, coins.opt.GlobalReform.NontermPatInstance)">isMatchedPattern</A></B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                 <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pSubPattern,
                 <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pHir,
                 <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A>&nbsp;pAncestorNontermPatInstance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isMatchedPattern discriminates whether HIR subtree pHir
 matches with the pattern pSubPattern (in-pattern or a
 part of in-pattern) comparing pHir with pSubPattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#isMatchedStmtSeq(coins.opt.GlobalReform.MatchingData, coins.ir.hir.HIR, coins.ir.hir.Stmt, int, coins.opt.GlobalReform.NontermPatInstance)">isMatchedStmtSeq</A></B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                 <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pSubPattern,
                 <A HREF="../../coins/ir/hir/Stmt.html" title="interface in coins.ir.hir">Stmt</A>&nbsp;pStmt,
                 int&nbsp;pPatternIndex,
                 <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A>&nbsp;pAncestorNontermPatInstance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isMatchedStmtSeq discriminates whether HIR subtree
 matches with the pattern pSubPattern (in-pattern or
 part of in-pattern) that is a sequence of statements
 comparing the statement sequence starting with pStmt.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#isMatchedSubs(coins.opt.GlobalReform.MatchingData, coins.ir.hir.HIR, coins.ir.hir.HIR, coins.opt.GlobalReform.NontermPatInstance)">isMatchedSubs</A></B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
              <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pSubPattern,
              <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pHir,
              <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A>&nbsp;pAncestorNontermPatInstance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isMatchedSubs discriminates whether HIR subtree pHir
 matches with the pattern pSubPattern (in-pattern or
 part of in-pattern) comparing pHir with pSubPattern
 where pHir or pSubPattern may be an expression
 representing an array element.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#isNontermParam(coins.sym.Sym)">isNontermParam</A></B>(<A HREF="../../coins/sym/Sym.html" title="interface in coins.sym">Sym</A>&nbsp;pSym)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If pSym is a nonterminal parameter or an instance of a
 nonterminal parameter, then return true, else return false.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#isPatternParam(coins.sym.Sym)">isPatternParam</A></B>(<A HREF="../../coins/sym/Sym.html" title="interface in coins.sym">Sym</A>&nbsp;pSym)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If pSym is a pattern parameter or an instance of a
 pattern parameter, then return true, else return false.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#isSameTree(coins.ir.hir.HIR, coins.ir.hir.HIR)">isSameTree</A></B>(<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pTree1,
           <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pTree2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isSameTree is a little different from that of coins.flow.HirSubpFlowImpl.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#isTransparent(coins.sym.Var, coins.ir.hir.HIR, coins.opt.GlobalReform.MatchingData)">isTransparent</A></B>(<A HREF="../../coins/sym/Var.html" title="interface in coins.sym">Var</A>&nbsp;pDeclVar,
              <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pHir,
              <A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If pDeclVar is declared as transparent to some variables
 and if pHir contains any of such variables or
 pDeclVar is included in pHir then
 pHir is treated as not transparent to pDeclVar</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#listUpHeadingHir(coins.sym.Subp, java.util.List, coins.ir.hir.HIR)">listUpHeadingHir</A></B>(<A HREF="../../coins/sym/Subp.html" title="interface in coins.sym">Subp</A>&nbsp;pNontermPatSym,
                 java.util.List&nbsp;pHeadingHirList,
                 <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pHir)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List up top subtrees for pHir and add the subtrees to
 pHeadingHirList.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#makeHirKey(coins.ir.hir.HIR)">makeHirKey</A></B>(<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pExp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Make an HIR that can be used as a key of maps
 so that there is only one instance for each group of
 HIR subtrees where member subtrees have the same shape
 when they are included in the same group
 (keeping one to one correspondence between key
 and group).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#makeParamCorrespComplete(coins.opt.GlobalReform.MatchingData)">makeParamCorrespComplete</A></B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If a nonterminal param is mapped to a pattern param
 directly or indirectly (by tracing the sequence of
 nontermParam-to-nontermParam correspondence),
 then record the HIR corresponding to the nonterm parameter
 as the HIR corresponding to the pattern parameter.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#patternCode(coins.ir.hir.HIR)">patternCode</A></B>(<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pHir)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute the pattern code of pHir digging out up to 2 levels
 of children.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#postProcess(boolean, java.util.Map, coins.opt.GlobalReform.MatchingData)">postProcess</A></B>(boolean&nbsp;pMatched,
            java.util.Map&nbsp;pGlobalPatternParamMap,
            <A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If matching failed, then restore fGlobalPatternParamMap
 by their previous value pGlobalPatternParamMap.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#processTransparent(coins.sym.Subp, java.lang.String, coins.ir.IrList)">processTransparent</A></B>(<A HREF="../../coins/sym/Subp.html" title="interface in coins.sym">Subp</A>&nbsp;pPattern,
                   java.lang.String&nbsp;pOptionName,
                   <A HREF="../../coins/ir/IrList.html" title="interface in coins.ir">IrList</A>&nbsp;pOptionList)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Process the pragma specifications such as
   #pragma globalReform transparentFitting pc (pzz2, pi2)
 and record the transparency relations to fTransparentMap.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#putToMap(java.util.Map, coins.sym.Sym, coins.ir.hir.HIR)">putToMap</A></B>(java.util.Map&nbsp;pMap,
         <A HREF="../../coins/sym/Sym.html" title="interface in coins.sym">Sym</A>&nbsp;pSym,
         <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pHir)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Put the correspondence of pSym-pHir to pMap
 if it is not a circular reference that is,
 if pSym is not an operand of pHir.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#recordExpandedHir(coins.ir.hir.HIR, coins.ir.hir.HIR, coins.opt.GlobalReform.NontermPatInstance)">recordExpandedHir</A></B>(<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pCallExp,
                  <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pExpandedHir,
                  <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A>&nbsp;pNontermPatInstance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Record the copy of pExpandedHir to
   fExpandedNontermInstance using pNontermPatInstance as key and
   fExpandedNonterm using makeHirKey(pCallExp) as key.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#recordParamCorresp(coins.opt.GlobalReform.MatchingData, coins.sym.Sym, coins.ir.hir.HIR)">recordParamCorresp</A></B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                   <A HREF="../../coins/sym/Sym.html" title="interface in coins.sym">Sym</A>&nbsp;pParam,
                   <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pHir)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Record the correspondence between the parameter pParam and
 the (matched) input pHir.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#reformByChangingParam(coins.opt.GlobalReform.MatchingData, coins.ir.hir.HIR, coins.ir.hir.HIR, coins.ir.hir.HIR, java.util.Set, int)">reformByChangingParam</A></B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                      <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pNontermCall,
                      <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pParamNode,
                      <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pRewriteExp,
                      java.util.Set&nbsp;pTraversedMatchingData,
                      int&nbsp;pNthInstance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reformByChangingParam does the transformation specified by
   _reform(n_th_instance, patternParam, replacementExp,
            nonterminalCallExp).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#replaceExpAdjustingType(coins.ir.hir.Exp, coins.ir.hir.Exp)">replaceExpAdjustingType</A></B>(<A HREF="../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;lOld,
                        <A HREF="../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;lNew)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replace expression lOld by lNew adjusting type to
 that of lOld.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#replaceHirTree(coins.ir.hir.HIR, coins.ir.hir.HIR)">replaceHirTree</A></B>(<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pOld,
               <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pNew)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replace pOld with pNew according to their kind.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#replaceParameters(coins.opt.GlobalReform.MatchingData, coins.ir.hir.HIR, java.util.Set, boolean)">replaceParameters</A></B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                  <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pOutHir,
                  java.util.Set&nbsp;pTraversedMatchingData,
                  boolean&nbsp;pNontermParamOnly)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replace nonterminal/pattern parameters and fitting symbols
 contained in pOutHi by the HIR correnponding to the parameters
 or fitting symbols where the correspondence is given by pData.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#replaceStatementParameter(coins.opt.GlobalReform.MatchingData, coins.ir.hir.SymNode, java.util.Set, boolean)">replaceStatementParameter</A></B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                          <A HREF="../../coins/ir/hir/SymNode.html" title="interface in coins.ir.hir">SymNode</A>&nbsp;pSymNode,
                          java.util.Set&nbsp;pTraversedMatchingData,
                          boolean&nbsp;pNontermParamOnly)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replace the node of statement parameter with the sequence
 of statements corresponding to it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#setNonterminalFlag(coins.ir.hir.HIR)">setNonterminalFlag</A></B>(<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pPattern)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set FLAG_NONTERMINAL to all call nodes that call _bnfOr,
 _bnfSeq, or _assignStmt contained in pPattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#setPatternCodeRange(int, java.util.List)">setPatternCodeRange</A></B>(int&nbsp;pStartIndex,
                    java.util.List&nbsp;pRangeList)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the pattern code ranges in pRangeList to
 fPatternCodeUpper/Lower starting from pStartIndex and return
 the updated next index value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#traceParamCorresp(coins.opt.GlobalReform.MatchingData, coins.sym.Var, coins.ir.hir.HIR, boolean)">traceParamCorresp</A></B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                  <A HREF="../../coins/sym/Var.html" title="interface in coins.sym">Var</A>&nbsp;pParamInstance,
                  <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pMatchedHir,
                  boolean&nbsp;pAdjustPhase)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trace the sequence of nonterminal parameter replacement
 and return the HIR that corresponds to the parameter
 pParamInstance directly or indirectly.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#traceParamCorrespSimply(coins.opt.GlobalReform.MatchingData, coins.sym.Var)">traceParamCorrespSimply</A></B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                        <A HREF="../../coins/sym/Var.html" title="interface in coins.sym">Var</A>&nbsp;pParamInstance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#traceReplacementSeq(coins.opt.GlobalReform.MatchingData, coins.sym.Sym, java.util.Set, java.util.Set, boolean)">traceReplacementSeq</A></B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                    <A HREF="../../coins/sym/Sym.html" title="interface in coins.sym">Sym</A>&nbsp;pParam,
                    java.util.Set&nbsp;pTracedParam,
                    java.util.Set&nbsp;pTraversedMatchingData,
                    boolean&nbsp;pNontermParamOnly)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;traceReplacementSeq gets replica HIR that is used to replace
 pParam which may be either a nonterminal parameter or
 a pattern parameter.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#transformByPatternSym(coins.opt.GlobalReform.MatchingData, coins.sym.Subp, coins.ir.hir.HIR)">transformByPatternSym</A></B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                      <A HREF="../../coins/sym/Subp.html" title="interface in coins.sym">Subp</A>&nbsp;pPatternSym,
                      <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pInHir)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transformByPatternSym transforms pInHir according to the
 pair of in-pattern and out-pattern defined by
 pPatternSym.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#transformStmtSeq(coins.opt.GlobalReform.MatchingData, coins.sym.Subp, coins.ir.hir.Stmt)">transformStmtSeq</A></B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                 <A HREF="../../coins/sym/Subp.html" title="interface in coins.sym">Subp</A>&nbsp;pPatternSym,
                 <A HREF="../../coins/ir/hir/Stmt.html" title="interface in coins.ir.hir">Stmt</A>&nbsp;pInStmt)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transform the statement sequence beginning with pInStmt
 that matched with the statement pattern pPatternsym
 by applying adjustOutPattern to the corresponding
 out-pattern and then applying replaceParameters to the
 adjusted result.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../coins/opt/GlobalReform.html#tryToReform(coins.opt.GlobalReform.MatchingData, coins.ir.hir.HIR)">tryToReform</A></B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
            <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pHir)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Try to transform given HIR subtree pHir.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="hirRoot"><!-- --></A><H3>
hirRoot</H3>
<PRE>
protected <A HREF="../../coins/HirRoot.html" title="class in coins">HirRoot</A> <B>hirRoot</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="symRoot"><!-- --></A><H3>
symRoot</H3>
<PRE>
protected <A HREF="../../coins/SymRoot.html" title="class in coins">SymRoot</A> <B>symRoot</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="ioRoot"><!-- --></A><H3>
ioRoot</H3>
<PRE>
protected <A HREF="../../coins/IoRoot.html" title="class in coins">IoRoot</A> <B>ioRoot</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fOptionMap"><!-- --></A><H3>
fOptionMap</H3>
<PRE>
protected java.util.Map <B>fOptionMap</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fCoinsOptions"><!-- --></A><H3>
fCoinsOptions</H3>
<PRE>
protected <A HREF="../../coins/driver/CoinsOptions.html" title="class in coins.driver">CoinsOptions</A> <B>fCoinsOptions</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fPatternList"><!-- --></A><H3>
fPatternList</H3>
<PRE>
protected java.util.List <B>fPatternList</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fInPatternMap"><!-- --></A><H3>
fInPatternMap</H3>
<PRE>
protected java.util.Map <B>fInPatternMap</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fOutPatternMap"><!-- --></A><H3>
fOutPatternMap</H3>
<PRE>
protected java.util.Map <B>fOutPatternMap</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fNonterminalList"><!-- --></A><H3>
fNonterminalList</H3>
<PRE>
protected java.util.List <B>fNonterminalList</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fNonterminalSet"><!-- --></A><H3>
fNonterminalSet</H3>
<PRE>
protected java.util.Set <B>fNonterminalSet</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fProductionMap"><!-- --></A><H3>
fProductionMap</H3>
<PRE>
protected java.util.Map <B>fProductionMap</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fFittingSet"><!-- --></A><H3>
fFittingSet</H3>
<PRE>
protected java.util.Set <B>fFittingSet</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fTransparentMap"><!-- --></A><H3>
fTransparentMap</H3>
<PRE>
protected java.util.Map <B>fTransparentMap</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fPatternCount"><!-- --></A><H3>
fPatternCount</H3>
<PRE>
protected int <B>fPatternCount</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fNontermPatCount"><!-- --></A><H3>
fNontermPatCount</H3>
<PRE>
protected int <B>fNontermPatCount</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fSubrootCount"><!-- --></A><H3>
fSubrootCount</H3>
<PRE>
protected int <B>fSubrootCount</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fProductionCount"><!-- --></A><H3>
fProductionCount</H3>
<PRE>
protected int <B>fProductionCount</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fNontermPat"><!-- --></A><H3>
fNontermPat</H3>
<PRE>
protected <A HREF="../../coins/sym/Subp.html" title="interface in coins.sym">Subp</A>[] <B>fNontermPat</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fLocalVarListMap"><!-- --></A><H3>
fLocalVarListMap</H3>
<PRE>
protected java.util.Map <B>fLocalVarListMap</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fSubpToReform"><!-- --></A><H3>
fSubpToReform</H3>
<PRE>
protected java.util.List <B>fSubpToReform</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fStmtParamSet"><!-- --></A><H3>
fStmtParamSet</H3>
<PRE>
protected java.util.Set <B>fStmtParamSet</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fNoFurtherChange"><!-- --></A><H3>
fNoFurtherChange</H3>
<PRE>
protected java.util.Set <B>fNoFurtherChange</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fCompileTimeEval"><!-- --></A><H3>
fCompileTimeEval</H3>
<PRE>
protected java.util.Set <B>fCompileTimeEval</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fFitToAnyCall"><!-- --></A><H3>
fFitToAnyCall</H3>
<PRE>
protected java.util.Set <B>fFitToAnyCall</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fCurrentPatternSym"><!-- --></A><H3>
fCurrentPatternSym</H3>
<PRE>
protected <A HREF="../../coins/sym/Subp.html" title="interface in coins.sym">Subp</A> <B>fCurrentPatternSym</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fUsedAsPatternRoot"><!-- --></A><H3>
fUsedAsPatternRoot</H3>
<PRE>
protected boolean[] <B>fUsedAsPatternRoot</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fUsedAsSubRoot"><!-- --></A><H3>
fUsedAsSubRoot</H3>
<PRE>
protected boolean[] <B>fUsedAsSubRoot</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fCodeIndexFrom"><!-- --></A><H3>
fCodeIndexFrom</H3>
<PRE>
protected int[] <B>fCodeIndexFrom</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fCodeIndexTo"><!-- --></A><H3>
fCodeIndexTo</H3>
<PRE>
protected int[] <B>fCodeIndexTo</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fStmt1CodeIndexFrom"><!-- --></A><H3>
fStmt1CodeIndexFrom</H3>
<PRE>
protected int[] <B>fStmt1CodeIndexFrom</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fStmt1CodeIndexTo"><!-- --></A><H3>
fStmt1CodeIndexTo</H3>
<PRE>
protected int[] <B>fStmt1CodeIndexTo</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fStmt2CodeIndexFrom"><!-- --></A><H3>
fStmt2CodeIndexFrom</H3>
<PRE>
protected int[] <B>fStmt2CodeIndexFrom</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fStmt2CodeIndexTo"><!-- --></A><H3>
fStmt2CodeIndexTo</H3>
<PRE>
protected int[] <B>fStmt2CodeIndexTo</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fPatternCodeUpper"><!-- --></A><H3>
fPatternCodeUpper</H3>
<PRE>
protected double[] <B>fPatternCodeUpper</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fPatternCodeLower"><!-- --></A><H3>
fPatternCodeLower</H3>
<PRE>
protected double[] <B>fPatternCodeLower</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fStmtsInPattern"><!-- --></A><H3>
fStmtsInPattern</H3>
<PRE>
protected int[] <B>fStmtsInPattern</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fPatternParameters"><!-- --></A><H3>
fPatternParameters</H3>
<PRE>
protected java.util.Set <B>fPatternParameters</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fNonterminalParameters"><!-- --></A><H3>
fNonterminalParameters</H3>
<PRE>
protected java.util.Set <B>fNonterminalParameters</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fProductionsInNonterminal"><!-- --></A><H3>
fProductionsInNonterminal</H3>
<PRE>
protected int[] <B>fProductionsInNonterminal</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fMaxStmtsInPattern"><!-- --></A><H3>
fMaxStmtsInPattern</H3>
<PRE>
protected int <B>fMaxStmtsInPattern</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fNextStmtCode"><!-- --></A><H3>
fNextStmtCode</H3>
<PRE>
protected double <B>fNextStmtCode</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fCurrentStmt"><!-- --></A><H3>
fCurrentStmt</H3>
<PRE>
protected <A HREF="../../coins/ir/hir/Stmt.html" title="interface in coins.ir.hir">Stmt</A> <B>fCurrentStmt</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fNextStmt"><!-- --></A><H3>
fNextStmt</H3>
<PRE>
protected <A HREF="../../coins/ir/hir/Stmt.html" title="interface in coins.ir.hir">Stmt</A> <B>fNextStmt</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fTailStmtMatched"><!-- --></A><H3>
fTailStmtMatched</H3>
<PRE>
protected <A HREF="../../coins/ir/hir/Stmt.html" title="interface in coins.ir.hir">Stmt</A> <B>fTailStmtMatched</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fMatchingDataForNontermInstance"><!-- --></A><H3>
fMatchingDataForNontermInstance</H3>
<PRE>
protected java.util.Map <B>fMatchingDataForNontermInstance</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fMatchingDataForNonterm"><!-- --></A><H3>
fMatchingDataForNonterm</H3>
<PRE>
protected java.util.Map <B>fMatchingDataForNonterm</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fLastMatchingDataForNonterm"><!-- --></A><H3>
fLastMatchingDataForNonterm</H3>
<PRE>
protected <A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>[] <B>fLastMatchingDataForNonterm</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fGlobalPatternParamMap"><!-- --></A><H3>
fGlobalPatternParamMap</H3>
<PRE>
protected java.util.Map <B>fGlobalPatternParamMap</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fExpandedNontermInstance"><!-- --></A><H3>
fExpandedNontermInstance</H3>
<PRE>
protected java.util.Map <B>fExpandedNontermInstance</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fExpandedNonterm"><!-- --></A><H3>
fExpandedNonterm</H3>
<PRE>
protected java.util.Map <B>fExpandedNonterm</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fNontermPatInstanceOfCurrentPattern"><!-- --></A><H3>
fNontermPatInstanceOfCurrentPattern</H3>
<PRE>
protected <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A> <B>fNontermPatInstanceOfCurrentPattern</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fHirKeys"><!-- --></A><H3>
fHirKeys</H3>
<PRE>
protected java.util.Set <B>fHirKeys</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fFormalParams"><!-- --></A><H3>
fFormalParams</H3>
<PRE>
protected java.util.Set[] <B>fFormalParams</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fInstanceNumberForNonterminals"><!-- --></A><H3>
fInstanceNumberForNonterminals</H3>
<PRE>
protected int[] <B>fInstanceNumberForNonterminals</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fOriginalVarMap"><!-- --></A><H3>
fOriginalVarMap</H3>
<PRE>
protected java.util.Map <B>fOriginalVarMap</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fNontermInstanceInPattern"><!-- --></A><H3>
fNontermInstanceInPattern</H3>
<PRE>
protected java.util.Map <B>fNontermInstanceInPattern</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fHirCodeLim"><!-- --></A><H3>
fHirCodeLim</H3>
<PRE>
static double <B>fHirCodeLim</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fDontCareCode"><!-- --></A><H3>
fDontCareCode</H3>
<PRE>
static double <B>fDontCareCode</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fHirCodeLim2"><!-- --></A><H3>
fHirCodeLim2</H3>
<PRE>
static double <B>fHirCodeLim2</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fHirCodeLim3"><!-- --></A><H3>
fHirCodeLim3</H3>
<PRE>
static double <B>fHirCodeLim3</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fHirCodeLim4"><!-- --></A><H3>
fHirCodeLim4</H3>
<PRE>
static double <B>fHirCodeLim4</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fHirCodeLim5"><!-- --></A><H3>
fHirCodeLim5</H3>
<PRE>
static double <B>fHirCodeLim5</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fHirCodeLim6"><!-- --></A><H3>
fHirCodeLim6</H3>
<PRE>
static double <B>fHirCodeLim6</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fChanged"><!-- --></A><H3>
fChanged</H3>
<PRE>
protected boolean <B>fChanged</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fDbgLevel"><!-- --></A><H3>
fDbgLevel</H3>
<PRE>
protected int <B>fDbgLevel</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="hir"><!-- --></A><H3>
hir</H3>
<PRE>
protected <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A> <B>hir</B></PRE>
<DL>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="GlobalReform(coins.HirRoot)"><!-- --></A><H3>
GlobalReform</H3>
<PRE>
public <B>GlobalReform</B>(<A HREF="../../coins/HirRoot.html" title="class in coins">HirRoot</A>&nbsp;pHirRoot)</PRE>
<DL>
<DD>Constructor GlobalTransform.
 Process pragmas
   #pragma globalReform patternSym pattern1 pattern2 ...
   #pragma globalReform target subp1 subp2 ...
 Make pattern map fPatternMap showing the correspondence
 of in-pattern and out-pattern checking the consistency
 of parameter usage in the pattern.
<P>
<DT><B>Parameters:</B><DD><CODE>pHirRoot</CODE> - HirRoot conveyed.</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="doReform(java.util.List)"><!-- --></A><H3>
doReform</H3>
<PRE>
public boolean <B>doReform</B>(java.util.List&nbsp;pReformPatternList)</PRE>
<DL>
<DD>doReform transforms subprograms listed up in
   #pragma globalReform target subp1 subp2 ...
 replacing HIR subtrees matched with some in-pattern
 treating parameters in in-pattern and out-pattern properly.
 HIR body of patterns are set to empty block at exit
 so as to suppress further optimization and code generation
 for them.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pReformPatternList</CODE> - is empty at entry and contains
     all patterns specified by #pragma globalReform at exit.
<DT><B>Returns:</B><DD>true if HIR is changed by the transformation,
     false otherwise.</DL>
</DD>
</DL>
<HR>

<A NAME="tryToReform(coins.opt.GlobalReform.MatchingData, coins.ir.hir.HIR)"><!-- --></A><H3>
tryToReform</H3>
<PRE>
protected <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A> <B>tryToReform</B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                          <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pHir)</PRE>
<DL>
<DD>Try to transform given HIR subtree pHir.
 If it matches with some in-pattern, then it is transformed
 to the form indicated by the out-pattern corresponding to
 the in-pattern.
 The matching process is done in 3 steps to speedup
 the matching.
 Case 1 - Pattern is one expression or one statement.
   step 1: operator of pHir is the same to the operator
           of root node of some in-pattern.
   step 2: pattern code of pHir is in the range of upper/lower
           pattern code of some in-pattern.
   step 3: Every nodes in pHir are the same to those
           of some in-pattern in the corresponding position
           except for parameters.
 Case 2 - Pattern is a sequence of statements
   step 1: operator of the first statement in pHir is the same to
           the operator of root node (or 1st statement)
           of some in-pattern.
   step 2: pattern codes of 1st statement and 2nd statement
           starting from pHir are in the range of upper/lower pattern
           codes of 1st statement and 2nd statement of some
           in-pattern, respectively.
   step 3: Every nodes in statement sequence starting from pHir
           are the same to those of some in-pattern in the
           corresponding position except for parameters.
 If the matched in-pattern is a sequence of stetements,
 fTailStmtMatched hold the statement of input statement
 sequence corresponding to the last statement of the matched
 in-pattern to show that the next pattern match is to be
 started from fTailStmtMatched.getNextStmt().
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pHir</CODE> - HIR subtree to be transformed or statement
           from which matching is to be started.
<DT><B>Returns:</B><DD>transformed HIR subtree (that may be a block statement
     when the transformed result is a sequence of statements).</DL>
</DD>
</DL>
<HR>

<A NAME="isMatchedPattern(coins.opt.GlobalReform.MatchingData, coins.ir.hir.HIR, coins.ir.hir.HIR, coins.opt.GlobalReform.NontermPatInstance)"><!-- --></A><H3>
isMatchedPattern</H3>
<PRE>
protected boolean <B>isMatchedPattern</B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                                   <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pSubPattern,
                                   <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pHir,
                                   <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A>&nbsp;pAncestorNontermPatInstance)</PRE>
<DL>
<DD>isMatchedPattern discriminates whether HIR subtree pHir
 matches with the pattern pSubPattern (in-pattern or a
 part of in-pattern) comparing pHir with pSubPattern.
 In the process of comparison, a parameter in pSubPattern
 is treated to match with any HIR expression of the same
 type or matches with any statement if the parameter is
 a statement parameter listed up in
   #pragma globalReform stmtParam
 The correspondence of parameter and HIR subtree located
 in the corresponding position is recorded in
 pData.paramCorresp or pData.nontermParamCorresp.
 The input expression/statement corresponding to the
 pattern is recorded in pData.expandedHir
 which may contain pattern parameter so that further
 replacement of the parameter is possible.
 In C language, array element expression has several
 variations such as subs-expression or pointer-expression.
 It makes the process of comparison and the process of
 replacement of parameters complicated. This problem
 is handled by
   isMatchedSubs (for subscripted variable expression), and
   isMatchedArray (for array expression).
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pData</CODE> - matching data.<DD><CODE>pSubPattern</CODE> - in-pattern or part of in-pattern.<DD><CODE>pHir</CODE> - input expression/statement to be compared
   with pSubPattern.<DD><CODE>pAncestorNontermPatInstance</CODE> - ancestor instance
   of nonterminal or pattern.
<DT><B>Returns:</B><DD>true if pHir matched with pSubPattern
   false if no.</DL>
</DD>
</DL>
<HR>

<A NAME="postProcess(boolean, java.util.Map, coins.opt.GlobalReform.MatchingData)"><!-- --></A><H3>
postProcess</H3>
<PRE>
boolean <B>postProcess</B>(boolean&nbsp;pMatched,
                    java.util.Map&nbsp;pGlobalPatternParamMap,
                    <A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData)</PRE>
<DL>
<DD>If matching failed, then restore fGlobalPatternParamMap
 by their previous value pGlobalPatternParamMap.
 If matching succeeded, then leave fGlobalPatternParamMap
 unchanged (in the updated status).
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pMatched</CODE> - true if the matching succeeded, otherwise false.<DD><CODE>pGlobalPatternParamMap</CODE> - Previous pattern param mapping.
<DT><B>Returns:</B><DD>pMatched.</DL>
</DD>
</DL>
<HR>

<A NAME="isMatchedSubs(coins.opt.GlobalReform.MatchingData, coins.ir.hir.HIR, coins.ir.hir.HIR, coins.opt.GlobalReform.NontermPatInstance)"><!-- --></A><H3>
isMatchedSubs</H3>
<PRE>
protected boolean <B>isMatchedSubs</B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                                <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pSubPattern,
                                <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pHir,
                                <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A>&nbsp;pAncestorNontermPatInstance)</PRE>
<DL>
<DD>isMatchedSubs discriminates whether HIR subtree pHir
 matches with the pattern pSubPattern (in-pattern or
 part of in-pattern) comparing pHir with pSubPattern
 where pHir or pSubPattern may be an expression
 representing an array element.
 In HIR corresponding to C language, array element may
 be represented as one of
   (subs <var arrayVar> subscriptExp)
   (subs (undecay pointerExp elemCount) subscriptExp)
   (contents (add pointerExp (mult elemSize subscriptExp)))
 and each combination of them should be considered
 in the comparison. isMatchedSubs does such comparison
 and record the correspondence of parameter in pSubPattern
 and the expression in pHir.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pData</CODE> - matching data.<DD><CODE>pSubPattern</CODE> - in-pattern or its subexpression.<DD><CODE>pHir</CODE> - part of input program to be matched.<DD><CODE>pAncestorNontermPatInstance</CODE> - ancestor instance
   of nonterminal or pattern.
<DT><B>Returns:</B><DD>true if pHir matched with pSubPattern.</DL>
</DD>
</DL>
<HR>

<A NAME="isMatchedArray(coins.opt.GlobalReform.MatchingData, coins.ir.hir.HIR, coins.ir.hir.HIR, coins.opt.GlobalReform.NontermPatInstance)"><!-- --></A><H3>
isMatchedArray</H3>
<PRE>
protected boolean <B>isMatchedArray</B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                                 <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pSubPattern,
                                 <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pHir,
                                 <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A>&nbsp;pAncestorNontermPatInstance)</PRE>
<DL>
<DD>isMatchedArray discriminates whether HIR subtree pHir
 matches with the pattern pSubPattern (in-pattern or
 part of in-pattern) comparing pHir with pSubPattern
 where pHir or pSubPattern may be an expression
 representing an array (vector) or array element.
 In HIR corresponding to C language, array and
 array element may be represented as one of
   (subs <var varOfArrayType> subscriptExp)
   (contents (add <varOfPointerType> (mult elemSize subscriptExp)))
   (undecay pointerExp elemCount)
   <var varOfArrayType>
   <var varOfPointerType>
   (decay arrayExp)
   (addr variableExp)
   (subs <var arrayVar> subscriptExp)
   (subs (undecay pointerExp elemCount) subscriptExp)
   (contents (add pointerExp (mult elemSize subscriptExp)))
 and each combination of them should be considered
 in the comparison.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pData</CODE> - matching data.<DD><CODE>pSubPattern</CODE> - in-pattern or its subexpression.<DD><CODE>pHir</CODE> - part of input program to be matched.<DD><CODE>pAncestorNontermPatInstance</CODE> - ancestor instance
   of nonterminal or pattern.
<DT><B>Returns:</B><DD>true if pHir matched with pSubPattern.</DL>
</DD>
</DL>
<HR>

<A NAME="isMatchedStmtSeq(coins.opt.GlobalReform.MatchingData, coins.ir.hir.HIR, coins.ir.hir.Stmt, int, coins.opt.GlobalReform.NontermPatInstance)"><!-- --></A><H3>
isMatchedStmtSeq</H3>
<PRE>
protected boolean <B>isMatchedStmtSeq</B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                                   <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pSubPattern,
                                   <A HREF="../../coins/ir/hir/Stmt.html" title="interface in coins.ir.hir">Stmt</A>&nbsp;pStmt,
                                   int&nbsp;pPatternIndex,
                                   <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A>&nbsp;pAncestorNontermPatInstance)</PRE>
<DL>
<DD>isMatchedStmtSeq discriminates whether HIR subtree
 matches with the pattern pSubPattern (in-pattern or
 part of in-pattern) that is a sequence of statements
 comparing the statement sequence starting with pStmt.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pData</CODE> - Maching data.<DD><CODE>pSubPattern</CODE> - Pattern taking the form of a sequence
   of statements.<DD><CODE>pStmt</CODE> - Statement from which comparison should
   take place.<DD><CODE>pPatternIndex</CODE> - Index assigned to the pattern
   (used to the number of statements in the pattern).<DD><CODE>pAncestorNontermPatInstance</CODE> - ancestor instance
   of nonterminal or pattern.
<DT><B>Returns:</B><DD>true if matched, false otherwise.</DL>
</DD>
</DL>
<HR>

<A NAME="isMatchedCondition(coins.opt.GlobalReform.MatchingData, coins.ir.hir.HIR, coins.ir.hir.HIR, coins.opt.GlobalReform.NontermPatInstance)"><!-- --></A><H3>
isMatchedCondition</H3>
<PRE>
protected boolean <B>isMatchedCondition</B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                                     <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pSubPattern,
                                     <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pHir,
                                     <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A>&nbsp;pAncestorNontermPatInstance)</PRE>
<DL>
<DD>isMatchedCondition: Check comparison expression having different
 operation code, where either pSubPattern or pHir have
 comparison operator.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pData</CODE> - matching data.<DD><CODE>pSubPattern</CODE> - in-pattern or part of in-pattern.<DD><CODE>pHir</CODE> - input expression/statement to be compared
   with pSubPattern.<DD><CODE>pAncestorNontermPatInstance</CODE> - ancestor instance
   of nonterminal or pattern.
<DT><B>Returns:</B><DD>true if pHir matched with pSubPattern
   false if no.</DL>
</DD>
</DL>
<HR>

<A NAME="isMatchedNonterminal(coins.opt.GlobalReform.MatchingData, coins.opt.GlobalReform.NontermPatInstance, coins.ir.hir.HIR, coins.ir.hir.HIR, coins.opt.GlobalReform.NontermPatInstance)"><!-- --></A><H3>
isMatchedNonterminal</H3>
<PRE>
protected boolean <B>isMatchedNonterminal</B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                                       <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A>&nbsp;pNontermInstance,
                                       <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pNontermCall,
                                       <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pHir,
                                       <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A>&nbsp;pAncestorNontermPatInstance)</PRE>
<DL>
<DD>isMatchedNonterminal discriminates whether the nonterminal
 (pMetaSym) refered by pNonterminalCall matches with
 the input HIR tree pHir.
 A new instance of the nonterminal is made and all of its
 parameters are also instanciated so that the same nonterminal
 refered in the same form of call expression may match with
 different HIR if its instance differs.
 Similarly, the same parameter may have different actual
 parameter (matched input) if they have multiple instances.
 The input expression/statement corresponding to the
 pattern is recorded in pData.expandedHir
 which may contain pattern parameter so that further
 replacement of the parameter is possible.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pData</CODE> - MatchingData to be refered and updated
            in the matching.<DD><CODE>pNontermInstance</CODE> - Nonterminal instanciated for this
        call (pNontermCall) which may be defined nonterminal
        or meta symbol (_bnfOr, _bnfSeq, _reform).<DD><CODE>pNontermCall</CODE> - Expression calling pMetaSym.<DD><CODE>pHir</CODE> - Input HIR to be matched with the nonterminal.<DD><CODE>pAncestorNontermPatInstance</CODE> - Nonterminal instance
        in which body the current nonterminal is instanciated
        (by pNontermCall).
<DT><B>Returns:</B><DD>true if matched nonterminal.</DL>
</DD>
</DL>
<HR>

<A NAME="isMatchedAssignStmt(coins.opt.GlobalReform.MatchingData, coins.opt.GlobalReform.NontermPatInstance, coins.ir.hir.HIR, coins.ir.hir.HIR, coins.opt.GlobalReform.NontermPatInstance)"><!-- --></A><H3>
isMatchedAssignStmt</H3>
<PRE>
protected boolean <B>isMatchedAssignStmt</B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                                      <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A>&nbsp;pNontermInstance,
                                      <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pNontermCall,
                                      <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pHir,
                                      <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A>&nbsp;pAncestorNontermPatInstance)</PRE>
<DL>
<DD>Examine whether the assign statement pHir matches with
 the pattern specified by _assignStmt.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pData</CODE> - Matching data to be used.<DD><CODE>pNontermInstance</CODE> - Instance of the nonterminal
        (_assignStmt) representing the pattern.<DD><CODE>pNontermCall</CODE> - HIR expression calling _assignStmt.<DD><CODE>pHir</CODE> - HIR to be matched with the pattern.<DD><CODE>pAncestorNontermPatInstance</CODE> - Ancestor pattern or
        ancestor nonterminal.
<DT><B>Returns:</B><DD>true if matched, false otherwise.</DL>
</DD>
</DL>
<HR>

<A NAME="transformByPatternSym(coins.opt.GlobalReform.MatchingData, coins.sym.Subp, coins.ir.hir.HIR)"><!-- --></A><H3>
transformByPatternSym</H3>
<PRE>
protected <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A> <B>transformByPatternSym</B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                                    <A HREF="../../coins/sym/Subp.html" title="interface in coins.sym">Subp</A>&nbsp;pPatternSym,
                                    <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pInHir)</PRE>
<DL>
<DD>transformByPatternSym transforms pInHir according to the
 pair of in-pattern and out-pattern defined by
 pPatternSym. It is called from tryToReform.
 For each parameter in in-pattern,
 corresponding expression/statement in pInHir should be
 already recorded in pData by isMatchedPattern method.
 Usually, transformByPatternSym is invoked in tryToReform
 when an expression or statement is discriminated to be
 matched with some pattern by isMatchedPattern.
 The transformed result raise the flag FLAG_NOCHANGE to
 show that further optimization is not desirable. //REFINE
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pData</CODE> - matching data.<DD><CODE>pPatternSym</CODE> - pattern symbol showing in-pattern and
     out-pattern to be used in transformation.<DD><CODE>pInHir</CODE> - a part of input program to be transformed.
<DT><B>Returns:</B><DD>HIR subtree generated as the result of the
     transformation.</DL>
</DD>
</DL>
<HR>

<A NAME="expandOutPattern(coins.opt.GlobalReform.MatchingData, coins.ir.hir.HIR, java.util.Set)"><!-- --></A><H3>
expandOutPattern</H3>
<PRE>
protected <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A> <B>expandOutPattern</B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                               <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pOutHir,
                               java.util.Set&nbsp;pTraversedNonterminals)</PRE>
<DL>
<DD>expandOutPattern expands pOutHir according to pData.
 Fitting symbols and nonterminal parameters are replaced
 by the corresponding HIR recorded in pData.
 If pOutHir contains a nonterminal call, a new instance
 of the nonterminal is created and its expansion is determinde
 by Nonterminal calls are replaced by the corresponding HIR
 determined by expandNonterminal (or getExpandedHir).
 Pattern parameters and other expressions contained in pOutHir
 are left unchanged.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pData</CODE> - Matching data to be used.<DD><CODE>pOutHir</CODE> - HIR to be expanded.<DD><CODE>pTraversedNonterminals</CODE> - Set of traverced nonterminal
        instances (used to avoid infinite loop).
<DT><B>Returns:</B><DD>the expanded result.</DL>
</DD>
</DL>
<HR>

<A NAME="expandNonterminal(coins.opt.GlobalReform.MatchingData, coins.opt.GlobalReform.NontermPatInstance, coins.ir.hir.HIR, java.util.Set)"><!-- --></A><H3>
expandNonterminal</H3>
<PRE>
protected <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A> <B>expandNonterminal</B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                                <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A>&nbsp;pNontermPatInstance,
                                <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pCallExp,
                                java.util.Set&nbsp;pTraversedNonterminals)</PRE>
<DL>
<DD>expandNonterminal expands the right hand side of the
 selected productin of the nonterminal pNontermPatInstance
 and return it.
 If the result of previous expansion is recorded
 in pData, then return it.
 If it is a recursive call, do not expand.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pData</CODE> - MatchingData to be used.<DD><CODE>pNontermPatInstance</CODE> - Instance of a nonterminal.<DD><CODE>pCallExp</CODE> - Expression that calls the nonterminal.<DD><CODE>pTraversedNonterminals</CODE> - Set of traverced nonterminal
        instances (used to avoid infinite loop).
<DT><B>Returns:</B><DD>the expanded result.</DL>
</DD>
</DL>
<HR>

<A NAME="adjustOutPattern(coins.opt.GlobalReform.MatchingData, coins.ir.hir.HIR, java.util.Set, int)"><!-- --></A><H3>
adjustOutPattern</H3>
<PRE>
protected <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A> <B>adjustOutPattern</B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                               <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pOutHir,
                               java.util.Set&nbsp;pTraversedMatchingData,
                               int&nbsp;pNthInstance)</PRE>
<DL>
<DD>Adjust the out pattern pOutHir corresponding to the pattern/nonterminal
 represented by pData, that is,
 If pOutHir is a pattern/nonterminal param node, then
   replace it by the HIR corresponding to it;
 If pOutHir represents a nonterminal, then
   replace it by the expanded HIR corresponding to it
   invoking adjustNonterminal with a
   MachingData obtained by copying pData;
 If pOutHir represents
   _reform(n_th_instance, patternParam, replacementExp,
           nonterminalCallExp),
   then expand the nonterminal and then replace the pattern
   parameter (patternParam) contained in it with
   replacementExp and then replace the pattern parameters
   according to the correspondence given in pData.
   If there are several nonterminal calls having the same
   form in a pattern definition, then the nonterminal instance
   corresponding to the i-th nonterminal call
   is selected where the sequence number i is given
   by the parameter pNthInstance.
 If pOutHir is a list, then replace each element
   by applying adjustOutPattern to the element;
 If pOutHir is a block, then replace each statement
   by applying adjustOutPattern to the statement;
 If pOutHir is other subtree, then replace each child
   by applying adjustOutPattern to the child;
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pData</CODE> - Matching data to be used.<DD><CODE>pOutHir</CODE> - Out pattern corresponding to the pattern/nonterminal
   represented by pData (it is already a copy and
   unnecessary to be copied in this method).<DD><CODE>pTraversedMatchingData</CODE> - Set of traversed matching data
   to be used to avoid the application of the same matching data.<DD><CODE>pNthInstance</CODE> - Sequence number (0, 1, 2, ...) assigned
   to a nonterminal call to distinguish it from other nonterminal
   calls having the same form in the definiton of a pattern.
<DT><B>Returns:</B><DD>the adjusted HIR.</DL>
</DD>
</DL>
<HR>

<A NAME="adjustNonterminal(coins.opt.GlobalReform.MatchingData, coins.opt.GlobalReform.NontermPatInstance, coins.ir.hir.HIR, java.util.Set, int, boolean)"><!-- --></A><H3>
adjustNonterminal</H3>
<PRE>
protected <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A> <B>adjustNonterminal</B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                                <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A>&nbsp;pNontermPatInstance,
                                <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pCallNode,
                                java.util.Set&nbsp;pTraversedMatchingData,
                                int&nbsp;pNthInstance,
                                boolean&nbsp;pRevisedMatchingData)</PRE>
<DL>
<DD>Change a nonterminal call to a plain HIR subtree
 that has resolved parameters and nonterminal calls
 by executing following steps:
 (1) Get the instance of MatchingData lData1
   corresponding to the nonterminal call pCallNode.
   Get the expanded Hir lExpandedHir corresponding to
   the nonterminal instance pNontermPatInstance.
 (2) Make the matching data complete, that is,
   trace the mapping sequence of nonterminal parameters
   and if it reaches to a pattern parameter, then
   make the nonterminal parameter corresponds to the HIR
   corresponding to the pattern parameter.
 (3) Get the expanded HIR corresponding to the nonterminal
   instance pNontermPatInstance.
 (4) Replace parameters in the expanded HIR.
 (5) Return the resultant expanded HIR.
 This is called from adjustOutPattern.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pData</CODE> - MatchingData instance to be used.<DD><CODE>pNontermPatInstance</CODE> - Nonterminal instance.<DD><CODE>pCallNode</CODE> - Nonterminal call node that instanciated
     pNontermPatInstance.<DD><CODE>pTraversedMatchingData</CODE> - <DD><CODE>pNthInstance</CODE> - Sequence number (0, 1, 2, ...) assigned
   to a nonterminal call to distinguish it from other nonterminal
   calls having the same form in the definiton of a pattern.<DD><CODE>pRevisedMatchingData</CODE> - true if pData is a revised one and
   unnecessary to use getMatchingData method.
<DT><B>Returns:</B><DD>Resultant HIR subtree adjusted.</DL>
</DD>
</DL>
<HR>

<A NAME="evaluateReform(coins.opt.GlobalReform.MatchingData, coins.ir.hir.HIR, java.util.Set)"><!-- --></A><H3>
evaluateReform</H3>
<PRE>
protected <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A> <B>evaluateReform</B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                             <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pOutHir,
                             java.util.Set&nbsp;pTraversedMatchingData)</PRE>
<DL>
<DD>Evaluate the special function _reform
 by calling reformByChangingParam( ... )
 after examining given arguments.
 The parameter pOutHir is an expanded HIR that may contain
 pattern parameters and _assignStmt function.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pData</CODE> - Matching data to be used.<DD><CODE>pOutHir</CODE> - expanded HIR to be transformed.<DD><CODE>pTraversedMatchingData</CODE> - Set of traversed matching data.
<DT><B>Returns:</B><DD>the transformed HIR.</DL>
</DD>
</DL>
<HR>

<A NAME="adjustMatchingData(coins.opt.GlobalReform.MatchingData, java.util.Map)"><!-- --></A><H3>
adjustMatchingData</H3>
<PRE>
protected java.util.Map <B>adjustMatchingData</B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                                           java.util.Map&nbsp;pParamCorresp)</PRE>
<DL>
<DD>Get the HIR corresponding to pattern parameters
 that are given as keys of pParamCorresp which
 maps pattern parameters to primary HIR that may contain
 parameters. The resultant HIR does not nontain
 parameters any more.
 In this processing, the correspondence of parameter
 replacement sequence is traced and if the HIR
 given by pData (as the one corresponding to a parameter)
 contains a parameter node, then the parameter node is
 replaced with corresponding HIR.
 (This method is called in adjustNonterminal.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pData</CODE> - The instance of MatchingData to be used
   in tracing the correspondence of parameters.<DD><CODE>pParamCorresp</CODE> - Input correspondence of pattern
   parameters and replacement expressions.
<DT><B>Returns:</B><DD>Resultant correspondence of pattern parameters and
   replacement expressions.</DL>
</DD>
</DL>
<HR>

<A NAME="traceReplacementSeq(coins.opt.GlobalReform.MatchingData, coins.sym.Sym, java.util.Set, java.util.Set, boolean)"><!-- --></A><H3>
traceReplacementSeq</H3>
<PRE>
protected <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A> <B>traceReplacementSeq</B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                                  <A HREF="../../coins/sym/Sym.html" title="interface in coins.sym">Sym</A>&nbsp;pParam,
                                  java.util.Set&nbsp;pTracedParam,
                                  java.util.Set&nbsp;pTraversedMatchingData,
                                  boolean&nbsp;pNontermParamOnly)</PRE>
<DL>
<DD>traceReplacementSeq gets replica HIR that is used to replace
 pParam which may be either a nonterminal parameter or
 a pattern parameter.
 If the HIR to be used to replace the parameter contains
 othter pattern/nonterminal parameters, then the contained
 parameters are replaced. This process continues successively
 until there remains no pattern/nonterminal parameters except
 the case where some parameter is contained in the replica
 HIR recursively.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pData</CODE> - Matching data used in the replacement.<DD><CODE>pParam</CODE> - a pattern parameter or a nonterminal parameter.<DD><CODE>pTracedParam</CODE> - Set of traced parameters.<DD><CODE>pTraversedMatchingData</CODE> - Set of traversed matching data.<DD><CODE>pNontermParamOnly</CODE> - true if replacement is to be done for
     nonterminal parameters and leave pattern parameters unchanged,
     false if both of pattern parameters and nonterminal parameters
     are to be replaced.
<DT><B>Returns:</B><DD>the replica to be used to replace pParam.</DL>
</DD>
</DL>
<HR>

<A NAME="traceParamCorresp(coins.opt.GlobalReform.MatchingData, coins.sym.Var, coins.ir.hir.HIR, boolean)"><!-- --></A><H3>
traceParamCorresp</H3>
<PRE>
protected <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A> <B>traceParamCorresp</B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                                <A HREF="../../coins/sym/Var.html" title="interface in coins.sym">Var</A>&nbsp;pParamInstance,
                                <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pMatchedHir,
                                boolean&nbsp;pAdjustPhase)</PRE>
<DL>
<DD>Trace the sequence of nonterminal parameter replacement
 and return the HIR that corresponds to the parameter
 pParamInstance directly or indirectly.
 The result will not contain nonterminal parameters but may
 contain pattern parameter or the result does not contain
 pattern/nonterminal parameters.
 pData.succeeded is set true if no discrepancy was found,
 false otherwise.
 At first, the sequence of nonterminal parameter replacement
 is traced. It stops to trace when a pattern parameter is
 reached or an HIR that is not a parameter node is reached.
 The 2nd phase differs according to the value of pAdjustPhase.
 If pAdjustPhase is false (called in matching phase), then
   if pParamInstance is a pattern parameter and the HIR
   corresponding to pParamInstance takes the same form
   as pMatchedHir, then the result is a parameter node
   representing pParamInstance and pData.succeeded is
   set true.
   If the HIR corresponding to pParamInstance has different
   form compared to pMatchedHir, then the result is a
   parameter node representing pParamInstance and
   pData.succeeded is false.
 If pAdjustPhase is true (called in adjustOutPattern
   directly or indirectly), then the result is the parameter
   node representing pParamInstance if pParamInstance is
   a pattern parameter or the result is the copy of pMatchedHir
   if not. In any case pData.succeeded is set true if
   pAdjustPhase is true..
 The resultant HIR is adjusted according to the type of
 pParamInstance by applying decay/undecay/conv operation
 if necessary.
 If discrepancy was found in the above processing, then
 the the result may be wrong.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pData</CODE> - Matching data to be used in tracing the replacement
     sequence.<DD><CODE>pParamInstance</CODE> - Instance of nonterminal parameter or pattern parameter.<DD><CODE>pMatchedHir</CODE> - Input HIR that matched to pParam.<DD><CODE>pAdjustPhase</CODE> - true if called in adjustOutPattern/adjustNonterminal,
     false otherwize.
<DT><B>Returns:</B><DD>(copy of) the HIR corresponding to pParamInstance
     or a parameter node representing pParamInstance.</DL>
</DD>
</DL>
<HR>

<A NAME="traceParamCorrespSimply(coins.opt.GlobalReform.MatchingData, coins.sym.Var)"><!-- --></A><H3>
traceParamCorrespSimply</H3>
<PRE>
protected <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A> <B>traceParamCorrespSimply</B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                                      <A HREF="../../coins/sym/Var.html" title="interface in coins.sym">Var</A>&nbsp;pParamInstance)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="makeParamCorrespComplete(coins.opt.GlobalReform.MatchingData)"><!-- --></A><H3>
makeParamCorrespComplete</H3>
<PRE>
protected void <B>makeParamCorrespComplete</B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData)</PRE>
<DL>
<DD>If a nonterminal param is mapped to a pattern param
 directly or indirectly (by tracing the sequence of
 nontermParam-to-nontermParam correspondence),
 then record the HIR corresponding to the nonterm parameter
 as the HIR corresponding to the pattern parameter.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pData</CODE> - Matching data in which nontermParam-to-nontermParam
     correspondence is to be traced.</DL>
</DD>
</DL>
<HR>

<A NAME="replaceParameters(coins.opt.GlobalReform.MatchingData, coins.ir.hir.HIR, java.util.Set, boolean)"><!-- --></A><H3>
replaceParameters</H3>
<PRE>
protected <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A> <B>replaceParameters</B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                                <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pOutHir,
                                java.util.Set&nbsp;pTraversedMatchingData,
                                boolean&nbsp;pNontermParamOnly)</PRE>
<DL>
<DD>Replace nonterminal/pattern parameters and fitting symbols
 contained in pOutHi by the HIR correnponding to the parameters
 or fitting symbols where the correspondence is given by pData.

  if (pOutHir instanceof SymNode) {
    if (it is a parameter or fitting symbol) {
      if (pNontermParamOnly&&(it is a pattern parameter)) {
        return pOutHir; // Do not replace pattern parameter.
      }
      It is a parameter or fitting symbol.
      Get the HIR subtree that corrresponds to the parameter
        in the form all parameters contained in it are already replaced
        by using traceReplacementSeq.
      if (its type is not VectorType) {
        Replace the node by the HIR subtree obtained by traceReplacementSeq.
      }else {
        It is an array parameter (parameter node of VectorType).
        Construct the resultant HIR subtree by replacing
          the parameter node or its parent expression
          considering that the array parameters
          may appear in such form as
            (subs <var varOfArrayType> subscriptExp)
            (subs (undecay varOfPointerType elemCount) subscriptExp)
            (contents (add <varOfPointerType> (mult elemSize subscriptExp)))
            <var varOfArrayType>
            <var varOfPointerType>
            (decay arrayExp)
            (addr variableExp)
            (conv <var varOfArrayAType>)
           (list <var varOfArrayType> ... )
           (list <var varOfPointerType> ... )
    }else {
      Other symbol node.
      if (the symbol is a variable  that is not defined in the
          subprogram under transformation) {
          (! lCorrespKeySet.contains(lSym))) {
        Generate a temporal variable and replace the variable node
          and register the correspondence in pParamCorresp.
      }else if (correspondence is given in pData) {
        Make the resultant expression by getting the expression
          corresponding to the symbol using pData.
      }
    }
  } // end of SymNode
  else if (pOutHir instanceof HirList) {
    Make a list by replacing all of its elements.
  }else if (pOutHir instanceof BlockStmt) {
     Make a block by replacing all statements contained in it.
  }else if (pOutHir instanceof LabeledStmt) {
    Make a labeled statement generating new label and replacing is body statement.
  }else {
    For other HIR having children, make the resultant HIR
      by replacing its children.
  }
  if (succeeded to get the resultant HIR lReplica) {
    return lReplica;
  }else {
      return pOutHir;
  }
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pData</CODE> - Matching data giving the correspondence of
     parameters and HIR subtrees.<DD><CODE>pOutHir</CODE> - HIR subtree whose parameter nodes are
     to be replaced (copy should be given if original HIR
     subtree should not be changed).<DD><CODE>pTraversedMatchingData</CODE> - Set of matching data already
     traversed (used to escape from infinite loop).<DD><CODE>pNontermParamOnly</CODE> - Set true if only nonterminal
     parameter nodes are to be replaced and leave pattaern
     parameter nodes are to be left unchanged, set false if
     both of nonterminal/pattern parameter nodes are to be
     replaced.
<DT><B>Returns:</B><DD>the result of replacement (return pOutHir if no
     replacement is taken).</DL>
</DD>
</DL>
<HR>

<A NAME="replaceStatementParameter(coins.opt.GlobalReform.MatchingData, coins.ir.hir.SymNode, java.util.Set, boolean)"><!-- --></A><H3>
replaceStatementParameter</H3>
<PRE>
protected <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A> <B>replaceStatementParameter</B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                                        <A HREF="../../coins/ir/hir/SymNode.html" title="interface in coins.ir.hir">SymNode</A>&nbsp;pSymNode,
                                        java.util.Set&nbsp;pTraversedMatchingData,
                                        boolean&nbsp;pNontermParamOnly)</PRE>
<DL>
<DD>Replace the node of statement parameter with the sequence
 of statements corresponding to it.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pData</CODE> - MatchingData to be used.<DD><CODE>pSymNode</CODE> - Statement parameter node.<DD><CODE>pTraversedMatchingData</CODE> - Set of matching data already
     traversed (used to escape from infinite loop).<DD><CODE>pNontermParamOnly</CODE> - Set true if only nonterminal
     parameter nodes are to be replaced and leave pattaern
     parameter nodes are to be left unchanged, set false if
     both of nonterminal/pattern parameter nodes are to be
     replaced.
<DT><B>Returns:</B><DD>The replaced result.</DL>
</DD>
</DL>
<HR>

<A NAME="reformByChangingParam(coins.opt.GlobalReform.MatchingData, coins.ir.hir.HIR, coins.ir.hir.HIR, coins.ir.hir.HIR, java.util.Set, int)"><!-- --></A><H3>
reformByChangingParam</H3>
<PRE>
protected <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A> <B>reformByChangingParam</B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                                    <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pNontermCall,
                                    <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pParamNode,
                                    <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pRewriteExp,
                                    java.util.Set&nbsp;pTraversedMatchingData,
                                    int&nbsp;pNthInstance)</PRE>
<DL>
<DD>reformByChangingParam does the transformation specified by
   _reform(n_th_instance, patternParam, replacementExp,
            nonterminalCallExp).
 (1) Get the nonterminal instance specified by
    nonterminalCallExp and n_th_instance.
 (2) Get the matching data corresponding to the
    nonterminal instance.
 (2) Replace all parameter nodes same as pParamNode in
    pRewriteExp by the corresponding HIR given by the
    matching data and record the revised rewrite-expression
    as the new HIR corresponding to the parameter
    in local MatchingData.
    pRewriteExp may contain pattern parameters and
    _assignStmt function.
 (3) Adjust the expanded HIR of the nonterminal instance
    using the revised local MatchingData (by adjustnonterminal).
 (4) Return the result of adjustNonterminal.
 (This method is called in adjustOutPattern.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pData</CODE> - Matching data to be used.<DD><CODE>pNontermCall</CODE> - Nonterminal call expression specified
     in _reform expression.<DD><CODE>pParamNode</CODE> - Parameter node to be rewritten as
     as specified in _reform expression.<DD><CODE>pRewriteExp</CODE> - HIR to be used to replace pParamNode
     as specified in _reform expression.<DD><CODE>pTraversedMatchingData</CODE> - Set of matching data already
     traversed (used to convey information to adjustNonterminal).<DD><CODE>pNthInstance</CODE> - Sequence number of nonterminal instance
     among the instances having the same form of call expression
     in the in-pattern.
<DT><B>Returns:</B><DD>The resultant HIR subtree for the given _reform expression.</DL>
</DD>
</DL>
<HR>

<A NAME="transformStmtSeq(coins.opt.GlobalReform.MatchingData, coins.sym.Subp, coins.ir.hir.Stmt)"><!-- --></A><H3>
transformStmtSeq</H3>
<PRE>
protected <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A> <B>transformStmtSeq</B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                               <A HREF="../../coins/sym/Subp.html" title="interface in coins.sym">Subp</A>&nbsp;pPatternSym,
                               <A HREF="../../coins/ir/hir/Stmt.html" title="interface in coins.ir.hir">Stmt</A>&nbsp;pInStmt)</PRE>
<DL>
<DD>Transform the statement sequence beginning with pInStmt
 that matched with the statement pattern pPatternsym
 by applying adjustOutPattern to the corresponding
 out-pattern and then applying replaceParameters to the
 adjusted result.
 At return, fTailStmtMatched represents the last statement
 in the matched input statement sequence.
 (This method is called in tryToReform.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pData</CODE> - MatchingData instance to be used.<DD><CODE>pPatternSym</CODE> - Pattern symbol representing a statement pattern.<DD><CODE>pInStmt</CODE> - Heading statement of the matched statement sequence.
<DT><B>Returns:</B><DD>The resultant HIR.</DL>
</DD>
</DL>
<HR>

<A NAME="getFormalActualParamCorrespondence(coins.opt.GlobalReform.MatchingData, coins.opt.GlobalReform.NontermPatInstance, coins.ir.hir.HIR, boolean)"><!-- --></A><H3>
getFormalActualParamCorrespondence</H3>
<PRE>
protected java.util.Map <B>getFormalActualParamCorrespondence</B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                                                           <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A>&nbsp;pNontermPat,
                                                           <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pCallNode,
                                                           boolean&nbsp;pAdjustPhase)</PRE>
<DL>
<DD>Get formal-actual parameter correspondence for the nonterminal
 pNontermPat that is called by the node pCallNode and return the
 correspondence. If the caller argument contains child nonterminal call,
 then formal-actual parameter correspondence for the child nonterminal
 is computed by getParamCorrespForArgWithNonterm.
 The result is not reflected to pData in this method.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pData</CODE> - MatchingData inherited.<DD><CODE>pNontermPat</CODE> - nonterminal instance.<DD><CODE>pCallNode</CODE> - Node calling the nonterminal.<DD><CODE>pAdjustPhase</CODE> - True if called in adjust phase, false otherwise.
<DT><B>Returns:</B><DD>the resultant correspondence.</DL>
</DD>
</DL>
<HR>

<A NAME="getParamCorrespForArgWithNonterm(coins.opt.GlobalReform.MatchingData, coins.ir.hir.HIR, coins.sym.Sym, coins.opt.GlobalReform.NontermPatInstance, boolean)"><!-- --></A><H3>
getParamCorrespForArgWithNonterm</H3>
<PRE>
protected java.util.Map <B>getParamCorrespForArgWithNonterm</B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                                                         <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pArgExp,
                                                         <A HREF="../../coins/sym/Sym.html" title="interface in coins.sym">Sym</A>&nbsp;pCallerFormalParam,
                                                         <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A>&nbsp;pParentNonterm,
                                                         boolean&nbsp;pAdjustPhase)</PRE>
<DL>
<DD>Get formal-actual parameter correspondence for the formal parameter
 pCallerFormalParam and actual parameter pArgExp that calls
 child nonterminal. The matching data pData is not changed.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pData</CODE> - Inherited MatchingData.<DD><CODE>pArgExp</CODE> - Actual parameter that calls child nonterminal.<DD><CODE>pCallerFormalParam</CODE> - Formal parameter corresponding to pArgExp.<DD><CODE>pParentNonterm</CODE> - Nonterminal that calls the child nonterminal.
<DT><B>Returns:</B><DD>formal-actual parameter correspondence.</DL>
</DD>
</DL>
<HR>

<A NAME="expandExp(coins.opt.GlobalReform.MatchingData, coins.ir.hir.HIR, coins.opt.GlobalReform.NontermPatInstance)"><!-- --></A><H3>
expandExp</H3>
<PRE>
protected <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A> <B>expandExp</B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                        <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pExp,
                        <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A>&nbsp;pParentNonterm)</PRE>
<DL>
<DD>Expand all nonterminal calls in pExp to the
 the expandedExp of the nonterminal instance corresponding
 to the nonterminal call.
 (Called in getFormalActualParamCorrespondence.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pData</CODE> - MatchingData to be used.<DD><CODE>pExp</CODE> - HIR to be expanded.<DD><CODE>pParentNonterm</CODE> - Nonterminal instance
<DT><B>Returns:</B><DD>the resultant expanded HIR.</DL>
</DD>
</DL>
<HR>

<A NAME="checkConsistency(coins.sym.Subp, java.util.List, coins.ir.hir.HIR, coins.ir.hir.HIR)"><!-- --></A><H3>
checkConsistency</H3>
<PRE>
protected boolean <B>checkConsistency</B>(<A HREF="../../coins/sym/Subp.html" title="interface in coins.sym">Subp</A>&nbsp;pPattern,
                                   java.util.List&nbsp;pLocalVarList,
                                   <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pInPattern,
                                   <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pOutPattern)</PRE>
<DL>
<DD>Check the consistency of parameters in in-pattern
 and out-pattern. Any of following cases are treated
 as inconsistent usage:
   Some parameter in the out-pattern does not appear
   in the in-pattern.
   Some parameter in the in-pattern does not appear
   in the out-pattern.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pPattern</CODE> - subprogram representing a pattern.<DD><CODE>pLocalVarList</CODE> - list of variables declared locally
     in pOutPattern.<DD><CODE>pInPattern</CODE> - in-pattern.<DD><CODE>pOutPattern</CODE> - out-pattern.
<DT><B>Returns:</B><DD>true if no inconsistency is found, false if some
     inconsistency is found.</DL>
</DD>
</DL>
<HR>

<A NAME="patternCode(coins.ir.hir.HIR)"><!-- --></A><H3>
patternCode</H3>
<PRE>
protected double <B>patternCode</B>(<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pHir)</PRE>
<DL>
<DD>Compute the pattern code of pHir digging out up to 2 levels
 of children.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pHir</CODE> - geven HIR subtree.
<DT><B>Returns:</B><DD>pattern code of pHir.</DL>
</DD>
</DL>
<HR>

<A NAME="computePatternCodeRange()"><!-- --></A><H3>
computePatternCodeRange</H3>
<PRE>
protected void <B>computePatternCodeRange</B>()</PRE>
<DL>
<DD>computePatternCodeRange
 compute pattern code range (fPatternCodeUpper and fPatternCodeLower)
 of all patterns.
 If the pattern is a block statement containing multiple statements,
 then compute code range of its 1st statement and 2nd statement
 (fStmt1CodeUpper/Lower and fStmt2CodeUpper/Lower) and the number of
 statements in the pattern (fStmtsInPattern).
 The pattern code of HIR subtree
   c0 --- c1 --- c11
      |      |-- c12
      |
      |-- c2 --- c21
             |-- c22
 is computed as
   c0*L*L*L*L*L*L + c1*L*L*L*L*L + c2*L*L*L*L
   + c11*L*L*L + c12*L*L + c21*L + c22
 where, c0, c1, etc. are operator code and
 L is fHirCodeLim (greater than any HIR operator code).
 If some child in above tree is a parameter, then
 fDontCareCode (greater than any opCode) is used as its
 operator code for computing upper code
 and 0 is used as its operator (corresponding to the case
 where the child is null) for computing lower code.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="computePatternCodeRangeOf(coins.ir.hir.HIR)"><!-- --></A><H3>
computePatternCodeRangeOf</H3>
<PRE>
protected <A HREF="../../coins/opt/GlobalReform.PatternCodeRange.html" title="class in coins.opt">GlobalReform.PatternCodeRange</A> <B>computePatternCodeRangeOf</B>(<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pHir)</PRE>
<DL>
<DD>computePatternCodeRangeOf(.....) computes pattern code range
 of pHir and set upper to pUpper[0], loper to pLower[0].
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pHir</CODE> - HIR for which the pattern code range is to be computed.</DL>
</DD>
</DL>
<HR>

<A NAME="setPatternCodeRange(int, java.util.List)"><!-- --></A><H3>
setPatternCodeRange</H3>
<PRE>
int <B>setPatternCodeRange</B>(int&nbsp;pStartIndex,
                        java.util.List&nbsp;pRangeList)</PRE>
<DL>
<DD>Set the pattern code ranges in pRangeList to
 fPatternCodeUpper/Lower starting from pStartIndex and return
 the updated next index value.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pStartIndex</CODE> - start position to store the pattern codes.<DD><CODE>pRangeList</CODE> - list of pattern codes.
<DT><B>Returns:</B><DD>the updated next position.</DL>
</DD>
</DL>
<HR>

<A NAME="replaceExpAdjustingType(coins.ir.hir.Exp, coins.ir.hir.Exp)"><!-- --></A><H3>
replaceExpAdjustingType</H3>
<PRE>
protected <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A> <B>replaceExpAdjustingType</B>(<A HREF="../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;lOld,
                                      <A HREF="../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;lNew)</PRE>
<DL>
<DD>Replace expression lOld by lNew adjusting type to
 that of lOld.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>lOld</CODE> - old expression to be replaced.<DD><CODE>lNew</CODE> - new expression for replacement.
<DT><B>Returns:</B><DD>replaced expression.</DL>
</DD>
</DL>
<HR>

<A NAME="adjustType(coins.ir.hir.Exp, coins.sym.Type)"><!-- --></A><H3>
adjustType</H3>
<PRE>
protected <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A> <B>adjustType</B>(<A HREF="../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pExp,
                         <A HREF="../../coins/sym/Type.html" title="interface in coins.sym">Type</A>&nbsp;pType)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="replaceHirTree(coins.ir.hir.HIR, coins.ir.hir.HIR)"><!-- --></A><H3>
replaceHirTree</H3>
<PRE>
protected <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A> <B>replaceHirTree</B>(<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pOld,
                             <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pNew)</PRE>
<DL>
<DD>Replace pOld with pNew according to their kind.
 If isSameTree(pOld,pNew), do not replace.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pOld</CODE> - Old HIR to be replaced.<DD><CODE>pNew</CODE> - New HIR used to replace.
<DT><B>Returns:</B><DD>the replaced result.</DL>
</DD>
</DL>
<HR>

<A NAME="isSameTree(coins.ir.hir.HIR, coins.ir.hir.HIR)"><!-- --></A><H3>
isSameTree</H3>
<PRE>
protected boolean <B>isSameTree</B>(<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pTree1,
                             <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pTree2)</PRE>
<DL>
<DD>isSameTree is a little different from that of coins.flow.HirSubpFlowImpl.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pTree1</CODE> - HIR tree to be compared.<DD><CODE>pTree2</CODE> - Another HIR tree to be compared.
<DT><B>Returns:</B><DD>true if pTree1 and pTree2 have the same shape and contents,
    false otherwise.</DL>
</DD>
</DL>
<HR>

<A NAME="processTransparent(coins.sym.Subp, java.lang.String, coins.ir.IrList)"><!-- --></A><H3>
processTransparent</H3>
<PRE>
protected void <B>processTransparent</B>(<A HREF="../../coins/sym/Subp.html" title="interface in coins.sym">Subp</A>&nbsp;pPattern,
                                  java.lang.String&nbsp;pOptionName,
                                  <A HREF="../../coins/ir/IrList.html" title="interface in coins.ir">IrList</A>&nbsp;pOptionList)</PRE>
<DL>
<DD>Process the pragma specifications such as
   #pragma globalReform transparentFitting pc (pzz2, pi2)
 and record the transparency relations to fTransparentMap.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pPattern</CODE> - Pattern symbol.<DD><CODE>pOptionName</CODE> - Option name ("transparentFitting", etc.).<DD><CODE>pOptionList</CODE> - List of the transparency relation.</DL>
</DD>
</DL>
<HR>

<A NAME="setNonterminalFlag(coins.ir.hir.HIR)"><!-- --></A><H3>
setNonterminalFlag</H3>
<PRE>
protected void <B>setNonterminalFlag</B>(<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pPattern)</PRE>
<DL>
<DD>Set FLAG_NONTERMINAL to all call nodes that call _bnfOr,
 _bnfSeq, or _assignStmt contained in pPattern.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pPattern</CODE> - HIR to which nodes nonterminal flag is
     to be attached.</DL>
</DD>
</DL>
<HR>

<A NAME="getIndex(coins.sym.Subp)"><!-- --></A><H3>
getIndex</H3>
<PRE>
int <B>getIndex</B>(<A HREF="../../coins/sym/Subp.html" title="interface in coins.sym">Subp</A>&nbsp;pSubp)</PRE>
<DL>
<DD>Get the index number of a pattern or a nonterminal.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pSubp</CODE> - is  a pattern or a nonterminal.
<DT><B>Returns:</B><DD>the index value.</DL>
</DD>
</DL>
<HR>

<A NAME="isTransparent(coins.sym.Var, coins.ir.hir.HIR, coins.opt.GlobalReform.MatchingData)"><!-- --></A><H3>
isTransparent</H3>
<PRE>
protected boolean <B>isTransparent</B>(<A HREF="../../coins/sym/Var.html" title="interface in coins.sym">Var</A>&nbsp;pDeclVar,
                                <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pHir,
                                <A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData)</PRE>
<DL>
<DD>If pDeclVar is declared as transparent to some variables
 and if pHir contains any of such variables or
 pDeclVar is included in pHir then
 pHir is treated as not transparent to pDeclVar
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pDeclVar</CODE> - variable that should be transparent.<DD><CODE>pHir</CODE> - HIR to be examined.
<DT><B>Returns:</B><DD>true if tranparent.</DL>
</DD>
</DL>
<HR>

<A NAME="getLeafOperands(coins.ir.hir.HIR)"><!-- --></A><H3>
getLeafOperands</H3>
<PRE>
protected java.util.Set <B>getLeafOperands</B>(<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pHir)</PRE>
<DL>
<DD>Get the set of leaf operands of pHir.
 Constant operands are excluded.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pHir</CODE> - HIR subtree.
<DT><B>Returns:</B><DD>the set of leaf operands.</DL>
</DD>
</DL>
<HR>

<A NAME="listUpHeadingHir(coins.sym.Subp, java.util.List, coins.ir.hir.HIR)"><!-- --></A><H3>
listUpHeadingHir</H3>
<PRE>
protected void <B>listUpHeadingHir</B>(<A HREF="../../coins/sym/Subp.html" title="interface in coins.sym">Subp</A>&nbsp;pNontermPatSym,
                                java.util.List&nbsp;pHeadingHirList,
                                <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pHir)</PRE>
<DL>
<DD>List up top subtrees for pHir and add the subtrees to
 pHeadingHirList.
 A pattern or nonterminal may have multiple top subtrees
 if the right-hand side of their production begins with _bnfOr
 or begins with a nonterminal having multiple top subtrees.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pNontermPatSym</CODE> - pattern symbol or nonterminal symbol.<DD><CODE>pHeadingHirList</CODE> - is a list to which top subtrees are
           to be added.<DD><CODE>pHir</CODE> - is the right-hand side of the production
     corresponding to the pattern or the nonterminal.</DL>
</DD>
</DL>
<HR>

<A NAME="recordParamCorresp(coins.opt.GlobalReform.MatchingData, coins.sym.Sym, coins.ir.hir.HIR)"><!-- --></A><H3>
recordParamCorresp</H3>
<PRE>
protected boolean <B>recordParamCorresp</B>(<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt">GlobalReform.MatchingData</A>&nbsp;pData,
                                     <A HREF="../../coins/sym/Sym.html" title="interface in coins.sym">Sym</A>&nbsp;pParam,
                                     <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pHir)</PRE>
<DL>
<DD>Record the correspondence between the parameter pParam and
 the (matched) input pHir.
 This method also records matchedInput and expandedHir to pData.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pData</CODE> - matching data inherited.<DD><CODE>pParam</CODE> - symbol that may be (1) a pattern/nonterminal parameter instance
     or (2) a pattern symbol itself representing recursive function
     or (3) a fitting symbol instance.<DD><CODE>pHir</CODE> - input HIR that is treaded as matched with pParam.
<DT><B>Returns:</B><DD>true if correspondence was found false if not found.</DL>
</DD>
</DL>
<HR>

<A NAME="putToMap(java.util.Map, coins.sym.Sym, coins.ir.hir.HIR)"><!-- --></A><H3>
putToMap</H3>
<PRE>
protected void <B>putToMap</B>(java.util.Map&nbsp;pMap,
                        <A HREF="../../coins/sym/Sym.html" title="interface in coins.sym">Sym</A>&nbsp;pSym,
                        <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pHir)</PRE>
<DL>
<DD>Put the correspondence of pSym-pHir to pMap
 if it is not a circular reference that is,
 if pSym is not an operand of pHir.
 If the correspondence is not recorded in fGlobalPatternParamMap,
 then record it. If pSym is recorded in fGlobalPatternParamMap
 as different tree, then "Inconsistent with previous value"
 message is issued.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pMap</CODE> - map to record the correspondence.<DD><CODE>pSym</CODE> - variable (usually a parameter instance).<DD><CODE>pHir</CODE> - HIR subtree that corresponds to pSym.</DL>
</DD>
</DL>
<HR>

<A NAME="dbgOut(int, java.lang.String)"><!-- --></A><H3>
dbgOut</H3>
<PRE>
protected void <B>dbgOut</B>(int&nbsp;pLevel,
                      java.lang.String&nbsp;pMessage)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="dbgOut(int, java.lang.String, java.lang.String)"><!-- --></A><H3>
dbgOut</H3>
<PRE>
protected void <B>dbgOut</B>(int&nbsp;pLevel,
                      java.lang.String&nbsp;pMessageClass,
                      java.lang.String&nbsp;pMessage)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="dbgMap(java.util.Map)"><!-- --></A><H3>
dbgMap</H3>
<PRE>
protected java.lang.String <B>dbgMap</B>(java.util.Map&nbsp;pMap)</PRE>
<DL>
<DD>make the text string showing the contents of the map pMap.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pMap</CODE> - Map to be displayed in the form of text string.
<DT><B>Returns:</B><DD>the resultant test string.</DL>
</DD>
</DL>
<HR>

<A NAME="dbgSet(java.util.Set)"><!-- --></A><H3>
dbgSet</H3>
<PRE>
protected java.lang.String <B>dbgSet</B>(java.util.Set&nbsp;pSet)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="hirToString(coins.ir.hir.HIR)"><!-- --></A><H3>
hirToString</H3>
<PRE>
public java.lang.String <B>hirToString</B>(<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pHir)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="recordExpandedHir(coins.ir.hir.HIR, coins.ir.hir.HIR, coins.opt.GlobalReform.NontermPatInstance)"><!-- --></A><H3>
recordExpandedHir</H3>
<PRE>
protected void <B>recordExpandedHir</B>(<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pCallExp,
                                 <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pExpandedHir,
                                 <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A>&nbsp;pNontermPatInstance)</PRE>
<DL>
<DD>Record the copy of pExpandedHir to
   fExpandedNontermInstance using pNontermPatInstance as key and
   fExpandedNonterm using makeHirKey(pCallExp) as key.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pCallExp</CODE> - call expression for the nonterminal.<DD><CODE>pExpandedHir</CODE> - expanded HIR for the nonterminal.<DD><CODE>pNontermPatInstance</CODE> - nonterminal instance.</DL>
</DD>
</DL>
<HR>

<A NAME="getExpandedHir(coins.ir.hir.HIR, coins.opt.GlobalReform.NontermPatInstance)"><!-- --></A><H3>
getExpandedHir</H3>
<PRE>
protected <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A> <B>getExpandedHir</B>(<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pCallExp,
                             <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A>&nbsp;pNontermInstance)</PRE>
<DL>
<DD>Get the expanded HIR corresponding to pCallExp
 calling pNonterminal. The same nonterminal may have
 different expansion according to its actual parameter
 list.
 //##86 REFINE Is there anay case where call expressions
 // of the same type has different expansion ?
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pCallExp</CODE> - expression calling pNonterminal.
<DT><B>Returns:</B><DD>the expanded HIR corresponding to pCallExp.</DL>
</DD>
</DL>
<HR>

<A NAME="makeHirKey(coins.ir.hir.HIR)"><!-- --></A><H3>
makeHirKey</H3>
<PRE>
protected <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A> <B>makeHirKey</B>(<A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pExp)</PRE>
<DL>
<DD>Make an HIR that can be used as a key of maps
 so that there is only one instance for each group of
 HIR subtrees where member subtrees have the same shape
 when they are included in the same group
 (keeping one to one correspondence between key
 and group).
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pExp</CODE> - HIR subtree to which key is to be searched.
<DT><B>Returns:</B><DD>the key corresponding to the group to which
     pExp belongs.</DL>
</DD>
</DL>
<HR>

<A NAME="getNontermInstance(coins.sym.Subp, coins.ir.hir.HIR, coins.opt.GlobalReform.NontermPatInstance)"><!-- --></A><H3>
getNontermInstance</H3>
<PRE>
protected <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A> <B>getNontermInstance</B>(<A HREF="../../coins/sym/Subp.html" title="interface in coins.sym">Subp</A>&nbsp;pNonterm,
                                                             <A HREF="../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pCallExp,
                                                             <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A>&nbsp;pParentInstance)</PRE>
<DL>
<DD>Get the instance of the nonterminal pNonterm corresponding
 to the nonterminal call expression pCallExp
 seeing callToNontermInstanceMap of the parent nonterminal
 pParentInstance.
 If it is not found then look for the ancestor of the parent
 (parent of the parent, etc.).
 (This method is refered in expandExp.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pNonterm</CODE> - Nonterminal symbol.<DD><CODE>pCallExp</CODE> - Nonterminal call expression.<DD><CODE>pParentInstance</CODE> - Instance of parent nonterminal or pattern
     whose definition body contains the nonterminal call pCallExp.
<DT><B>Returns:</B><DD>the nonterminal instance.</DL>
</DD>
</DL>
<HR>

<A NAME="instanciateParam(coins.sym.Subp, coins.sym.Param, int)"><!-- --></A><H3>
instanciateParam</H3>
<PRE>
protected <A HREF="../../coins/sym/Param.html" title="interface in coins.sym">Param</A> <B>instanciateParam</B>(<A HREF="../../coins/sym/Subp.html" title="interface in coins.sym">Subp</A>&nbsp;pNonterm,
                                 <A HREF="../../coins/sym/Param.html" title="interface in coins.sym">Param</A>&nbsp;pParam,
                                 int&nbsp;pInstanceNumber)</PRE>
<DL>
<DD>Get a new instance of the parameter pParam used in
 the nonterminal pnonterm.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pNonterm</CODE> - Nonterminal symbol.<DD><CODE>pParam</CODE> - Formal parameter of pNonterm.<DD><CODE>pInstanceNumber</CODE> - Instance number.
<DT><B>Returns:</B><DD>the instanciated parameter.</DL>
</DD>
</DL>
<HR>

<A NAME="instanciateVar(coins.sym.Subp, coins.sym.Var, int, int)"><!-- --></A><H3>
instanciateVar</H3>
<PRE>
protected <A HREF="../../coins/sym/Var.html" title="interface in coins.sym">Var</A> <B>instanciateVar</B>(<A HREF="../../coins/sym/Subp.html" title="interface in coins.sym">Subp</A>&nbsp;pNonterm,
                             <A HREF="../../coins/sym/Var.html" title="interface in coins.sym">Var</A>&nbsp;pVar,
                             int&nbsp;pKind,
                             int&nbsp;pInstanceNumber)</PRE>
<DL>
<DD>Get the new instance of the variable pVar.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pNonterm</CODE> - Nonterminal containing the variable pVar.<DD><CODE>pVar</CODE> - Variable symbol.<DD><CODE>pKind</CODE> - Symbol kind of the variable.<DD><CODE>pInstanceNumber</CODE> - Instance number within the nonterminal
    (this parameter is not yet used).
<DT><B>Returns:</B><DD>the instanciated variable.</DL>
</DD>
</DL>
<HR>

<A NAME="getParamInstance(coins.sym.Param, coins.opt.GlobalReform.NontermPatInstance)"><!-- --></A><H3>
getParamInstance</H3>
<PRE>
protected <A HREF="../../coins/sym/Param.html" title="interface in coins.sym">Param</A> <B>getParamInstance</B>(<A HREF="../../coins/sym/Param.html" title="interface in coins.sym">Param</A>&nbsp;pParam,
                                 <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A>&nbsp;pNontermInstance)</PRE>
<DL>
<DD>Get the parameter instanciated from pParam for the
 instance of the nonterminal pNontermInstance.
 (Formal parameters are instanciated for each
  nonterminal instance.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pParam</CODE> - Formal parameter from which new parameter
    is instanciated.<DD><CODE>pNontermInstance</CODE> - Instance of a nonterminal.
<DT><B>Returns:</B><DD>the instance of the parameter.</DL>
</DD>
</DL>
<HR>

<A NAME="getVarInstance(coins.sym.Var, coins.opt.GlobalReform.NontermPatInstance)"><!-- --></A><H3>
getVarInstance</H3>
<PRE>
protected <A HREF="../../coins/sym/Var.html" title="interface in coins.sym">Var</A> <B>getVarInstance</B>(<A HREF="../../coins/sym/Var.html" title="interface in coins.sym">Var</A>&nbsp;pVar,
                             <A HREF="../../coins/opt/GlobalReform.NontermPatInstance.html" title="class in coins.opt">GlobalReform.NontermPatInstance</A>&nbsp;pNontermInstance)</PRE>
<DL>
<DD>Get the variable instanciated from pVar for the
 instance of the nonterminal pNontermInstance.
 (Local variables (including formal parameters) are
  instanciated for each nonterminal instance.)
 If not found, then search among variables instanciated
 for ancestor nonterminal instances.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pVar</CODE> - Variable  from which new variable is instanciated.<DD><CODE>pNontermInstance</CODE> - Instance of a nonterminal.
<DT><B>Returns:</B><DD>the instance of the variable.</DL>
</DD>
</DL>
<HR>

<A NAME="getOriginalParam(coins.sym.Param)"><!-- --></A><H3>
getOriginalParam</H3>
<PRE>
protected <A HREF="../../coins/sym/Param.html" title="interface in coins.sym">Param</A> <B>getOriginalParam</B>(<A HREF="../../coins/sym/Param.html" title="interface in coins.sym">Param</A>&nbsp;pParam)</PRE>
<DL>
<DD>Get the original parameter from which pParam is instanciated.
 If pParam is already the original parameter, then return it.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pParam</CODE> - Instance of a formal parameter.
<DT><B>Returns:</B><DD>the original parameter.</DL>
</DD>
</DL>
<HR>

<A NAME="getOriginalVar(coins.sym.Var)"><!-- --></A><H3>
getOriginalVar</H3>
<PRE>
protected <A HREF="../../coins/sym/Var.html" title="interface in coins.sym">Var</A> <B>getOriginalVar</B>(<A HREF="../../coins/sym/Var.html" title="interface in coins.sym">Var</A>&nbsp;pVar)</PRE>
<DL>
<DD>Get the original variable from which pVar is instanciated.
 If pVar is already the original variable, then return it.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pVar</CODE> - Instance of a variable.
<DT><B>Returns:</B><DD>the original variable.</DL>
</DD>
</DL>
<HR>

<A NAME="isPatternParam(coins.sym.Sym)"><!-- --></A><H3>
isPatternParam</H3>
<PRE>
protected boolean <B>isPatternParam</B>(<A HREF="../../coins/sym/Sym.html" title="interface in coins.sym">Sym</A>&nbsp;pSym)</PRE>
<DL>
<DD>If pSym is a pattern parameter or an instance of a
 pattern parameter, then return true, else return false.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pSym</CODE> - Symbol to be examined.
<DT><B>Returns:</B><DD>true or false.</DL>
</DD>
</DL>
<HR>

<A NAME="isNontermParam(coins.sym.Sym)"><!-- --></A><H3>
isNontermParam</H3>
<PRE>
protected boolean <B>isNontermParam</B>(<A HREF="../../coins/sym/Sym.html" title="interface in coins.sym">Sym</A>&nbsp;pSym)</PRE>
<DL>
<DD>If pSym is a nonterminal parameter or an instance of a
 nonterminal parameter, then return true, else return false.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pSym</CODE> - Symbol to be examined.
<DT><B>Returns:</B><DD>true or false.</DL>
</DD>
</DL>
<HR>

<A NAME="isFittingSym(coins.sym.Sym)"><!-- --></A><H3>
isFittingSym</H3>
<PRE>
protected boolean <B>isFittingSym</B>(<A HREF="../../coins/sym/Sym.html" title="interface in coins.sym">Sym</A>&nbsp;pSym)</PRE>
<DL>
<DD>If pSym is a fitting symbol or an instance of a
 fitting symbol, then return true, else return false.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pSym</CODE> - Symbol to be examined.
<DT><B>Returns:</B><DD>true or false.</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../coins/opt/DeadCodeElim.html" title="class in coins.opt"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../coins/opt/GlobalReform.MatchingData.html" title="class in coins.opt"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="GlobalReform.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
