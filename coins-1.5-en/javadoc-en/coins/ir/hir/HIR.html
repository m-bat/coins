<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.4.2_12) on Fri Sep 12 11:04:43 JST 2008 -->
<TITLE>
HIR
</TITLE>

<META NAME="keywords" CONTENT="coins.ir.hir.HIR interface">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="HIR";
}
</SCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../coins/ir/hir/FunctionExp.html" title="interface in coins.ir.hir"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../coins/ir/hir/HIR0.html" title="interface in coins.ir.hir"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="HIR.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
coins.ir.hir</FONT>
<BR>
Interface HIR</H2>
<DL>
<DT><B>All Superinterfaces:</B> <DD>java.lang.Cloneable, <A HREF="../../../coins/ir/hir/HIR0.html" title="interface in coins.ir.hir">HIR0</A>, <A HREF="../../../coins/ir/IR.html" title="interface in coins.ir">IR</A>, <A HREF="../../../coins/ir/IR0.html" title="interface in coins.ir">IR0</A></DD>
</DL>
<DL>
<DT><B>All Known Subinterfaces:</B> <DD><A HREF="../../../coins/ir/hir/AsmStmt.html" title="interface in coins.ir.hir">AsmStmt</A>, <A HREF="../../../coins/ir/hir/AssignStmt.html" title="interface in coins.ir.hir">AssignStmt</A>, <A HREF="../../../coins/ir/hir/BlockStmt.html" title="interface in coins.ir.hir">BlockStmt</A>, <A HREF="../../../coins/ir/hir/ConstNode.html" title="interface in coins.ir.hir">ConstNode</A>, <A HREF="../../../coins/ir/hir/ElemNode.html" title="interface in coins.ir.hir">ElemNode</A>, <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>, <A HREF="../../../coins/ir/hir/ExpListExp.html" title="interface in coins.ir.hir">ExpListExp</A>, <A HREF="../../../coins/ir/hir/ExpStmt.html" title="interface in coins.ir.hir">ExpStmt</A>, <A HREF="../../../coins/ir/hir/ForStmt.html" title="interface in coins.ir.hir">ForStmt</A>, <A HREF="../../../coins/ir/hir/FunctionExp.html" title="interface in coins.ir.hir">FunctionExp</A>, <A HREF="../../../coins/ir/hir/HirList.html" title="interface in coins.ir.hir">HirList</A>, <A HREF="../../../coins/ir/hir/HirSeq.html" title="interface in coins.ir.hir">HirSeq</A>, <A HREF="../../../coins/ir/hir/IfStmt.html" title="interface in coins.ir.hir">IfStmt</A>, <A HREF="../../../coins/ir/hir/IndexedLoopStmt.html" title="interface in coins.ir.hir">IndexedLoopStmt</A>, <A HREF="../../../coins/ir/hir/InfNode.html" title="interface in coins.ir.hir">InfNode</A>, <A HREF="../../../coins/ir/hir/InfStmt.html" title="interface in coins.ir.hir">InfStmt</A>, <A HREF="../../../coins/ir/hir/JumpStmt.html" title="interface in coins.ir.hir">JumpStmt</A>, <A HREF="../../../coins/ir/hir/LabelDef.html" title="interface in coins.ir.hir">LabelDef</A>, <A HREF="../../../coins/ir/hir/LabeledStmt.html" title="interface in coins.ir.hir">LabeledStmt</A>, <A HREF="../../../coins/ir/hir/LabelNode.html" title="interface in coins.ir.hir">LabelNode</A>, <A HREF="../../../coins/ir/hir/LoopStmt.html" title="interface in coins.ir.hir">LoopStmt</A>, <A HREF="../../../coins/ir/hir/NullNode.html" title="interface in coins.ir.hir">NullNode</A>, <A HREF="../../../coins/ir/hir/PhiExp.html" title="interface in coins.ir.hir">PhiExp</A>, <A HREF="../../../coins/ir/hir/PointedExp.html" title="interface in coins.ir.hir">PointedExp</A>, <A HREF="../../../coins/ir/hir/Program.html" title="interface in coins.ir.hir">Program</A>, <A HREF="../../../coins/ir/hir/QualifiedExp.html" title="interface in coins.ir.hir">QualifiedExp</A>, <A HREF="../../../coins/ir/hir/RepeatStmt.html" title="interface in coins.ir.hir">RepeatStmt</A>, <A HREF="../../../coins/ir/hir/ReturnStmt.html" title="interface in coins.ir.hir">ReturnStmt</A>, <A HREF="../../../coins/ir/hir/SetDataStmt.html" title="interface in coins.ir.hir">SetDataStmt</A>, <A HREF="../../../coins/ir/hir/Stmt.html" title="interface in coins.ir.hir">Stmt</A>, <A HREF="../../../coins/ir/hir/SubpDefinition.html" title="interface in coins.ir.hir">SubpDefinition</A>, <A HREF="../../../coins/ir/hir/SubpNode.html" title="interface in coins.ir.hir">SubpNode</A>, <A HREF="../../../coins/ir/hir/SubscriptedExp.html" title="interface in coins.ir.hir">SubscriptedExp</A>, <A HREF="../../../coins/ir/hir/SwitchStmt.html" title="interface in coins.ir.hir">SwitchStmt</A>, <A HREF="../../../coins/ir/hir/SymNode.html" title="interface in coins.ir.hir">SymNode</A>, <A HREF="../../../coins/ir/hir/TypeNode.html" title="interface in coins.ir.hir">TypeNode</A>, <A HREF="../../../coins/ir/hir/UntilStmt.html" title="interface in coins.ir.hir">UntilStmt</A>, <A HREF="../../../coins/ir/hir/VarNode.html" title="interface in coins.ir.hir">VarNode</A>, <A HREF="../../../coins/ir/hir/WhileStmt.html" title="interface in coins.ir.hir">WhileStmt</A></DD>
</DL>
<DL>
<DT><B>All Known Implementing Classes:</B> <DD><A HREF="../../../coins/ir/hir/AsmStmtImpl.html" title="class in coins.ir.hir">AsmStmtImpl</A>, <A HREF="../../../coins/ir/hir/AssignStmtImpl.html" title="class in coins.ir.hir">AssignStmtImpl</A>, <A HREF="../../../coins/ir/hir/BlockStmtImpl.html" title="class in coins.ir.hir">BlockStmtImpl</A>, <A HREF="../../../coins/ir/hir/ConstNodeImpl.html" title="class in coins.ir.hir">ConstNodeImpl</A>, <A HREF="../../../coins/ir/hir/ElemNodeImpl.html" title="class in coins.ir.hir">ElemNodeImpl</A>, <A HREF="../../../coins/ir/hir/ExpImpl.html" title="class in coins.ir.hir">ExpImpl</A>, <A HREF="../../../coins/ir/hir/ExpListExpImpl.html" title="class in coins.ir.hir">ExpListExpImpl</A>, <A HREF="../../../coins/ir/hir/ExpStmtImpl.html" title="class in coins.ir.hir">ExpStmtImpl</A>, <A HREF="../../../coins/ir/hir/ForStmtImpl.html" title="class in coins.ir.hir">ForStmtImpl</A>, <A HREF="../../../coins/ir/hir/FunctionExpImpl.html" title="class in coins.ir.hir">FunctionExpImpl</A>, <A HREF="../../../coins/ir/hir/HIR_Impl.html" title="class in coins.ir.hir">HIR_Impl</A>, <A HREF="../../../coins/ir/hir/HirListImpl.html" title="class in coins.ir.hir">HirListImpl</A>, <A HREF="../../../coins/ir/hir/HirSeqImpl.html" title="class in coins.ir.hir">HirSeqImpl</A>, <A HREF="../../../coins/ir/hir/IfStmtImpl.html" title="class in coins.ir.hir">IfStmtImpl</A>, <A HREF="../../../coins/ir/hir/IndexedLoopStmtImpl.html" title="class in coins.ir.hir">IndexedLoopStmtImpl</A>, <A HREF="../../../coins/ir/hir/InfNodeImpl.html" title="class in coins.ir.hir">InfNodeImpl</A>, <A HREF="../../../coins/ir/hir/InfStmtImpl.html" title="class in coins.ir.hir">InfStmtImpl</A>, <A HREF="../../../coins/ir/hir/JumpStmtImpl.html" title="class in coins.ir.hir">JumpStmtImpl</A>, <A HREF="../../../coins/ir/hir/LabelDefImpl.html" title="class in coins.ir.hir">LabelDefImpl</A>, <A HREF="../../../coins/ir/hir/LabeledStmtImpl.html" title="class in coins.ir.hir">LabeledStmtImpl</A>, <A HREF="../../../coins/ir/hir/LabelNodeImpl.html" title="class in coins.ir.hir">LabelNodeImpl</A>, <A HREF="../../../coins/ir/hir/LoopStmtImpl.html" title="class in coins.ir.hir">LoopStmtImpl</A>, <A HREF="../../../coins/ir/hir/NullNodeImpl.html" title="class in coins.ir.hir">NullNodeImpl</A>, <A HREF="../../../coins/ir/hir/PhiExpImpl.html" title="class in coins.ir.hir">PhiExpImpl</A>, <A HREF="../../../coins/ir/hir/PointedExpImpl.html" title="class in coins.ir.hir">PointedExpImpl</A>, <A HREF="../../../coins/ir/hir/ProgramImpl.html" title="class in coins.ir.hir">ProgramImpl</A>, <A HREF="../../../coins/ir/hir/QualifiedExpImpl.html" title="class in coins.ir.hir">QualifiedExpImpl</A>, <A HREF="../../../coins/ir/hir/RepeatStmtImpl.html" title="class in coins.ir.hir">RepeatStmtImpl</A>, <A HREF="../../../coins/ir/hir/ReturnStmtImpl.html" title="class in coins.ir.hir">ReturnStmtImpl</A>, <A HREF="../../../coins/ir/hir/SetDataStmtImpl.html" title="class in coins.ir.hir">SetDataStmtImpl</A>, <A HREF="../../../coins/ir/hir/StmtImpl.html" title="class in coins.ir.hir">StmtImpl</A>, <A HREF="../../../coins/ir/hir/SubpDefinitionImpl.html" title="class in coins.ir.hir">SubpDefinitionImpl</A>, <A HREF="../../../coins/ir/hir/SubpNodeImpl.html" title="class in coins.ir.hir">SubpNodeImpl</A>, <A HREF="../../../coins/ir/hir/SubscriptedExpImpl.html" title="class in coins.ir.hir">SubscriptedExpImpl</A>, <A HREF="../../../coins/ir/hir/SwitchStmtImpl.html" title="class in coins.ir.hir">SwitchStmtImpl</A>, <A HREF="../../../coins/ir/hir/SymNodeImpl.html" title="class in coins.ir.hir">SymNodeImpl</A>, <A HREF="../../../coins/ir/hir/TypeNodeImpl.html" title="class in coins.ir.hir">TypeNodeImpl</A>, <A HREF="../../../coins/ir/hir/UntilStmtImpl.html" title="class in coins.ir.hir">UntilStmtImpl</A>, <A HREF="../../../coins/ir/hir/VarNodeImpl.html" title="class in coins.ir.hir">VarNodeImpl</A>, <A HREF="../../../coins/ir/hir/WhileStmtImpl.html" title="class in coins.ir.hir">WhileStmtImpl</A></DD>
</DL>
<HR>
<DL>
<DT>public interface <B>HIR</B><DT>extends <A HREF="../../../coins/ir/IR.html" title="interface in coins.ir">IR</A>, <A HREF="../../../coins/ir/hir/HIR0.html" title="interface in coins.ir.hir">HIR0</A>, java.lang.Cloneable</DL>

<P>
HIR interface
<PRE>
 High Level Intermediate Representation (HIR) interface.
 All HIR classes implement all methods declared in HIR interface
 and IR interface which is inherited by the HIR interface.
 See IR, Stmt, Exp, Sym interfaces and HirRoot class.

 Preliminaries
   High level intermediate representation is composed of operation
   information in a tree form, symbol information, data flow
   information, and others.
   The operation information tree is composed of nodes and edges.
   A node with children is called as nonleaf node and a node without
   child is called a leaf node.
   The term "node" means either leaf node or nonleaf node,
   the term "subtree" means either pure subtree composed of
   several nonleafs and leafs, or one leaf.

 Class/interface hierarchy:
   (Root is a class, others are interfaces.
    An interface xxx is implemented by corresponding class
    named xxxImpl or xxx_Impl.)

 Root
 |
 |- Sym
 |   |- ...
 |
 |- Flow
 |   |- ...
 |
 |- IR
     |- IR_factory    // IR object creation factory.
     |- IrList        // List of indefinite number of objects.
     |   |- HirList   // IrList whose elements are HIR objects.
     |
     |- LIR           // Low level Intermediate Representation
     |   |- ...
     |
     |- HIR0 // Simple HIR interface.
        |
        HIR // High level Intermediate Representation.
         |  // Usual operations on HIR are done by using HIR methods.
         |
         |- Program         // Program definition node.
         |- SubpDefinition  // Subprogram definition node.
         |- HirSeq          // Sequence of definite number of
         |                  // HIR objects.
         |- HirList         // IrList whose elements are HIR objects.
         |                  // (Note that elements of IrList may be Sym
         |                  //  and String but elements of HirList should
         |                  //  be HIR objects.)
         |                  // (Multi-inheritance of interface)
         |- Stmt            // Statement
         |   |- LabeledStmt // Labeled statement.
         |   |- AssignStmt  // Assignment statement.
         |   |- IfStmt      // If-statement.
         |   |- JumpStmt    // Jump (goto) statement.
         |   |              //  (Jump unconditionally)
         |   |- LoopStmt    // Loop statement.
         |   |   |- ForLoop     // For-loop.
         |   |   |- WhileLoop   // While-loop.
         |   |   |- RepeatLoop  // Repeat-while-true loop.
         |   |   |- IndexedLoop // Loop with index range
         |   |                  // (such as Fortran DO loop).
         |   |- ReturnStmt   // Return statement.
         |   |- SwitchStmt   // Switch (case) statement.
         |   |- BlockStmt    // Block representing a sequence
         |   |               //   of statements.
         |   |- ExpStmt      // Expression treated as a statement.
         |   |               // Call statement is treated as an
         |   |               // expression statement of function call.
         |   |               // Loop start condition expression has
         |   |               // label and treated as ExpStmt.
         |   |- InfStmt      // An information node
         |   |               // which can be treated as a statement.
         |   |               //  (pragma, comment line, etc.)
         |   |- AsmStmt      // Asm statement representing sequence of
         |                   // assembly language instructions.  //##70
         |- LabelDef         // Label definition node.
 //      |- InfNode          // IR information node.         DELETED
 //      |                   //  (pragma, comment line, etc.)
         |- Exp  // Expression
             |- ConstNode // Constant node
             |- SymNode   // Symbol node
             |   |- VarNode   // Variable name node.
 //          |   |   |- ParamNode // formal parameter name node
 //          |   |   |             DELETED
             |   |   |- ElemNode  // struct/union element name node
             |   |                 not DELETED
             |   |- SubpNode  // Subprogram name node.
             |   |- LabelNode // Label reference node.
             |   |- TypeNode  // Type name node.
             |
             |- SubscriptedExp // Subscripted variable.
             |- PointedExp     // Pointed object.
             |- QualifiedExp   // Qualified variable.
             |- FunctionExp    // Function call expression.
             |- PhiExp     // Phi function used in SSA
             |- ExpListExp // Expression representing a list of expressions
             |- NullNode   // Null (no-operation) node

  Deleted classes:
    ParamNode,
    StmtBody, AssignExp,
    Nonleaf, Leaf, HIRdetail, BBlock, PBlock, ExitStmt,
    ContinueStmt. (##10)

 Abstract syntax of HIR:

  Abstract syntax of HIR is shown as BNF syntax
  in the form ( operationCode attr child1 child2 ... ),
  where, child1 represents source operand 1, child2 represents
  source operand 2,  ... .  Instance of HIR may be regarded
  as a tree attached with operands as its subtree.
  The result operand is represented by the root node
  of the tree. The attr represents attributes
  such as type of the tree, etc.
  (Each node may be attached an expression identifier (expId)
  as an attribute. In such case, the expId attached to
  the root node of a subtree may be regarded as the identifier
  corresponding to the result value of the operation
  specified by the subtree.)
  Each child is also a subtree of the same form.
  Some child may be null.
  The operationCode and attr are not subtree but
  information attached to the root node of the subtree.
  (This notation is not explaining parse tree of HIR but
  explaining abstract syntax tree of HIR.)

  Notations in the following BNF descriptions..
    identifier starting with lower case letter except attr: terminal
    identifier starting with upper case letter:  nonterminal
      identifier ending with "_":
             nonterminal that is not an interface
      identifier that does not end with "_":
             nonterminal representing an interface
    xxxCode: operation code xxx
    xxxSym : symbol recorded in the symbol table
            progSym : program name symbol
            subpSym : subprogram name symbol
            varSym  : variable name symbol
                      (including array/struct/union name symbol)
            paramSym: formal parameter name symbol
            elemSym : struct/union element name symbol
            labelSym: label name symbol
            typeSym : type name symbol
    xxxConst: constant recorded in the symbol table
            intConst   : integer constant
                         (int/short/long/unsigned int/ ...)
            floatConst : floating constant (float/double/ ...)
            charConst  : character constant (signed/unsigned)
            stringConst: character string constant
            boolConst  : boolean constant
                      (true is 1, false is 0 if converted to  integer)
    intConstValue:    integer constant
                      (not a symbol table entry but value itself).
    stringConstValue: string  constant
                      (not a symbol table entry but value itself).
    null       : empty (nothing, epsilon)
    NullNode   : a leaf node with operation code null.
    List_of_xxx: java.util.List with elements xxxx. (##10)
    Parenthesis is not a syntactic component but a delimiter.
      One subtree begins with left parenthesis and end with
      right parenthesis.

  Note:
    Following items are not represented as a subtree
    dangling to a node but are represented as information
    attached to the node. They are not traversed when HIR tree
    is traversed but can be get by applying corresponding HIR
    methods to the node.
        Operation code     (xxxCode)
        Symbol table entry (xxxSym)
        Constant symbol    (xxxConst)
        Symbol table       (SymTable, GlobalSymTable_, LocalSymTable_)
        attr               (attribute such as node type which is
                            a symbol representing the type
                            of the result of HIR subtree.)
    Items represented as a subtree is indicated by @ to clarify.
    (@ is not a syntactic component but a postfix marker
     to avoid misunderstanding.)

  Program   ->             // Program represents a compile unit.
     ( progCode attr       //
       GlobalSymTable_     // Global symbols of the program
       ProgSym_ @          // Program name (may be null).
       InitiationPart_ @   // Initial value specification.
       SubpList_ @ )       // Subprogram definition list.
  ProgSym_  ->
     ( symCode attr progSym )   // Program name symbol.
   | null
  GlobalSymTable_  ->   // Global symbol table of the program.
     SymTable           // As for SymTable, see Sym and SymTable.
   | null
  InitiationPart_ ->    // Initial value specification (##14)
     InitiationBlock_
   | NullNode
  InitiationBlock_ ->   // Block containing initiation statements.
     ( blockCode attr
       InitiationStmtSeq_ @ )
  InitiationStmtSeq_ -> // Sequence of initiation statements
     InitiationStmt_ @ InitiationStmtSeq_ @
   | null
  InitiationStmt_ ->    // Initiation statement
     ( setDataCode attr         // with Exp_l_: l-value
        Exp_l_ @ ValueSpec_ @ ) // ValueSpec_: constant Exp.
   | InfStmt                    //##74
   | AssignStmt
  ValueSpec_ ->
      ConstExp_         // Constant expression
   | ( explistCode attr // ExpListExp of ValueSpec_
       List_of_ValueSpec_ @ )
   | ( exprepeatCode attr        // Expression to represent repeating
       ValueSpec_ @ intConst @ ) //   ValueSpec_ intConst-times.
  ConstExp_ ->           BEGIN
     ConstNode          // Constant value
   | Exp                // Exp whose operands are all ConstNode
  SubpList_ ->
     ( listCode attr     // Subprogram definition list
       List_of_SubpDefinition @ )
  SubpDefinition ->      // Subprogram definition
     ( subpDefCode attr
       LocalSymTable_    // SymTable local in the subprogram.
       SubpNode @        // Subprogram name.
       InitiationPart_ @ // Subprogram initiation.
       SubpBody_ @ )     // HIR subprogram body
                         // (Control flow should be ended by return).
  //   LIR @ )      // LIR representation for the subprogram.  deleted
  SubpNode  ->      // Subprogram name node.
     ( symCode attr
       subpSym )
  LocalSymTable_ -> // Local symbol table (for subprogram, block, etc.)
     SymTable
   | null
  SubpBody_ ->      // HIR subprogram body is
     BlockStmt                 // block statement or
   | ( labeledStmtCode attr    // BlockStmt with Label.
        LabelDefinitionList_ @ // List of label definitions.
        BlockStmt @ )          // Statement body
     // BlockStmt of SubpBody should have LocalSymTable. //##70
  *  BlockStmt ->
     ( blockCode attr
       LocalSymTable_  // Define symbols local in the block.
       StmtSeq_ @ )    // Block makes a sequence of statements
                       // to be treated as one statement.
            // Statements in StmtSeq_ can be get
            // by getFirstStmt() and successive getNextStmt().
  StmtSeq_  ->
     Stmt @ StmtSeq_ @  // Statement sequence is a statement
   | null               // followed by statements or empty.
  Stmt      ->          // Statement is
     LabeledStmt        // a statement with label definitions or
   | StmtBody_          // a statement without label definition.
  LabeledStmt ->        // Statement with label definition.
     ( labeledStmtCode attr
        LabelDefinitionList_ @ // List of label definitions.
        StmtBody_ @ )          // Statement body (statement that is
                               // peeled label off).
  LabelDefinitionList_ ->   // List of LabelDef nodes.
     ( listCode attr
       List_of_LabelDef @ )
  LabelDef   ->             // Label definition node.
     ( labelDefCode attr
       labelSym )
  StmtBody_  ->     // Statement body.
     AssignStmt     // Assignment statement.
   | IfStmt         // If statement.
   | JumpStmt       // Jump (goto) statement.
   | LoopStmt       // Loop statement.
   | CallStmt_      // Subprogram call statement.
   | ReturnStmt     // Return statement.
   | SwitchStmt     // Switch (case selection) statement.
   | BlockStmt      // Block statement.
   | ExpStmt        // Expression treated as a statement.
   | InfStmt        // Inf (information) statement        //##70
                    // #Pragma is represented as a kind of
                    // InfStmt.
   | AsmStmt        // Asm (assemblyu language) statement //##70
   | SetDataStmt    // Set initial data statement.

  AssignStmt ->     // Assign statement.
     ( assignCode attr
       Exp_l_ @     // l_value expression.
       Exp @ )      // Expression whose value is to be assigned.
                    // Exp_l_ and Exp should have the same type.
                    // Exp may be any scalar expression
                    // or struct/union expression.
                    // (Array expression will be permitted in future.)
   | ( CompoundAssignOperator_ attr  // HIR-C only
       Exp_l_ @
       Exp @ )
   | ( IncrDecrOperator_ attr        // HIR-C only
       Exp_l_ @ )
  Exp_l_  ->              // l-value expression is
     Exp                  // an expression representing an object
                          // (memory area to contain data).
  IfStmt    ->            // If statement
    ( ifCode attr
       ConditionalExp_ @  // Conditional expression.
       ThenPart_ @        // Then-part
       ElsePart_ @        // Else-part.
       LabeledStmt0_ @ )  // Statement with end-of-if label.
  ThenPart  ->
     LabeledStmt   // Executed if ConditionalExp is true.
   | null          //
  ElsePart  ->
     LabeledStmt   // Executed if ConditionalExp is false.
   | null          //
  LabeledStmt0_    ->         // LabeledStmt0_ is a labeled
     ( labeledStmtCode attr   // statement whose statement body
       LabelDefinitionList_ @ // may be null at first but it may become
       NullOrStmt_ @ )        // non-null by code optimization, etc.
                              // LabeledStmt0_ may be called labeled null.
  JumpStmt  ->
     ( jumpCode attr  // Jump to the statement with
       LabelNode @ )  // specified label.
  LoopStmt ->  // Loop statement is either for-loop, while-loop,
               // repeat-loop, indexed-loop, or other general loop.
               // All of them are implemented as a general loop
               // with some restriction depending on the loop type.
               // Compiler components (other than front part) should
               // treat general loop, that is, do not assume some child
               // is null without checking whether the child is null
               // or not. For example, a while-loop may be changed
               // to a loop with LoopInitPart_ and LoopStepPart_
               // by code optimizer. isSimpleForLoop(), isSimpleWhileLoop(),
               // isSimpleRepeatLoop() of LoopStmt interface check
               // whether the loop can be treated pure for-loop,
               // pure while-loop, etc.
               // There may be some cases where processing become
               // simple if the loop is either simple for-loop,
               // while-loop, repeat-loop, etc.
    ( LoopCode_ attr     // Loop kind code.
      LoopInitPart_ @    // Loop initiation part to be executed
                         // before repetition. It may be null.
                         // LoopInitPart_ should not contain
                         // control statements except for the one
                         // generated by addToConditionalInitPart
                         // of LoopStmt interface.
                         // As for expressions to be executed
                         // only once (loop invariant expressions, etc.),
                         // see addToConditionalInitPart of LoopStmt.
      StartConditionPart_ @  // Loop start conditional expression
                         // with loopBackLabel.
                         // If true, pass through to LoopBody_,
                         // otherwise transfer to LoopEndPart_
                         // to terminate the loop execution.
                         // If loop start condition part is null,
                         //  pass through to LoopBody_.
      LoopBody_ @        // Loop body repetitively executed.
                         // Pass through to EndCondition_.
                         // It is a block statement (BlockStmt)
                         // with loop start label and the blcok
                         // statement contains a labeled statement
                         // with loopStepLabel as its last statement.
                         // This should not be null but the block may
                         // have no executable statement and contains
                         // only a labeled statement with loopStepLabel.
                         // "continue" jumps to the loopStepLabel.
                         // The loopStepLabel may be omitted if
                         // there is no "jump loopStepLabel".
     EndCondition_ @     // Loop end condition expression.
                         // If false, transfer to LoopEndPart_
                         // to terminate the loop execution,
                         // otherwise pass through to
                         // LoopStepPart_.
     LoopStepPart_ @     // Loop step part that is to be executed
                         // before jumping to loopBackLabel.
                         // LoopStepPart_ should not contain
                         // control statements.
     LoopEndPart_ @ )    // Loop end part
                         // with loopEndLabel.
                         // "exit" (break in C) jumps to here.
     IndexedLoop_ attr   // Attributes for IndexedLoop.
                         // Not given for other loops.
  LoopCode_ attr ->
     whileCode attr      // while-loop
   | forCode attr        // for-loop
   | repeatCode attr     // repeat-while-true--loop
   | indexedLoopCode attr// indexed-loop
   | loopCode attr       // general loop other than above loops.
  LoopInitPart_   ->     // Loop initiation part.
     Stmt
   | null
  ConditionalInitPart_ ->  // This item is deleted. Give null for this item
     null                  // but use addToConditionalInitPart method
                           // of LoopStmt to move loop invariant expressions
                           // etc. from loop body so that they are executed
                           // only once.
  StartConditionPart_ ->      // Show start condition with
     ( labeledStmtCode attr   // loopBacklabel.
       LabelDefinitionList_ @
       BooleanExpStmtOrNull_ @ ) // loopStartConditionExpression.
  LoopBody_  ->               // Block statement with loopBodyLabel.
     ( labeledStmtCode attr   // The last statement of the block
       LabelDefinitionList_ @ // is a LabeledStmt0_ statement with
       BlockStmt_ @ )         // loopStepLabel.
  EndCondition_ ->            // ExpStmt showing loop end condition.
     BooleanExpStmtOrNull_
  LoopStepPart_  ->    // Statement to be executed before jumping
     Stmt              // to loopBackLabel.
   | null              // LoopStepPart_ should not contain
                       // statements that change control flow.
  LoopEndPart_  ->     // LabeledStmt0_ statement with loopEndLabel.
     LabeledStmt0_
  NullOrStmt_ ->       // Usually null but it may be
     null              // a statement (created during
   | Stmt              // HIR transformation).
  BooleanExpStmtOrNull_ ->    // Boolean expression statement or null.
     ExpStmt           // ExpStmt whose Exp part is a boolean expression.
   | null
  IndexedLoop_ attr  -> // Attributes for IndexedLoop.
     loopIndex attr     // Loop index (induction variable).
                        // See getLoopIndex().
     startValue attr    // Start value of the loop index.
                        // See getStartValue().
     endValue attr      // End value of the loop index.
                        // See getEndValue().
     stepValue attr     // Step value for the loop index.
                        // See getStepValue().

  // Note. LoopInf may contain goto-loop that is difficult or
  //   impossible to be represent by above LoopStmt.
  //   (goto-loop is not implemented by LoopStmt.)

  // LoopStmt is executed as follows:
  //   LoopInitPart_;
  //   if (loopStartConditionExpression == null) {
  //     Sequence of statements added by addToConditionalInitPart();
  //   }else {
  //     if (loopStartConditionExpression == false) {
  //       jump to loopEndLabel;
  //     }else { // ConditionalInitBlock
  //       Sequence of statements added by addToConditionalInitPart().
  //       jump to loopBodyLabel;
  //     }
  //   }
  //   loopBackLabel:
  //     if ((loopStartConditionExpression != null)&&
  //         (loopStartConditionExpression == false))
  //       jump to loopEndLabel;
  //   loopBodyLabel:
  //     Start of BlockStmt of LoopBody_
  //       Stastement sequence of the BlockStmt;
  //       (break statement jumps to loopEndLabel;)
  //       (continue statement jumps to loopStepLabel;)
  //       Rest of stastement sequence of the LoopBody_;
  //       loopStepLabel:;
  //     End of BlockStmt of LoopBody_
  //     if ((loopEndConditionExpression != null)&&
  //         (loopEndConditionExpression == false))
  //       jump to loopEndLabel;
  //     LoopStepPart;
  //     jump to loopBackLabel;
  //   loopEndLabel:
  //     Loop end part;

  // BEGIN #21
  // ForStmt is created as a general loop where contents of
  //   ConditionalInitPart_, EndCondition_, LoopEndPart_
  //   are labeled null at first (but their statement body may
  //   become not null by some optimizing transformation).
  //   See isSimpleForLoop().
  // WhileStmt is created as a general loop where contents of
  //   LoopInitPart_, ConditionalInitPart_, EndCondition_,
  //   LoopStepPart_, LoopEndPart_
  //   are labeled null at first (but their statement body may
  //   become not null by some optimizing transformation).
  //   See isSimpleWhileLoop().
  // RepeatStmt is created as a general loop where contents of
  //   LoopInitPart, ConditionalInitPart_, StartCondition_,
  //   LoopStepPart_, LoopEndPart_
  //   are labeled null at first (but their statement body may
  //   become not null by some optimizing transformation).
  //   See isSimpleUntilLoop().
  // IndexedLoopStmt is created as a general loop where contents of
  //   ConditionalInitPart_, EndCondition_, LoopEndPart_
  //   are labeled null at first (but their statement body may
  //   become not null by some optimizing transformation).
  //   See isSimpleIndexedLoop().
  // IndexedLoopStmt represents a Fortran type loop where
  //   value of loop index is incremented or decremented by loop
  //   step value starting from loop start value and stops
  //   to loop before crossing the barrier of loop end value.
  //   (See IndexedLoopStmt interface.)
  // Indexed loop attributes (IndexedLoopAttr_) are available
  // only for IndexedLoopStmt.
  // END #21

  CallStmt_   ->         // Subprogram call statement.
     ( expStmtCode attr  // Expression statement
       FunctionExp @ )   // with FunctionExp.
  FunctionExp ->         // Subprogram call expression.
     ( callCode attr
       Exp @             // Expression specifying subprogram
                         // to be called. It may be
                         // SubpNode or (addr SubpNode), etc.
       HirList @ )       // Actual parameter list.
  ReturnStmt ->          // Return statement.
     ( returnCode attr
       ReturnValue_ @ )  // Return value.
  ReturnValue_ ->
     Exp
   | null
  SwitchStmt ->          // Switch statement.
     ( switchCode attr
       Exp @             // Case selection expression.
       JumpTable_ @      // List of constants and statement labels.
       Stmt @            // Collection of statements to be selected.
       LabeledStmt0_ @ )  // Indicate end of case statement.
  JumpTable_ ->          // Jump table.
     ( seqCode attr
       JumpList_ @       // List of constant-label pairs.
       LabelNode @ )     // Default label.
  JumpList_ ->                 // Jump list.
     ( listCode attr           // Correlate Exp value
       List_of_SwitchCase @ )  // and list of SwitchCase_ pairs.
  SwitchCase_ ->       // List of SwitchCase_ pairs.
     ( seqCode attr
       ConstNode @     // Correlate Exp value and
       LabelNode @ )   // switch statement label.
  ExpStmt   ->         // Expression statement.
     ( expStmtCode attr
       Exp @ )         // Expression treated as a Stmt.
  NullNode  ->
     ( nullCode attr ) // NullNode is a terminal
                       // that is not null.
  InfStmt   ->
     ( infCode attr    // Information statement.
       InfKind_        // Information kind identifier.
       InfObject_  )   // Information.
                       // (InfKind_ and InfObject_ are not
                       // traversed by HIR traverse operations.)
  InfKind_  ->
     StringConstNode_ // String constant node showing the kind of
                      // information such as pragma, comment, etc. //##70
  InfObject_  ->      // Information.
     Object           // Object such as Sym, Exp, etc. or
                      // a list of Objects. It may or may not be HIR.
  StringConstNode_  ->            //##70
    (constCode attr stringConst ) // String constant node.  //##70
  Pragma_   ->   // Pragma is a direction to the compiler.
     ( infCode attr    // Pragma is represented as
                       // an information statement.
       InfKind_        // Pragma information kind identifier.
       InfObject_  )   // Pragma information.
  AsmStmt   ->
    ( asmCode attr  // Asm statement.
      StringConst @ // String constant representing
                    // parameter description pragma,
                    // clobber specification pragma, and
                    // assembly language instruction sequence
      HirList @ )   // List of l-value expressions (variable nodes,
                    // pointer expressions, etc.) and arithmetic
                    // expressions representing actual parameters.
     // As for detail, see AsmStmt interface.
  ConditionalExp_ ->     // boolean expression
     Exp
  Exp ->                 // Expression.
     Factor_
   | UnaryExp_
   | BinaryExp_
   | ExpListExp
   | TernaryExp_
   | NullNode
 | InfNode
  Factor_  ->
     ConstNode
   | SymNode
   | CompoundVar_
   | FunctionExp
   | PhiExp
 //| AssignStmt          // HIR-C
   | ExpListExp
   | HirSeq              // Sequence of objects
  UnaryExp_ ->           // Unary expression.
     ( UnaryOperator_ attr
       Exp @ )
   | ( sizeofCode attr  // size of the type of Exp
        Exp @ )
   | ( sizeofCode attr  // size of the type
       TypeNode @ )     // represented by TypeNode.
  BinaryExp_ ->         // Binary expression.
     ( BinaryOperator_ attr
       Exp @
       Exp @ )
  TernaryExp_ ->        // Ternary expression.
       SelectExp          // HIR-C only
  CompoundVar_ ->    // Compound variable.
     SubscriptedExp  // Subscripted variable.
   | PointedExp      // Pointed variable.
   | QualifiedExp    // Qualified variable.
  SubscriptedExp ->  Subscripted variable.
     ( subsCode attr // Array with subscript expression.
       Exp @       // Expression indicating the array.
       Exp @ )     // Subscript expression.
//  | ( subsCode attr
//      Exp @       // Expression indicating an array.
//      ExpList @ ) // List of Subscripts.
//                  // (1st subscript, 2nd subscript,
//                  //  etc. for rectangular array.)
  ElemSize_    ->    // Element size.
     Exp
  QualifiedExp ->    // Qualified expression.
     ( qualCode attr // Qualified variable
       Exp @         // Should represent a structure or union.
       ElemNode @ )  // struct/union element.
  PointedExp ->       // Pointed expression.
     ( arrowCode attr // Pointed variable
       Exp @          // Expression representing a variable
       PointedElem_ @ ) // Pointed element.
  PointedElem_ ->
     ElemNode  // Pointed element (with displacement).
   | null      // Pointed location (0 displacement).
  ConstNode ->                      // Constant symbol.
     ( constCode attr intConst )    // integer   constant node
   | ( constCode attr floatConst )  // float     constant node
   | ( constCode attr charConst )   // character constant node
   | ( constCode attr stringConst ) // string    constant node
   | ( constCode attr boolConst )   // boolean   constant node
  SymNode   ->        // Symbol node.
     (symCode Sym )   // Program name, etc.
   | VarNode
 //| ParamNode   DELETED
   | SubpNode
   | LabelNode
   | ElemNode   not DELETED
   | TypeNode
  VarNode   ->
     ( symCode attr varSym )   // Variable name node
  SubpNode  ->
     ( symCode attr subpSym )  // Subprogram name node
  LabelNode ->
     ( symCode attr labelSym ) // Label reference node
  ElemNode  ->
     ( symCode attr elemSym )  // structure/union element
                                    // name node.
  TypeNode  ->
     ( symCode attr typeSym )  // Type name node
  FunctionExp ->     // Function expression.
     ( callCode attr
       Exp @         // Expression specifying function
                     // to be called (SubpNode, (addr SubpNode), etc.).
       HirList @ )   // Actual parameter list.
                     // It is an HirList whose elements are Exp.
  IrList     ->
     ( listCode attr    // A List that can be treated as IR.
       List_of_Objects_ @ ) // Its elements may be Sym, String and IR object.
  HirList        ->
     ( listCode attr    // A List of HIR elements. It can be treated as HIR.
       List_of_HIR_Objects_ @ ) // Its elements should be HIR object.
  ExpListExp  ->        // Expression representing
     ( expListCode attr // a list of
       List_of_Exp @ )  // expressions in HIR form.
  HirSeq  ->
     ( seqCode attr HIR @ )  // Sequence of some definite
   | ( seqCode HIR @  HIR @ ) // number of HIR nodes.
   | ( seqCode HIR @  HIR @  HIR @ )
   | ( seqCode HIR @  HIR @  HIR @  HIR @ )
  PhiExp         ->
     (phiCode attr FlowVarList_ @ )  // phi function
  FlowVarList_   ->
     ( listCode attr
       List_of_VarLabelPair @ )
                               // List of (Var Label) pairs.
  VarLabelPair   ->
     ( listCode attr VarNode @  Label @)
  UnaryOperator_ ->
     notCode      // bitwise not (~) one's complement
                  // logical not (boolean not) (!)
   | negCode      // negate (unary minus)
   | addrCode     // get address (&)
   | contentsCode // get contents of pointed memory
   | convCode     // type conversion for basic type
   | decayCode    // convert array to pointer
   | sizeofCode   // sizeof operator
   | encloseCode  // honor parenthesis
   | IncrDecrOperator_  // Increment/decrement. HIR-C only.
  BinaryOperator_ ->
   | addCode      // add                 (+)
   | subCode      // subtract            (-)
   | offsetCode   // Offset between pointers (HIR-C only)
   | multCode     // multiply            (*)
   | divCode      // divide              (/)
   | modCode      // modulo              (%)
   | andCode      // bitwise and, logical and for bool (&)
   | orCode       // bitwise or,  logical or for bool  (|)
   | xorCode      // bitwise exclusive or, logical exclusive or (^)
   | shiftLLCode  // shift left  logical    (<<) //
   | shiftRCode   // shift right arithmetic (>>)
   | shiftRLCode  // shift right logical    (>>) //
   | undecayCode  // convert pointer to array
   | expRepeatCode   // Repeat constant values (operand 1)
                     //   count (operand 2) times.
   | CompareOperator_
   | CompareZeroOperator_            // HIR-C only
   | ShortCircuitOperator_           // HIR-C only
   | commaCode    // comma operator  // HIR-C only
  CompareOperator_ ->
     cmpEqCode    // equal
   | cmpNeCode    // not equal
   | cmpGtCode    // greater than
   | cmpGeCode    // greater or equal
   | cmpLtCode    // less than
   | cmpLeCode    // less or equal
  CompareZeroOperator_ ->                // HIR-C only
     eqZeroCode   // equal zero          // HIR-C only
  ShortCircuitOperator_ ->               // HIR-C only
     lgAndCode    // logical and (&&)    // HIR-C only
   | lgOrCode     // logical or  (||)    // HIR-C only
  IncrDeclOperator_ ->                             // HIR-C only
     preIncrCode  // pre-increment  (++) // HIR-C only
   | preDecrCode  // pre-decrement  (--) // HIR-C only
   | postIncrCode // post-increment (++) // HIR-C only
   | postDecrCode // post-decrement (--) // HIR-C only
  CompoundAssignmentOperator_ ->         // HIR-C only
     multAssignCode   // *=    // HIR-C only
   | divAssignCode    // /=    // HIR-C only
   | modAssignCode    // %=    // HIR-C only
   | addAssignCode    // +=    // HIR-C only
   | subAssignCode    // -=    // HIR-C only
   | shiftLAssignCode // <<=   // HIR-C only
   | shiftRAssignCode // >>=   // HIR-C only
   | andAssignCode    // &=    // HIR-C only
   | xorAssignCode    // ^=    // HIR-C only
   | orAssignCode     // |=    // HIR-C only
  SelectExp ->        //  (Exp ? Exp : Exp) // HIR-C only
     ( selectCode attr
       ConditionalExp @   Exp @  Exp @ )

  attr ->             // Attribute attached to the HIR node
     typeSym          // Shows the type of HIR subtree.
     OptionalAttrSeq_ // Sequence of optional attributes
                      // that are not inevitable at the first stage
                      // of HIR generation. The optional attributes
                      // may be attached to give information used
                      // in some specific compiler modules or
                      // to help compiling processes.
  OptionalAttrSeq_ ->
     OptionalAttr_ OptionalAttrSeq_
   | null
  OptionalAttr_ ->
     StmtAttr_      // Attributes for statements
   | IndexNumber_   // Index number to identify the HIR node.
   | Flag_          // true/false flag.
   | InfItem_       // Node-wise information.
   | ExpId          // Expression identifier used in flow analysis.
   | Work_          // Phase-wise information.
  StmtAttr_ ->      // Attributes attached to statement subtrees.
     FileName_      // Source program file containing the statement.
     LineNumber_    // Line number of the line in which the
                    // statement started.
  FileName_ ->
     stringConstValue
  LineNumber_
     intConstvalue
  IndexNumber_ ->
     intConstValue
  Flag_ ->
     FlagNumber_
     FlagValue_
  FlagNumber_ ->
     intConstValue   // Such as  FLAG_NOCHANGE, FLAG_C_PTR,
                     // FLAG_CONST_EXP
  FlagValue_ ->
     true
   | false
  InfItem_ ->
     InfKind_ InfObject_


  Deleted methods:
    buildXxx, getSym (use getSym in IR or getSymNodeSym in SymNode)
    insertBBlockCode, insertGBlockCode, insertPBlockCode.
  Deleted operators:
    addUCode, subUCode, multUCode, divUCode.
    (Decide by Type attached to each node.)
    addA, subA, multA, divA, modA, shiftL.   (##9)
    lgNot  (##10)

 Construction of HIR objects:
  Most HIR objects are constructed by object factory methods
  such as program(....), subpDefinition(....), assignStmt(....),
  ifStmt(....), exp(....), etc. specified in the HIR interface.
  Users are recommended to use the object factory methods so as
  to avoid forgetting to specify essential data and to make
  relation with other objects.  It is not recommended to use
  "new" directly to construct HIR objects.

 Transformation of HIR:
  HIR are transformed in various phases of the compiler
  for optimization, parallelization, etc.
  Such transformation can be executed by invoking transformation
  methods such as replaceThisNode, addNextStmt, etc.
  Transformed result should always be tree. Care should be taken
  not to share leafs and branches between subtrees.
  The simple way of keeping tree structure in transformation is
  to make a new subtree copying some part of original tree
  and replace some branch so that no node is linked from
  plural parent nodes.
  It is strongly recommended not to destroy the control structure
  of HIR. For exmple, jump into a loop from outside, jump out of
  loop from loop step part, jump into if statement from outside,
  etc. although such transformations are not automatically prohibited.

  HIR nodes should be numbered by applying setIndexNumberToAllNodes
  to Program tree or SubpDefinition subtree when HIR is created or
  modified. When HIR is created by a parser or entirely transformed
  by an optimizer, setIndexNumberToAllNodes(1) should be applied to
  hirRoot.programRoot. If subprogram-wise transformation is done
  (e.g., repeat to do subprogram-wise optimization and code generation),
  then apply setIndexNumberToAllNodes(subpDefinition.getNodeIndexMin())
  to SubpDefinition node "subpDefinition" of each subprogram.

 Operator number
public static final int
  OP_PROG          =  1,   // program( .... )
  OP_SUBP_DEF      =  2,   // subpDefinition( .... )
  OP_LABEL_DEF     =  3,   // labelDef( .... )
  OP_INF           =  4,   // infNode( .... )
  OP_CONST         =  5,   // constNode( .... )
  OP_SYM           =  6,   // symNode( .... )
  OP_VAR           =  7,   // varNode( .... )
  OP_PARAM         =  8,   //                UNNECESSARY ?
  OP_SUBP          =  9,   // subpNode( .... )
  OP_TYPE          = 10,   //                UNNECESSARY ?
  OP_LABEL         = 11,   // labelNode( .... )
  OP_ELEM          = 12,   // elemNode( .... )
  OP_LIST          = 14,   // irList( .... )  List of HIR/Sym objects
                           // such as HIR nodes and symbols
  OP_SEQ           = 15,   // hirSeq( .... )
  OP_ENCLOSE       = 16,   // exp( int, Exp ) Enclose subexpression

  OP_SUBS          = 17,   // subscriptedExp( .... )
  OP_QUAL          = 19,   // qualifiedExp( .... )
  OP_ARROW         = 20,   // pointedExp( .... )

  OP_STMT          = 21,   // Statement code lower. Stmt is
                           // an abstract class and there is
                           // no instance having OP_STMT.
  OP_LABELED_STMT  = 21,   // labeledStmt( .... )
                           // Use the same number as Stmt
                           // because Stmt is an abstract class.
  OP_ASSIGN        = 22,   // assignStmt( .... )
  OP_IF            = 23,   // ifStmt( .... )
  OP_WHILE         = 24,   // whileStmt( .... )
  OP_FOR           = 25,   // forStmt( .... )
  OP_REPEAT        = 26,   // repeatStmt( .... )
  OP_INDEXED_LOOP  = 27,   // indexedLoopStmt( .... )

  OP_JUMP          = 28,   // jumpStmt( .... )
  OP_SWITCH        = 32,   // switchStmt( .... )
  OP_CALL          = 33,   // callStmt( .... )
  OP_RETURN        = 34,   // returnStmt( .... )
  OP_BLOCK         = 35,   // blockStmt( .... )
  OP_EXP_STMT      = 36,   // expStmt( .... ) expression statement
  OP_ASM           = 37,   // asmStmt( .... )
  OP_STMT_UPPER    = 37,

// OP_ADD ... OP_XOR OP_CMP_EQ ... OP_CMP_LE OP_SHIFT_LL ... OP_SHIFT_LL
//         are binary operators used in exp(int, Exp, Exp).
  OP_ADD           = 38,
  OP_SUB           = 39,
  OP_MULT          = 41,
  OP_DIV           = 42,
  OP_MOD           = 43,

  OP_AND           = 46,
  OP_OR            = 47,
  OP_XOR           = 48,

  OP_CMP_EQ        = 51,
  OP_CMP_NE        = 52,
  OP_CMP_GT        = 53,
  OP_CMP_GE        = 54,
  OP_CMP_LT        = 55,
  OP_CMP_LE        = 56,

  OP_SHIFT_LL      = 58,
  OP_SHIFT_R       = 59,
  OP_SHIFT_RL      = 60,
//  OP_LG_NOT       = 61, // Use (OP_CMP_EQ e false) instead of (OP_LG_NOT e)
  OP_NOT           = 62,   // exp(OP_NOT, Exp)
  OP_NEG           = 63,   // exp(OP_NEG, Exp)
  OP_ADDR          = 64,   // exp(OP_ADDR, EXP )
  OP_CONV          = 65,   // convExp( .... )
  OP_DECAY         = 66,   // decayExp( .... )
  OP_UNDECAY       = 67,   // undecayExp( .... )
// OP_CONTENTS, OP_SSIZEOF are unary operator used in exp(int, Exp).
  OP_CONTENTS      = 68,   // contentsExp( .... )
  OP_SIZEOF        = 70,   // sizeofExp( .... )
//  OP_NOCHANGE_EXP = 71,   // See FLAG_NOCHANGE
  OP_SETDATA       = 71,
  OP_PHI           = 72,  // phiExp( .... )
  OP_NULL          = 73,  // nullNode();

// OP_OFFSET ... OP_LG_OR are binary operators used in exp(int, Exp, Exp).
  OP_OFFSET        = 76,  // exp( int, Exp, Exp ) // HIR-C only
  OP_LG_AND        = 77, // HIR-C only
  OP_LG_OR         = 78, // HIR-C only
  OP_SELECT        = 79, // HIR-C only
  OP_COMMA         = 80, // HIR-C only

  OP_EQ_ZERO       = 81, // ! // HIR-C only
  OP_PRE_INCR      = 82, // HIR-C only
  OP_PRE_DECR      = 83, // HIR-C only
  OP_POST_INCR     = 84, // HIR-C only
  OP_POST_DECR     = 85, // HIR-C only
  OP_ADD_ASSIGN    = 86, // HIR-C only
  OP_SUB_ASSIGN    = 87, // HIR-C only
  OP_MULT_ASSIGN   = 88, // HIR-C only
  OP_DIV_ASSIGN    = 89, // HIR-C only
  OP_MOD_ASSIGN    = 90, // HIR-C only

  OP_SHIFT_L_ASSIGN= 91, // HIR-C only
  OP_SHIFT_R_ASSIGN= 92, // HIR-C only
  OP_AND_ASSIGN    = 93, // HIR-C only
  OP_OR_ASSIGN     = 94, // HIR-C only
  OP_XOR_ASSIGN    = 95, // HIR-C only

  OP_EXPLIST       = 96, // Expression representing a list of expressions.
  OP_EXPREPEAT     = 97  // Repetition of the same values.
                         // OP_EXPLIST and OP_EXPREPEAT are used only in
                         // OP_SETDATA expression.
  ;

 Flag numbers applied to HIR nodes:
 static final int     // Flag numbers used in setFlag/getFlag.
                   // They should be a number between 1 to 31.
FLAG_NOCHANGE = 1, // This subtree should not be
                   // changed in optimization.
FLAG_C_PTR    = 2, // The operation (add, sub) is
                   // pointer operation peculiar to C.
FLAG_CONST_EXP= 3; // This subtree is a constant expression.
                   // (constant, address constant, null,
                   //  sizeof fixed-size-variable,
                   //  expression whose operands are all constant
                   //  expression)
  // Flag numbers 24-31 can be used in each phase for apbitrary purpose.
  // They may be destroyed by other phases.

 Coding rules applied to all classes in the sym, hir packeges:

 Methods begin with lower case letter.
 Constants (final static int, etc.) are spelled in upper case letters.
 Indentation is 2 characters. Tab is not used for indentation.
 Formal parameters begin with p.
 Local variables begin with l.
 Methods and variables are named so that meaning is easily guessed.
 Short names less than 3 characters are not used except for
 very local purpose.

</PRE>
<P>

<P>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#OP_CODE_NAME">OP_CODE_NAME</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Operator number</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#OP_CODE_NAME_DENSE">OP_CODE_NAME_DENSE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_coins.ir.IR"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Fields inherited from interface coins.ir.<A HREF="../../../coins/ir/IR.html" title="interface in coins.ir">IR</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../coins/ir/IR.html#OP_INF">OP_INF</A>, <A HREF="../../../coins/ir/IR.html#OP_LIST">OP_LIST</A>, <A HREF="../../../coins/ir/IR.html#OP_PROG">OP_PROG</A>, <A HREF="../../../coins/ir/IR.html#OP_SUBP_DEF">OP_SUBP_DEF</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_coins.ir.hir.HIR0"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Fields inherited from interface coins.ir.hir.<A HREF="../../../coins/ir/hir/HIR0.html" title="interface in coins.ir.hir">HIR0</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../coins/ir/hir/HIR0.html#FLAG_C_PTR">FLAG_C_PTR</A>, <A HREF="../../../coins/ir/hir/HIR0.html#FLAG_CONST_EXP">FLAG_CONST_EXP</A>, <A HREF="../../../coins/ir/hir/HIR0.html#FLAG_INIT_BLOCK">FLAG_INIT_BLOCK</A>, <A HREF="../../../coins/ir/hir/HIR0.html#FLAG_LOOP_WITH_CONDITIONAL_INIT">FLAG_LOOP_WITH_CONDITIONAL_INIT</A>, <A HREF="../../../coins/ir/hir/HIR0.html#FLAG_NOCHANGE">FLAG_NOCHANGE</A>, <A HREF="../../../coins/ir/hir/HIR0.html#FLAG_NONTERMINAL">FLAG_NONTERMINAL</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_ADD">OP_ADD</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_ADD_ASSIGN">OP_ADD_ASSIGN</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_ADDR">OP_ADDR</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_AND">OP_AND</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_AND_ASSIGN">OP_AND_ASSIGN</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_ARROW">OP_ARROW</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_ASM">OP_ASM</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_ASSIGN">OP_ASSIGN</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_BLOCK">OP_BLOCK</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_CALL">OP_CALL</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_CMP_EQ">OP_CMP_EQ</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_CMP_GE">OP_CMP_GE</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_CMP_GT">OP_CMP_GT</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_CMP_LE">OP_CMP_LE</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_CMP_LT">OP_CMP_LT</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_CMP_NE">OP_CMP_NE</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_COMMA">OP_COMMA</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_CONST">OP_CONST</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_CONTENTS">OP_CONTENTS</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_CONV">OP_CONV</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_DECAY">OP_DECAY</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_DIV">OP_DIV</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_DIV_ASSIGN">OP_DIV_ASSIGN</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_ELEM">OP_ELEM</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_ENCLOSE">OP_ENCLOSE</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_EQ_ZERO">OP_EQ_ZERO</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_EXP_STMT">OP_EXP_STMT</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_EXPLIST">OP_EXPLIST</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_EXPREPEAT">OP_EXPREPEAT</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_FOR">OP_FOR</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_IF">OP_IF</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_INDEX">OP_INDEX</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_INDEXED_LOOP">OP_INDEXED_LOOP</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_JUMP">OP_JUMP</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_LABEL">OP_LABEL</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_LABEL_DEF">OP_LABEL_DEF</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_LABELED_STMT">OP_LABELED_STMT</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_LG_AND">OP_LG_AND</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_LG_OR">OP_LG_OR</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_MOD">OP_MOD</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_MOD_ASSIGN">OP_MOD_ASSIGN</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_MULT">OP_MULT</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_MULT_ASSIGN">OP_MULT_ASSIGN</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_NEG">OP_NEG</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_NOT">OP_NOT</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_NULL">OP_NULL</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_OFFSET">OP_OFFSET</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_OR">OP_OR</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_OR_ASSIGN">OP_OR_ASSIGN</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_PARAM">OP_PARAM</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_PHI">OP_PHI</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_POST_DECR">OP_POST_DECR</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_POST_INCR">OP_POST_INCR</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_PRE_DECR">OP_PRE_DECR</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_PRE_INCR">OP_PRE_INCR</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_QUAL">OP_QUAL</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_REPEAT">OP_REPEAT</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_RETURN">OP_RETURN</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_SELECT">OP_SELECT</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_SEQ">OP_SEQ</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_SETDATA">OP_SETDATA</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_SHIFT_L_ASSIGN">OP_SHIFT_L_ASSIGN</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_SHIFT_LL">OP_SHIFT_LL</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_SHIFT_R">OP_SHIFT_R</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_SHIFT_R_ASSIGN">OP_SHIFT_R_ASSIGN</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_SHIFT_RL">OP_SHIFT_RL</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_SIZEOF">OP_SIZEOF</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_STMT">OP_STMT</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_STMT_UPPER">OP_STMT_UPPER</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_SUB">OP_SUB</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_SUB_ASSIGN">OP_SUB_ASSIGN</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_SUBP">OP_SUBP</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_SUBS">OP_SUBS</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_SWITCH">OP_SWITCH</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_SYM">OP_SYM</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_TYPE">OP_TYPE</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_UNDECAY">OP_UNDECAY</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_UNTIL">OP_UNTIL</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_VAR">OP_VAR</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_WHILE">OP_WHILE</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_XOR">OP_XOR</A>, <A HREF="../../../coins/ir/hir/HIR0.html#OP_XOR_ASSIGN">OP_XOR_ASSIGN</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->


<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#addrExp(coins.ir.hir.Exp)">addrExp</A></B>(<A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pExp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addrExp
 Build addr expression representing the address of pExp.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../coins/ir/hir/AsmStmt.html" title="interface in coins.ir.hir">AsmStmt</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#asmStmt(java.lang.String, coins.ir.hir.HirList)">asmStmt</A></B>(java.lang.String&nbsp;pInstructions,
        <A HREF="../../../coins/ir/hir/HirList.html" title="interface in coins.ir.hir">HirList</A>&nbsp;pActualParamList)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;asmStmt
 Make a statement representing
  asm( formalParams, instructionList, actualParams ).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#checkLinkage(java.lang.String)">checkLinkage</A></B>(java.lang.String&nbsp;pCheckName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Check parent-child linkage if debug level (ioRoot.dbgHir.getLevel())
 is greater than 0.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#conditionalExp(coins.ir.hir.Exp)">conditionalExp</A></B>(<A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pExp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;conditionalExp builds boolean expression to be used as
 conditional expression of IfStmt and LoopStmt.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#contains(coins.ir.hir.HIR)">contains</A></B>(<A HREF="../../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pSubtree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Check if pSubtree is contained in this subtree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#copyInfListFrom(coins.ir.hir.HIR)">copyInfListFrom</A></B>(<A HREF="../../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pFromHir)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copy the contents of InfList attached to pFromHir
 to the InfList of this node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#cutParentLink()">cutParentLink</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cutParentLink
  Cut both links from/to parent node if they exist.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#exp(int, coins.ir.hir.Exp, coins.ir.hir.Exp, coins.ir.hir.Exp)">exp</A></B>(int&nbsp;pOperator,
    <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pExp1,
    <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pExp2,
    <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pExp3)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exp:
  Build ternary expression (OP_SELECT, etc.).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#expList(java.util.List)">expList</A></B>(java.util.List&nbsp;pList)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expList
 Make an expression representing a list of expressions,
 that is, make an instance of ExpListExp.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#expRepeat(coins.ir.hir.Exp, coins.ir.hir.Exp)">expRepeat</A></B>(<A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pValue,
          <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expRepeat
 Make an expression representing a list of expressions
 of the same value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../coins/ir/hir/ForStmt.html" title="interface in coins.ir.hir">ForStmt</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#forStmt(coins.ir.hir.Stmt, coins.sym.Label, coins.ir.hir.Exp, coins.ir.hir.Stmt, coins.sym.Label, coins.ir.hir.Stmt, coins.sym.Label)">forStmt</A></B>(<A HREF="../../../coins/ir/hir/Stmt.html" title="interface in coins.ir.hir">Stmt</A>&nbsp;pInitStmt,
        <A HREF="../../../coins/sym/Label.html" title="interface in coins.sym">Label</A>&nbsp;pLoopBackLabel,
        <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pCondition,
        <A HREF="../../../coins/ir/hir/Stmt.html" title="interface in coins.ir.hir">Stmt</A>&nbsp;pLoopBody,
        <A HREF="../../../coins/sym/Label.html" title="interface in coins.sym">Label</A>&nbsp;pLoopStepLabel,
        <A HREF="../../../coins/ir/hir/Stmt.html" title="interface in coins.ir.hir">Stmt</A>&nbsp;pStepPart,
        <A HREF="../../../coins/sym/Label.html" title="interface in coins.sym">Label</A>&nbsp;pLoopEndLabel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../coins/sym/ExpId.html" title="interface in coins.sym">ExpId</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#getExpId()">getExpId</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getExpId
  Get the expression identifier assigned to this node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../coins/sym/FlowAnalSym.html" title="interface in coins.sym">FlowAnalSym</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#getFlowAnalSym()">getFlowAnalSym</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getFlowAnalSym
  Get the flow analysis symbol assigned to this node if it is given.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#getIndentSpace(int)">getIndentSpace</A></B>(int&nbsp;pIndent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getIndentSace
  Get a sequence of spaces specified by pIndent.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#getInfString()">getInfString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the string image of Inf.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#getIrName()">getIrName</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getIrName
  Get operation name and node index
  to display node in compact form for flow analysis, debug, etc.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#getSourceNode(int)">getSourceNode</A></B>(int&nbsp;pNumber)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getSourceNode
  Get the pNumber-th source operand of "this" node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#getSourceNode1()">getSourceNode1</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getSourceNode1
  Get the 1st source operand node of "this" node where the
  source is an operand used/refered in "this" operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#getSourceNode2()">getSourceNode2</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getSourceNode2
  Get the 2nd source operand node of "this" node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../coins/sym/FlowAnalSym.html" title="interface in coins.sym">FlowAnalSym</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#getSymOrExpId()">getSymOrExpId</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getSymOrExpId
  If this is a SymNode with FlowAnalSym instance,
  then return it
  else return getExpId().</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#getWork()">getWork</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getWork
  Get information set by setWork for this node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#hirNodeClone()">hirNodeClone</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Make a copy of this HIR node
 without copying children.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../coins/ir/hir/HirSeq.html" title="interface in coins.ir.hir">HirSeq</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#hirSeq(coins.ir.hir.HIR)">hirSeq</A></B>(<A HREF="../../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pChild1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hirSeq Make an HirSeq node that have some definite number of
  children.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../coins/ir/hir/HirSeq.html" title="interface in coins.ir.hir">HirSeq</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#hirSeq(coins.ir.hir.HIR, coins.ir.hir.HIR, coins.ir.hir.HIR)">hirSeq</A></B>(<A HREF="../../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pChild1,
       <A HREF="../../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pChild2,
       <A HREF="../../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pChild3)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hirSeq Make an HirSeq node that have some definite number of
  children.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../coins/ir/hir/IndexedLoopStmt.html" title="interface in coins.ir.hir">IndexedLoopStmt</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#indexedLoopStmt(coins.sym.Var, coins.ir.hir.Exp, coins.ir.hir.Exp, coins.ir.hir.Exp, boolean, coins.ir.hir.Stmt)">indexedLoopStmt</A></B>(<A HREF="../../../coins/sym/Var.html" title="interface in coins.sym">Var</A>&nbsp;pLoopIndex,
                <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pStartValue,
                <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pEndValue,
                <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pStepValue,
                boolean&nbsp;pUpward,
                <A HREF="../../../coins/ir/hir/Stmt.html" title="interface in coins.ir.hir">Stmt</A>&nbsp;pLoopBody)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../coins/ir/hir/IndexedLoopStmt.html" title="interface in coins.ir.hir">IndexedLoopStmt</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#indexedLoopStmt(coins.sym.Var, coins.ir.hir.Exp, coins.ir.hir.Exp, coins.ir.hir.Exp, coins.ir.hir.Stmt)">indexedLoopStmt</A></B>(<A HREF="../../../coins/sym/Var.html" title="interface in coins.sym">Var</A>&nbsp;pLoopIndex,
                <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pStartValue,
                <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pEndValue,
                <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pStepValue,
                <A HREF="../../../coins/ir/hir/Stmt.html" title="interface in coins.ir.hir">Stmt</A>&nbsp;pLoopBody)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../coins/ir/hir/InfStmt.html" title="interface in coins.ir.hir">InfStmt</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#infStmt(java.lang.String, coins.ir.IrList)">infStmt</A></B>(java.lang.String&nbsp;pInfKindInterned,
        <A HREF="../../../coins/ir/IrList.html" title="interface in coins.ir">IrList</A>&nbsp;pInfData)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;infStmt
  Build an InfStmt representing some information.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../coins/ir/hir/InfStmt.html" title="interface in coins.ir.hir">InfStmt</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#infStmt(java.lang.String, java.lang.Object)">infStmt</A></B>(java.lang.String&nbsp;pInfKind,
        java.lang.Object&nbsp;pInfData)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../coins/ir/hir/ConstNode.html" title="interface in coins.ir.hir">ConstNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#intConstNode(int)">intConstNode</A></B>(int&nbsp;pIntValue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intConstNode
  Make a ConstNode instance having pIntValue as its value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../coins/ir/IrList.html" title="interface in coins.ir">IrList</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#irList(java.util.LinkedList)">irList</A></B>(java.util.LinkedList&nbsp;pList)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;irList Make an HirList node that makes a LinkedList.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#isEmpty(coins.ir.hir.HIR)">isEmpty</A></B>(<A HREF="../../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pHir)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isEmpty
 Decide if pHir is empty or not, where empty means either
   null, NullNode, HIR with OP_NULL as its operator,
   LabeledStmt whose statement body isEmpty, or
   ExpStmt whose Exp part isEmpty.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#isStmt()">isStmt</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isStmt</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#isTree()">isTree</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isTree
  Test if this does not violates tree structure, that is,
  detect node adherence in branches and
  handshake miss in parent-child relation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../coins/ir/hir/NullNode.html" title="interface in coins.ir.hir">NullNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#nullNode()">nullNode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nullNode
  Make a NullNode instance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../coins/ir/hir/Stmt.html" title="interface in coins.ir.hir">Stmt</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#nullStmt()">nullStmt</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nullStmt
  Make a statement having NullNode as its statement body.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../coins/ir/hir/ConstNode.html" title="interface in coins.ir.hir">ConstNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#offsetConstNode(long)">offsetConstNode</A></B>(long&nbsp;pIntValue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offsetConstNode
  Make a ConstNode instance having pIntValue as its offset value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../coins/ir/hir/PhiExp.html" title="interface in coins.ir.hir">PhiExp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#phiExp(coins.sym.Var, coins.sym.Label)">phiExp</A></B>(<A HREF="../../../coins/sym/Var.html" title="interface in coins.sym">Var</A>&nbsp;pVar,
       <A HREF="../../../coins/sym/Label.html" title="interface in coins.sym">Label</A>&nbsp;pLabel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phiExp
  Make a phi expression used in SSA.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../coins/ir/hir/RepeatStmt.html" title="interface in coins.ir.hir">RepeatStmt</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#repeatStmt(coins.sym.Label, coins.ir.hir.Stmt, coins.sym.Label, coins.ir.hir.Exp, coins.sym.Label)">repeatStmt</A></B>(<A HREF="../../../coins/sym/Label.html" title="interface in coins.sym">Label</A>&nbsp;pLoopBackLabel,
           <A HREF="../../../coins/ir/hir/Stmt.html" title="interface in coins.ir.hir">Stmt</A>&nbsp;pLoopBody,
           <A HREF="../../../coins/sym/Label.html" title="interface in coins.sym">Label</A>&nbsp;pLoopStepLabel,
           <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pCondition,
           <A HREF="../../../coins/sym/Label.html" title="interface in coins.sym">Label</A>&nbsp;pLoopEndLabel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#replaceSource(int, coins.ir.IR)">replaceSource</A></B>(int&nbsp;pNumber,
              <A HREF="../../../coins/ir/IR.html" title="interface in coins.ir">IR</A>&nbsp;pOperand)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replaceSource
  Replace pNumber-th source operand of "this" node by pOperand.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#replaceSource1(coins.ir.hir.HIR)">replaceSource1</A></B>(<A HREF="../../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pOperand)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replaceSource1
  Replace the source operand 1 of "this" node by pOperand.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#replaceSource2(coins.ir.hir.HIR)">replaceSource2</A></B>(<A HREF="../../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pOperand)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replaceSource2
  Replace the source operand 2 of "this" node by pOperand.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../coins/ir/hir/ReturnStmt.html" title="interface in coins.ir.hir">ReturnStmt</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#returnStmt()">returnStmt</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;returnStmt
  Build return statement that terminates the execution of
  current subprogram under construction.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#setChild1(coins.ir.IR)">setChild1</A></B>(<A HREF="../../../coins/ir/IR.html" title="interface in coins.ir">IR</A>&nbsp;p1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#setChild2(coins.ir.IR)">setChild2</A></B>(<A HREF="../../../coins/ir/IR.html" title="interface in coins.ir">IR</A>&nbsp;p2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#setChildren(coins.ir.IR, coins.ir.IR)">setChildren</A></B>(<A HREF="../../../coins/ir/IR.html" title="interface in coins.ir">IR</A>&nbsp;p1,
            <A HREF="../../../coins/ir/IR.html" title="interface in coins.ir">IR</A>&nbsp;p2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#setChildren(coins.ir.IR, coins.ir.IR, coins.ir.IR)">setChildren</A></B>(<A HREF="../../../coins/ir/IR.html" title="interface in coins.ir">IR</A>&nbsp;p1,
            <A HREF="../../../coins/ir/IR.html" title="interface in coins.ir">IR</A>&nbsp;p2,
            <A HREF="../../../coins/ir/IR.html" title="interface in coins.ir">IR</A>&nbsp;p3)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../coins/ir/hir/SetDataStmt.html" title="interface in coins.ir.hir">SetDataStmt</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#setDataStmt(coins.ir.hir.Exp, coins.ir.hir.Exp)">setDataStmt</A></B>(<A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pVariable,
            <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pValueExp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setDataStmt
 Make the statement that sets initial value or a list of
 initial values (pValueExp) to a variable (pVariable).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#setIndex(int)">setIndex</A></B>(int&nbsp;pIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setIndex
  Set an index number to "this" node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#setIndexNumberToAllNodes(int, boolean)">setIndexNumberToAllNodes</A></B>(int&nbsp;pStartNumber,
                         boolean&nbsp;pResetSymIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set index number to all nodes and if pResetSymIndex is true,
 reset Sym index by resetFlowAnalInf for FlowAnalSym nodes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#setParent(coins.ir.IR)">setParent</A></B>(<A HREF="../../../coins/ir/IR.html" title="interface in coins.ir">IR</A>&nbsp;pParent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setParent
  Set the parent of this node as pParent.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#setType(coins.sym.Type)">setType</A></B>(<A HREF="../../../coins/sym/Type.html" title="interface in coins.sym">Type</A>&nbsp;pType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setType
  Attach a type to this node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#setWork(java.lang.Object)">setWork</A></B>(java.lang.Object&nbsp;pWork)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setWork
  Set information privately used in each phase.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../coins/ir/hir/SubpDefinition.html" title="interface in coins.ir.hir">SubpDefinition</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#subpDefinition(coins.sym.Subp, coins.sym.SymTable, coins.ir.hir.BlockStmt, coins.ir.hir.BlockStmt)">subpDefinition</A></B>(<A HREF="../../../coins/sym/Subp.html" title="interface in coins.sym">Subp</A>&nbsp;pSubpSym,
               <A HREF="../../../coins/sym/SymTable.html" title="interface in coins.sym">SymTable</A>&nbsp;pLocalSymTable,
               <A HREF="../../../coins/ir/hir/BlockStmt.html" title="interface in coins.ir.hir">BlockStmt</A>&nbsp;pInitiationPart,
               <A HREF="../../../coins/ir/hir/BlockStmt.html" title="interface in coins.ir.hir">BlockStmt</A>&nbsp;pHirBody)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subpDefinition with full specification.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Iterator</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#subpIterator()">subpIterator</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subpIterator
  Make an iterator that traverses all subprogram definitions
  in the current compile unit.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#subscriptedExp(coins.ir.hir.Exp, coins.ir.hir.Exp, coins.ir.hir.Exp)">subscriptedExp</A></B>(<A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pArrayExp,
               <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pSubscript,
               <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pElemSize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subscriptedExp
  Build an expression representing the indicated element
  of a vector whose element size is unfixed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;toString
  Get text representation of this node
  without traversing children.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#toStringDetail()">toStringDetail</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;toStringDetail
  Get text string of this node showing detail information.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#toStringShort()">toStringShort</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;toStringShort
  Get text string of this node showing node name and index only.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#toStringWithChildren()">toStringWithChildren</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;toStringWithChildren
 Get the string of this node and its children traversing the children
 in depth-first order.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#undecayExp(coins.ir.hir.Exp, coins.ir.hir.ConstNode)">undecayExp</A></B>(<A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pPointerExp,
           <A HREF="../../../coins/ir/hir/ConstNode.html" title="interface in coins.ir.hir">ConstNode</A>&nbsp;pElemCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;undecayExp
  Build an expression that undecay a pointer to a vector whose element
  type is pointed type.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#undecayExp(coins.ir.hir.Exp, coins.ir.hir.Exp, coins.ir.hir.Exp)">undecayExp</A></B>(<A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pPointerExp,
           <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pElemCount,
           <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pLowerBound)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;undecayExp
  Build an expression that undecay a pointer to a vector whose element
  type is pointed type.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#undecayExp(coins.ir.hir.Exp, long)">undecayExp</A></B>(<A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pPointerExp,
           long&nbsp;pElemCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;undecayExp
  Build an expression that undecay a pointer to a vector whose element
  type is pointed type.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../coins/ir/hir/WhileStmt.html" title="interface in coins.ir.hir">WhileStmt</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../coins/ir/hir/HIR.html#whileStmt(coins.sym.Label, coins.ir.hir.Exp, coins.ir.hir.Stmt, coins.sym.Label, coins.sym.Label)">whileStmt</A></B>(<A HREF="../../../coins/sym/Label.html" title="interface in coins.sym">Label</A>&nbsp;pLoopBackLabel,
          <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pCondition,
          <A HREF="../../../coins/ir/hir/Stmt.html" title="interface in coins.ir.hir">Stmt</A>&nbsp;pLoopBody,
          <A HREF="../../../coins/sym/Label.html" title="interface in coins.sym">Label</A>&nbsp;pLoopStepLabel,
          <A HREF="../../../coins/sym/Label.html" title="interface in coins.sym">Label</A>&nbsp;pLoopEndLabel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ifStmt
  Build an if-statement with then-part (pThenPart) and
  else-part (pElsePart).</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_coins.ir.IR"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from interface coins.ir.<A HREF="../../../coins/ir/IR.html" title="interface in coins.ir">IR</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../coins/ir/IR.html#addInf(java.lang.String, java.lang.Object)">addInf</A>, <A HREF="../../../coins/ir/IR.html#getChild1()">getChild1</A>, <A HREF="../../../coins/ir/IR.html#getChild2()">getChild2</A>, <A HREF="../../../coins/ir/IR.html#getInf(java.lang.String)">getInf</A>, <A HREF="../../../coins/ir/IR.html#getInfList()">getInfList</A>, <A HREF="../../../coins/ir/IR.html#getParent()">getParent</A>, <A HREF="../../../coins/ir/IR.html#getSym()">getSym</A>, <A HREF="../../../coins/ir/IR.html#print(int)">print</A>, <A HREF="../../../coins/ir/IR.html#print(int, boolean)">print</A>, <A HREF="../../../coins/ir/IR.html#removeInf(java.lang.String)">removeInf</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_coins.ir.IR0"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from interface coins.ir.<A HREF="../../../coins/ir/IR0.html" title="interface in coins.ir">IR0</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../coins/ir/IR0.html#getChild(int)">getChild</A>, <A HREF="../../../coins/ir/IR0.html#getChildCount()">getChildCount</A>, <A HREF="../../../coins/ir/IR0.html#getIndex()">getIndex</A>, <A HREF="../../../coins/ir/IR0.html#getOperator()">getOperator</A>, <A HREF="../../../coins/ir/IR0.html#setChild(int, coins.ir.IR)">setChild</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_coins.ir.hir.HIR0"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from interface coins.ir.hir.<A HREF="../../../coins/ir/hir/HIR0.html" title="interface in coins.ir.hir">HIR0</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../coins/ir/hir/HIR0.html#accept(coins.ir.hir.HirVisitor)">accept</A>, <A HREF="../../../coins/ir/hir/HIR0.html#assignStmt(coins.ir.hir.Exp, coins.ir.hir.Exp)">assignStmt</A>, <A HREF="../../../coins/ir/hir/HIR0.html#blockStmt(coins.ir.hir.Stmt)">blockStmt</A>, <A HREF="../../../coins/ir/hir/HIR0.html#callStmt(coins.ir.hir.Exp, coins.ir.IrList)">callStmt</A>, <A HREF="../../../coins/ir/hir/HIR0.html#constNode(coins.sym.Const)">constNode</A>, <A HREF="../../../coins/ir/hir/HIR0.html#contentsExp(coins.ir.hir.Exp)">contentsExp</A>, <A HREF="../../../coins/ir/hir/HIR0.html#convExp(coins.sym.Type, coins.ir.hir.Exp)">convExp</A>, <A HREF="../../../coins/ir/hir/HIR0.html#copyWithOperands()">copyWithOperands</A>, <A HREF="../../../coins/ir/hir/HIR0.html#copyWithOperandsChangingLabels(coins.ir.IrList)">copyWithOperandsChangingLabels</A>, <A HREF="../../../coins/ir/hir/HIR0.html#decayExp(coins.ir.hir.Exp)">decayExp</A>, <A HREF="../../../coins/ir/hir/HIR0.html#elemNode(coins.sym.Elem)">elemNode</A>, <A HREF="../../../coins/ir/hir/HIR0.html#exp(int, coins.ir.hir.Exp)">exp</A>, <A HREF="../../../coins/ir/hir/HIR0.html#exp(int, coins.ir.hir.Exp, coins.ir.hir.Exp)">exp</A>, <A HREF="../../../coins/ir/hir/HIR0.html#expStmt(coins.ir.hir.Exp)">expStmt</A>, <A HREF="../../../coins/ir/hir/HIR0.html#falseNode()">falseNode</A>, <A HREF="../../../coins/ir/hir/HIR0.html#finishHir()">finishHir</A>, <A HREF="../../../coins/ir/hir/HIR0.html#forStmt(coins.ir.hir.Stmt, coins.ir.hir.Exp, coins.ir.hir.Stmt, coins.ir.hir.Stmt)">forStmt</A>, <A HREF="../../../coins/ir/hir/HIR0.html#functionExp(coins.ir.hir.Exp, coins.ir.IrList)">functionExp</A>, <A HREF="../../../coins/ir/hir/HIR0.html#getChildNumber()">getChildNumber</A>, <A HREF="../../../coins/ir/hir/HIR0.html#getFlag(int)">getFlag</A>, <A HREF="../../../coins/ir/hir/HIR0.html#getFlagBox()">getFlagBox</A>, <A HREF="../../../coins/ir/hir/HIR0.html#getNextStmt()">getNextStmt</A>, <A HREF="../../../coins/ir/hir/HIR0.html#getStmtContainingThisNode()">getStmtContainingThisNode</A>, <A HREF="../../../coins/ir/hir/HIR0.html#getType()">getType</A>, <A HREF="../../../coins/ir/hir/HIR0.html#hirClone()">hirClone</A>, <A HREF="../../../coins/ir/hir/HIR0.html#hirIterator(coins.ir.IR)">hirIterator</A>, <A HREF="../../../coins/ir/hir/HIR0.html#hirList()">hirList</A>, <A HREF="../../../coins/ir/hir/HIR0.html#hirSeq(coins.ir.hir.HIR, coins.ir.hir.HIR)">hirSeq</A>, <A HREF="../../../coins/ir/hir/HIR0.html#ifStmt(coins.ir.hir.Exp, coins.ir.hir.Stmt, coins.ir.hir.Stmt)">ifStmt</A>, <A HREF="../../../coins/ir/hir/HIR0.html#intConstNode(long)">intConstNode</A>, <A HREF="../../../coins/ir/hir/HIR0.html#irList()">irList</A>, <A HREF="../../../coins/ir/hir/HIR0.html#isSameAs(coins.ir.hir.HIR)">isSameAs</A>, <A HREF="../../../coins/ir/hir/HIR0.html#jumpStmt(coins.sym.Label)">jumpStmt</A>, <A HREF="../../../coins/ir/hir/HIR0.html#labelDef(coins.sym.Label)">labelDef</A>, <A HREF="../../../coins/ir/hir/HIR0.html#labeledStmt(coins.sym.Label, coins.ir.hir.Stmt)">labeledStmt</A>, <A HREF="../../../coins/ir/hir/HIR0.html#labelNode(coins.sym.Label)">labelNode</A>, <A HREF="../../../coins/ir/hir/HIR0.html#pointedExp(coins.ir.hir.Exp, coins.ir.hir.ElemNode)">pointedExp</A>, <A HREF="../../../coins/ir/hir/HIR0.html#print(int, boolean)">print</A>, <A HREF="../../../coins/ir/hir/HIR0.html#program(coins.sym.Sym, coins.sym.SymTable, coins.ir.IR, coins.ir.IrList)">program</A>, <A HREF="../../../coins/ir/hir/HIR0.html#qualifiedExp(coins.ir.hir.Exp, coins.ir.hir.ElemNode)">qualifiedExp</A>, <A HREF="../../../coins/ir/hir/HIR0.html#repeatStmt(coins.ir.hir.Stmt, coins.ir.hir.Exp)">repeatStmt</A>, <A HREF="../../../coins/ir/hir/HIR0.html#replaceThisNode(coins.ir.hir.HIR)">replaceThisNode</A>, <A HREF="../../../coins/ir/hir/HIR0.html#returnStmt(coins.ir.hir.Exp)">returnStmt</A>, <A HREF="../../../coins/ir/hir/HIR0.html#setFlag(int, boolean)">setFlag</A>, <A HREF="../../../coins/ir/hir/HIR0.html#setIndexNumberToAllNodes(int)">setIndexNumberToAllNodes</A>, <A HREF="../../../coins/ir/hir/HIR0.html#sizeofExp(coins.ir.hir.Exp)">sizeofExp</A>, <A HREF="../../../coins/ir/hir/HIR0.html#sizeofExp(coins.sym.Type)">sizeofExp</A>, <A HREF="../../../coins/ir/hir/HIR0.html#subpDefinition(coins.sym.Subp, coins.sym.SymTable)">subpDefinition</A>, <A HREF="../../../coins/ir/hir/HIR0.html#subpNode(coins.sym.Subp)">subpNode</A>, <A HREF="../../../coins/ir/hir/HIR0.html#subscriptedExp(coins.ir.hir.Exp, coins.ir.hir.Exp)">subscriptedExp</A>, <A HREF="../../../coins/ir/hir/HIR0.html#switchStmt(coins.ir.hir.Exp, coins.ir.IrList, coins.sym.Label, coins.ir.hir.Stmt, coins.sym.Label)">switchStmt</A>, <A HREF="../../../coins/ir/hir/HIR0.html#symNode(coins.sym.Sym)">symNode</A>, <A HREF="../../../coins/ir/hir/HIR0.html#trueNode()">trueNode</A>, <A HREF="../../../coins/ir/hir/HIR0.html#undecayExp(coins.ir.hir.Exp, long, long)">undecayExp</A>, <A HREF="../../../coins/ir/hir/HIR0.html#varNode(coins.sym.Var)">varNode</A>, <A HREF="../../../coins/ir/hir/HIR0.html#whileStmt(coins.ir.hir.Exp, coins.ir.hir.Stmt)">whileStmt</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="OP_CODE_NAME"><!-- --></A><H3>
OP_CODE_NAME</H3>
<PRE>
public static final java.lang.String[] <B>OP_CODE_NAME</B></PRE>
<DL>
<DD>Operator number
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="OP_CODE_NAME_DENSE"><!-- --></A><H3>
OP_CODE_NAME_DENSE</H3>
<PRE>
public static final java.lang.String[] <B>OP_CODE_NAME_DENSE</B></PRE>
<DL>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->


<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="subpDefinition(coins.sym.Subp, coins.sym.SymTable, coins.ir.hir.BlockStmt, coins.ir.hir.BlockStmt)"><!-- --></A><H3>
subpDefinition</H3>
<PRE>
public <A HREF="../../../coins/ir/hir/SubpDefinition.html" title="interface in coins.ir.hir">SubpDefinition</A> <B>subpDefinition</B>(<A HREF="../../../coins/sym/Subp.html" title="interface in coins.sym">Subp</A>&nbsp;pSubpSym,
                                     <A HREF="../../../coins/sym/SymTable.html" title="interface in coins.sym">SymTable</A>&nbsp;pLocalSymTable,
                                     <A HREF="../../../coins/ir/hir/BlockStmt.html" title="interface in coins.ir.hir">BlockStmt</A>&nbsp;pInitiationPart,
                                     <A HREF="../../../coins/ir/hir/BlockStmt.html" title="interface in coins.ir.hir">BlockStmt</A>&nbsp;pHirBody)</PRE>
<DL>
<DD>subpDefinition with full specification.
  Other items are the same as the previous method.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pSubpSym</CODE> - Subprogram symbol. Should be given.<DD><CODE>pLocalSymTable</CODE> - Symbol table local in the subprogram;
      If subprogram uses a local symbol table, this parameter
      should be given (by using pushSymTable() of SymTable
      interface); Even if the source program does not use
      local symbol, this parameter is required to register
      temporal variables and internal labels generated by
      the compiler. //##51<DD><CODE>pInitiationPart</CODE> - Initiation statement block. optional.<DD><CODE>pHirBody</CODE> - Subprogram body in HIR. optional.</DL>
</DD>
</DL>
<HR>

<A NAME="irList(java.util.LinkedList)"><!-- --></A><H3>
irList</H3>
<PRE>
public <A HREF="../../../coins/ir/IrList.html" title="interface in coins.ir">IrList</A> <B>irList</B>(java.util.LinkedList&nbsp;pList)</PRE>
<DL>
<DD>irList Make an HirList node that makes a LinkedList.
  The created list can be treated as an HIR node.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pList</CODE> - List of objects to be included in the HirList;
      The elements of the list are an HIR object or Sym object.
<DT><B>Returns:</B><DD>IrList containing pList;
      Resultant list is also an instance of HIR.</DL>
</DD>
</DL>
<HR>

<A NAME="infStmt(java.lang.String, coins.ir.IrList)"><!-- --></A><H3>
infStmt</H3>
<PRE>
public <A HREF="../../../coins/ir/hir/InfStmt.html" title="interface in coins.ir.hir">InfStmt</A> <B>infStmt</B>(java.lang.String&nbsp;pInfKindInterned,
                       <A HREF="../../../coins/ir/IrList.html" title="interface in coins.ir">IrList</A>&nbsp;pInfData)</PRE>
<DL>
<DD>infStmt
  Build an InfStmt representing some information.
  The information may be defined in each compiler for arbitrary purpose.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pInfKindInterned</CODE> - a string to identify the information kind of
      the InfNode. It should be an interned string (string with intern());
      See coins.Registry.<DD><CODE>pInfData</CODE> - IrList of objects to be attached (Sym, HIR node, String or IrList);
      The object kind is indicated by the pInfKindInterned;
      If an element of the IrList is an IrList, then the parameter can represent
      complicated information structure.</DL>
</DD>
</DL>
<HR>

<A NAME="infStmt(java.lang.String, java.lang.Object)"><!-- --></A><H3>
infStmt</H3>
<PRE>
public <A HREF="../../../coins/ir/hir/InfStmt.html" title="interface in coins.ir.hir">InfStmt</A> <B>infStmt</B>(java.lang.String&nbsp;pInfKind,
                       java.lang.Object&nbsp;pInfData)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setType(coins.sym.Type)"><!-- --></A><H3>
setType</H3>
<PRE>
public void <B>setType</B>(<A HREF="../../../coins/sym/Type.html" title="interface in coins.sym">Type</A>&nbsp;pType)</PRE>
<DL>
<DD>setType
  Attach a type to this node.
  When HIR node is created by HIR factory methods,
  its type is set in the factory methods so that
  it is unnecessary to call setType again.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pType</CODE> - type to be attached to this node;
      It should represent a proper type corresponding to the
      result of subtree represented by this node.</DL>
</DD>
</DL>
<HR>

<A NAME="setWork(java.lang.Object)"><!-- --></A><H3>
setWork</H3>
<PRE>
public void <B>setWork</B>(java.lang.Object&nbsp;pWork)</PRE>
<DL>
<DD>setWork
  Set information privately used in each phase.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pWork</CODE> - any information of arbitrary class to be set to this node;
      You may define a new class that represents arbitrary information
      and give its reference as pWork.
  This method is moved to IR interface.</DL>
</DD>
</DL>
<HR>

<A NAME="getWork()"><!-- --></A><H3>
getWork</H3>
<PRE>
public java.lang.Object <B>getWork</B>()</PRE>
<DL>
<DD>getWork
  Get information set by setWork for this node.
  Users should cast by the name of the class used in setWork.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the information object set by setWork.
  This method is moved to IR interface.</DL>
</DD>
</DL>
<HR>

<A NAME="getExpId()"><!-- --></A><H3>
getExpId</H3>
<PRE>
public <A HREF="../../../coins/sym/ExpId.html" title="interface in coins.sym">ExpId</A> <B>getExpId</B>()</PRE>
<DL>
<DD>getExpId
  Get the expression identifier assigned to this node.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the expression identifier assigned to this node,
      or return null if it is not assigned.</DL>
</DD>
</DL>
<HR>

<A NAME="getSymOrExpId()"><!-- --></A><H3>
getSymOrExpId</H3>
<PRE>
public <A HREF="../../../coins/sym/FlowAnalSym.html" title="interface in coins.sym">FlowAnalSym</A> <B>getSymOrExpId</B>()</PRE>
<DL>
<DD>getSymOrExpId
  If this is a SymNode with FlowAnalSym instance,
  then return it
  else return getExpId().
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>FlowAnalSym or ExpId attached to this node.</DL>
</DD>
</DL>
<HR>

<A NAME="isStmt()"><!-- --></A><H3>
isStmt</H3>
<PRE>
public boolean <B>isStmt</B>()</PRE>
<DL>
<DD>isStmt
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true if this node is a statement node,
      otherwise return false.</DL>
</DD>
</DL>
<HR>

<A NAME="isEmpty(coins.ir.hir.HIR)"><!-- --></A><H3>
isEmpty</H3>
<PRE>
public boolean <B>isEmpty</B>(<A HREF="../../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pHir)</PRE>
<DL>
<DD>isEmpty
 Decide if pHir is empty or not, where empty means either
   null, NullNode, HIR with OP_NULL as its operator,
   LabeledStmt whose statement body isEmpty, or
   ExpStmt whose Exp part isEmpty.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pHir</CODE> - HIR node to be tested if empty or not.
<DT><B>Returns:</B><DD>true if pHir is empty else retuen false.</DL>
</DD>
</DL>
<HR>

<A NAME="contains(coins.ir.hir.HIR)"><!-- --></A><H3>
contains</H3>
<PRE>
public boolean <B>contains</B>(<A HREF="../../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pSubtree)</PRE>
<DL>
<DD>Check if pSubtree is contained in this subtree.
 It is not recommended to apply this method to large subtree
 but recommended to apply to small subtree such as expressions.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pSubtree</CODE> - subtree to be searched.
<DT><B>Returns:</B><DD>true if found, false if not found.</DL>
</DD>
</DL>
<HR>

<A NAME="cutParentLink()"><!-- --></A><H3>
cutParentLink</H3>
<PRE>
public void <B>cutParentLink</B>()</PRE>
<DL>
<DD>cutParentLink
  Cut both links from/to parent node if they exist.
  (Used to prepare for moving a node.)
  This method is prepared for factory methods and it is not
  recommended to use this method except when user knows the
  structure of HIR in detail.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="intConstNode(int)"><!-- --></A><H3>
intConstNode</H3>
<PRE>
public <A HREF="../../../coins/ir/hir/ConstNode.html" title="interface in coins.ir.hir">ConstNode</A> <B>intConstNode</B>(int&nbsp;pIntValue)</PRE>
<DL>
<DD>intConstNode
  Make a ConstNode instance having pIntValue as its value.
  The constant value is changed to Const symbol and attached to
  the constant node.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pIntValue</CODE> - Integer value to be attached to the node.
<DT><B>Returns:</B><DD>the resultant ConstNode.</DL>
</DD>
</DL>
<HR>

<A NAME="offsetConstNode(long)"><!-- --></A><H3>
offsetConstNode</H3>
<PRE>
public <A HREF="../../../coins/ir/hir/ConstNode.html" title="interface in coins.ir.hir">ConstNode</A> <B>offsetConstNode</B>(long&nbsp;pIntValue)</PRE>
<DL>
<DD>offsetConstNode
  Make a ConstNode instance having pIntValue as its offset value.
  The offset value pIntValue is changed to Const symbol and
  attached to the constant node.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pIntValue</CODE> - Offset value to be attached to the node.
<DT><B>Returns:</B><DD>the resultant ConstNode.</DL>
</DD>
</DL>
<HR>

<A NAME="nullNode()"><!-- --></A><H3>
nullNode</H3>
<PRE>
public <A HREF="../../../coins/ir/hir/NullNode.html" title="interface in coins.ir.hir">NullNode</A> <B>nullNode</B>()</PRE>
<DL>
<DD>nullNode
  Make a NullNode instance.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the NullNode.</DL>
</DD>
</DL>
<HR>

<A NAME="exp(int, coins.ir.hir.Exp, coins.ir.hir.Exp, coins.ir.hir.Exp)"><!-- --></A><H3>
exp</H3>
<PRE>
public <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A> <B>exp</B>(int&nbsp;pOperator,
               <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pExp1,
               <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pExp2,
               <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pExp3)</PRE>
<DL>
<DD>exp:
  Build ternary expression (OP_SELECT, etc.).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pExp1</CODE> - operand 1 expression.<DD><CODE>pExp2</CODE> - operand 2 expression.<DD><CODE>pExp3</CODE> - operand 3 expression.
<DT><B>Returns:</B><DD>the resultant ternary expression subtree.</DL>
</DD>
</DL>
<HR>

<A NAME="undecayExp(coins.ir.hir.Exp, coins.ir.hir.ConstNode)"><!-- --></A><H3>
undecayExp</H3>
<PRE>
public <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A> <B>undecayExp</B>(<A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pPointerExp,
                      <A HREF="../../../coins/ir/hir/ConstNode.html" title="interface in coins.ir.hir">ConstNode</A>&nbsp;pElemCount)</PRE>
<DL>
<DD>undecayExp
  Build an expression that undecay a pointer to a vector whose element
  type is pointed type.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pPointerExp</CODE> - pointer expression pointing to the
      first element of the resultant vector.<DD><CODE>pElemCount</CODE> - Constant expression showing element count of
      the resultant vector.
<DT><B>Returns:</B><DD>the vector expression.</DL>
</DD>
</DL>
<HR>

<A NAME="undecayExp(coins.ir.hir.Exp, coins.ir.hir.Exp, coins.ir.hir.Exp)"><!-- --></A><H3>
undecayExp</H3>
<PRE>
public <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A> <B>undecayExp</B>(<A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pPointerExp,
                      <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pElemCount,
                      <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pLowerBound)</PRE>
<DL>
<DD>undecayExp
  Build an expression that undecay a pointer to a vector whose element
  type is pointed type.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pPointerExp</CODE> - pointer expression pointing to the
      first element of the resultant vector.<DD><CODE>pElemCount</CODE> - Expression showing element count of
      the resultant vector.<DD><CODE>pLowerBound</CODE> - Expression showing the lower index bound of
      the resultant vector.
<DT><B>Returns:</B><DD>the vector expression.</DL>
</DD>
</DL>
<HR>

<A NAME="undecayExp(coins.ir.hir.Exp, long)"><!-- --></A><H3>
undecayExp</H3>
<PRE>
public <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A> <B>undecayExp</B>(<A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pPointerExp,
                      long&nbsp;pElemCount)</PRE>
<DL>
<DD>undecayExp
  Build an expression that undecay a pointer to a vector whose element
  type is pointed type.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pPointerExp</CODE> - pointer expression pointing to the
      first element of the resultant vector.<DD><CODE>pElemCount</CODE> - element count of the resultant vector.
<DT><B>Returns:</B><DD>the vector expression.</DL>
</DD>
</DL>
<HR>

<A NAME="subscriptedExp(coins.ir.hir.Exp, coins.ir.hir.Exp, coins.ir.hir.Exp)"><!-- --></A><H3>
subscriptedExp</H3>
<PRE>
public <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A> <B>subscriptedExp</B>(<A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pArrayExp,
                          <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pSubscript,
                          <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pElemSize)</PRE>
<DL>
<DD>subscriptedExp
  Build an expression representing the indicated element
  of a vector whose element size is unfixed.
  If the size of the vector element is fixed and pElemSize is
  equal to it, then
    (subs pArrayExp pSubscript)
  is returned.
  If not, then a pointer expression representing the element
  located at the address
    addr(pArrayExp) + pElemSize * (pSubscript - lowerBound)
  is returned.
  As for vectors whose element size is constant or represented
  by an expression, use
    subscriptedExp( Exp pArrayExp, Exp pSubscript )
  instead of this method.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pArrayExp</CODE> - is array expression to which subscript is
      to be attached (it is unfixed size vector).<DD><CODE>pSubscript</CODE> - is subscript expression.<DD><CODE>pElemSize</CODE> - is the element size of pArrayExp in bytes.
<DT><B>Returns:</B><DD>either subscripted expression node having operation code subsCode
     or pointer expression if the element type is unfixed-size.</DL>
</DD>
</DL>
<HR>

<A NAME="addrExp(coins.ir.hir.Exp)"><!-- --></A><H3>
addrExp</H3>
<PRE>
public <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A> <B>addrExp</B>(<A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pExp)</PRE>
<DL>
<DD>addrExp
 Build addr expression representing the address of pExp.
 pExp should be l-value expression such as variable or
 SubpNode expression.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pExp</CODE> - l-value expression or SubpNode.
<DT><B>Returns:</B><DD>the addr expression.</DL>
</DD>
</DL>
<HR>

<A NAME="conditionalExp(coins.ir.hir.Exp)"><!-- --></A><H3>
conditionalExp</H3>
<PRE>
public <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A> <B>conditionalExp</B>(<A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pExp)</PRE>
<DL>
<DD>conditionalExp builds boolean expression to be used as
 conditional expression of IfStmt and LoopStmt.
 This will transform pExp to comparison expression
 if it is not so that conversion to LIR become easy.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pExp</CODE> - boolean expression.
<DT><B>Returns:</B><DD>pExp if pExp is a comparison expression or
         return comparison expression transformed from pExp.</DL>
</DD>
</DL>
<HR>

<A NAME="whileStmt(coins.sym.Label, coins.ir.hir.Exp, coins.ir.hir.Stmt, coins.sym.Label, coins.sym.Label)"><!-- --></A><H3>
whileStmt</H3>
<PRE>
public <A HREF="../../../coins/ir/hir/WhileStmt.html" title="interface in coins.ir.hir">WhileStmt</A> <B>whileStmt</B>(<A HREF="../../../coins/sym/Label.html" title="interface in coins.sym">Label</A>&nbsp;pLoopBackLabel,
                           <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pCondition,
                           <A HREF="../../../coins/ir/hir/Stmt.html" title="interface in coins.ir.hir">Stmt</A>&nbsp;pLoopBody,
                           <A HREF="../../../coins/sym/Label.html" title="interface in coins.sym">Label</A>&nbsp;pLoopStepLabel,
                           <A HREF="../../../coins/sym/Label.html" title="interface in coins.sym">Label</A>&nbsp;pLoopEndLabel)</PRE>
<DL>
<DD>ifStmt
  Build an if-statement with then-part (pThenPart) and
  else-part (pElsePart).
  Internal labels (then-label and else-label) are generated
  to be attached to the then-part and else-part.
  If pThenPart or pElsePart is null, a LabeledStmt with null
  statement body is generated as then-part or else-part.
  (null else-part can be deleted by deleteUselessLabeledStmtOfHir()
  of coins.flow.DeleteUnusedLabels1.)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pCondition</CODE> - conditional expression subtree.
<DT><B>Returns:</B><DD>the subtree of the built statement
      with statement body operator OP_IF;
      If else-part is not given, it is treated as null.</DL>
</DD>
</DL>
<HR>

<A NAME="forStmt(coins.ir.hir.Stmt, coins.sym.Label, coins.ir.hir.Exp, coins.ir.hir.Stmt, coins.sym.Label, coins.ir.hir.Stmt, coins.sym.Label)"><!-- --></A><H3>
forStmt</H3>
<PRE>
public <A HREF="../../../coins/ir/hir/ForStmt.html" title="interface in coins.ir.hir">ForStmt</A> <B>forStmt</B>(<A HREF="../../../coins/ir/hir/Stmt.html" title="interface in coins.ir.hir">Stmt</A>&nbsp;pInitStmt,
                       <A HREF="../../../coins/sym/Label.html" title="interface in coins.sym">Label</A>&nbsp;pLoopBackLabel,
                       <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pCondition,
                       <A HREF="../../../coins/ir/hir/Stmt.html" title="interface in coins.ir.hir">Stmt</A>&nbsp;pLoopBody,
                       <A HREF="../../../coins/sym/Label.html" title="interface in coins.sym">Label</A>&nbsp;pLoopStepLabel,
                       <A HREF="../../../coins/ir/hir/Stmt.html" title="interface in coins.ir.hir">Stmt</A>&nbsp;pStepPart,
                       <A HREF="../../../coins/sym/Label.html" title="interface in coins.sym">Label</A>&nbsp;pLoopEndLabel)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="repeatStmt(coins.sym.Label, coins.ir.hir.Stmt, coins.sym.Label, coins.ir.hir.Exp, coins.sym.Label)"><!-- --></A><H3>
repeatStmt</H3>
<PRE>
public <A HREF="../../../coins/ir/hir/RepeatStmt.html" title="interface in coins.ir.hir">RepeatStmt</A> <B>repeatStmt</B>(<A HREF="../../../coins/sym/Label.html" title="interface in coins.sym">Label</A>&nbsp;pLoopBackLabel,
                             <A HREF="../../../coins/ir/hir/Stmt.html" title="interface in coins.ir.hir">Stmt</A>&nbsp;pLoopBody,
                             <A HREF="../../../coins/sym/Label.html" title="interface in coins.sym">Label</A>&nbsp;pLoopStepLabel,
                             <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pCondition,
                             <A HREF="../../../coins/sym/Label.html" title="interface in coins.sym">Label</A>&nbsp;pLoopEndLabel)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="indexedLoopStmt(coins.sym.Var, coins.ir.hir.Exp, coins.ir.hir.Exp, coins.ir.hir.Exp, coins.ir.hir.Stmt)"><!-- --></A><H3>
indexedLoopStmt</H3>
<PRE>
public <A HREF="../../../coins/ir/hir/IndexedLoopStmt.html" title="interface in coins.ir.hir">IndexedLoopStmt</A> <B>indexedLoopStmt</B>(<A HREF="../../../coins/sym/Var.html" title="interface in coins.sym">Var</A>&nbsp;pLoopIndex,
                                       <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pStartValue,
                                       <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pEndValue,
                                       <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pStepValue,
                                       <A HREF="../../../coins/ir/hir/Stmt.html" title="interface in coins.ir.hir">Stmt</A>&nbsp;pLoopBody)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="indexedLoopStmt(coins.sym.Var, coins.ir.hir.Exp, coins.ir.hir.Exp, coins.ir.hir.Exp, boolean, coins.ir.hir.Stmt)"><!-- --></A><H3>
indexedLoopStmt</H3>
<PRE>
public <A HREF="../../../coins/ir/hir/IndexedLoopStmt.html" title="interface in coins.ir.hir">IndexedLoopStmt</A> <B>indexedLoopStmt</B>(<A HREF="../../../coins/sym/Var.html" title="interface in coins.sym">Var</A>&nbsp;pLoopIndex,
                                       <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pStartValue,
                                       <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pEndValue,
                                       <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pStepValue,
                                       boolean&nbsp;pUpward,
                                       <A HREF="../../../coins/ir/hir/Stmt.html" title="interface in coins.ir.hir">Stmt</A>&nbsp;pLoopBody)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="returnStmt()"><!-- --></A><H3>
returnStmt</H3>
<PRE>
public <A HREF="../../../coins/ir/hir/ReturnStmt.html" title="interface in coins.ir.hir">ReturnStmt</A> <B>returnStmt</B>()</PRE>
<DL>
<DD>returnStmt
  Build return statement that terminates the execution of
  current subprogram under construction.
  It has no return value.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the subtree of the built statement
      with statement body operator OP_RETURN.</DL>
</DD>
</DL>
<HR>

<A NAME="nullStmt()"><!-- --></A><H3>
nullStmt</H3>
<PRE>
public <A HREF="../../../coins/ir/hir/Stmt.html" title="interface in coins.ir.hir">Stmt</A> <B>nullStmt</B>()</PRE>
<DL>
<DD>nullStmt
  Make a statement having NullNode as its statement body.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the null statement.</DL>
</DD>
</DL>
<HR>

<A NAME="asmStmt(java.lang.String, coins.ir.hir.HirList)"><!-- --></A><H3>
asmStmt</H3>
<PRE>
public <A HREF="../../../coins/ir/hir/AsmStmt.html" title="interface in coins.ir.hir">AsmStmt</A> <B>asmStmt</B>(java.lang.String&nbsp;pInstructions,
                       <A HREF="../../../coins/ir/hir/HirList.html" title="interface in coins.ir.hir">HirList</A>&nbsp;pActualParamList)</PRE>
<DL>
<DD>asmStmt
 Make a statement representing
  asm( formalParams, instructionList, actualParams ).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pInstructions</CODE> - String representing formal parameters and
    sequence of instructions.<DD><CODE>pActualParamList</CODE> - List of variable nodes and arithmetic expressions
    representing actual parameters.
<DT><B>Returns:</B><DD>instance of AsmStmt.</DL>
</DD>
</DL>
<HR>

<A NAME="phiExp(coins.sym.Var, coins.sym.Label)"><!-- --></A><H3>
phiExp</H3>
<PRE>
public <A HREF="../../../coins/ir/hir/PhiExp.html" title="interface in coins.ir.hir">PhiExp</A> <B>phiExp</B>(<A HREF="../../../coins/sym/Var.html" title="interface in coins.sym">Var</A>&nbsp;pVar,
                     <A HREF="../../../coins/sym/Label.html" title="interface in coins.sym">Label</A>&nbsp;pLabel)</PRE>
<DL>
<DD>phiExp
  Make a phi expression used in SSA.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pVar</CODE> - variable to be selected.<DD><CODE>pLabel</CODE> - label attached to a basic block from which
     control tranfers.
<DT><B>Returns:</B><DD>PhiExp.</DL>
</DD>
</DL>
<HR>

<A NAME="hirSeq(coins.ir.hir.HIR)"><!-- --></A><H3>
hirSeq</H3>
<PRE>
public <A HREF="../../../coins/ir/hir/HirSeq.html" title="interface in coins.ir.hir">HirSeq</A> <B>hirSeq</B>(<A HREF="../../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pChild1)</PRE>
<DL>
<DD>hirSeq Make an HirSeq node that have some definite number of
  children.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pChild1</CODE> - Child 1 HIR node.
<DT><B>Returns:</B><DD>HirSeq with one child.</DL>
</DD>
</DL>
<HR>

<A NAME="hirSeq(coins.ir.hir.HIR, coins.ir.hir.HIR, coins.ir.hir.HIR)"><!-- --></A><H3>
hirSeq</H3>
<PRE>
public <A HREF="../../../coins/ir/hir/HirSeq.html" title="interface in coins.ir.hir">HirSeq</A> <B>hirSeq</B>(<A HREF="../../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pChild1,
                     <A HREF="../../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pChild2,
                     <A HREF="../../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pChild3)</PRE>
<DL>
<DD>hirSeq Make an HirSeq node that have some definite number of
  children.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pChild1</CODE> - Child 1 HIR node.<DD><CODE>pChild2</CODE> - Child 2 HIR node.<DD><CODE>pChild3</CODE> - Child 3 HIR node.
<DT><B>Returns:</B><DD>HirSeq with 3 children.</DL>
</DD>
</DL>
<HR>

<A NAME="setDataStmt(coins.ir.hir.Exp, coins.ir.hir.Exp)"><!-- --></A><H3>
setDataStmt</H3>
<PRE>
public <A HREF="../../../coins/ir/hir/SetDataStmt.html" title="interface in coins.ir.hir">SetDataStmt</A> <B>setDataStmt</B>(<A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pVariable,
                               <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pValueExp)</PRE>
<DL>
<DD>setDataStmt
 Make the statement that sets initial value or a list of
 initial values (pValueExp) to a variable (pVariable).
 The value(s) may be set at loading time (ahead of execution time)
 depending on execution environment.
 pVariable is the name of a scalar variable, an array variable,
 or a structure variable. If pVariable is not a scalar variable,
 pValueExp may be a list expression generated by expListExp method or
 a repeat specification generated by expRepeat method.
 pVariable is an l-value expression that may be a qualified
 expression or an array element. The qualified expression may
 appear to set initial values to elements of RegionType variable.
 The array element may appear in HIR expressions corresponding to
 Fortran DATA statement.
 If pVariable is an instance of Var, then a copy of pValueExp
 is set as the initial value of pvariable in the symbol table.
 pValueExp or elements of pValueExp should be constant value.
 See get, getWithRepeat, set methods of ExpListExp.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pVariable</CODE> - Variable to which initial value is to be set.<DD><CODE>pValueExp</CODE> - Value or list of values to be set to pVariable.
<DT><B>Returns:</B><DD>the statement representing initail value setting.</DL>
</DD>
</DL>
<HR>

<A NAME="expList(java.util.List)"><!-- --></A><H3>
expList</H3>
<PRE>
public <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A> <B>expList</B>(java.util.List&nbsp;pList)</PRE>
<DL>
<DD>expList
 Make an expression representing a list of expressions,
 that is, make an instance of ExpListExp.
 The resultant list can be treated as an instance of Exp.
 Its elements may be an expression made by expRepeat method.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pList</CODE> - list of expressions.
<DT><B>Returns:</B><DD>expression list.</DL>
</DD>
</DL>
<HR>

<A NAME="expRepeat(coins.ir.hir.Exp, coins.ir.hir.Exp)"><!-- --></A><H3>
expRepeat</H3>
<PRE>
public <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A> <B>expRepeat</B>(<A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pValue,
                     <A HREF="../../../coins/ir/hir/Exp.html" title="interface in coins.ir.hir">Exp</A>&nbsp;pCount)</PRE>
<DL>
<DD>expRepeat
 Make an expression representing a list of expressions
 of the same value.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pValue</CODE> - Expression representing a value to be repeated.<DD><CODE>pCount</CODE> - Specifies the number of repeat count.
<DT><B>Returns:</B><DD>repetition specification.</DL>
</DD>
</DL>
<HR>

<A NAME="setChildren(coins.ir.IR, coins.ir.IR)"><!-- --></A><H3>
setChildren</H3>
<PRE>
public void <B>setChildren</B>(<A HREF="../../../coins/ir/IR.html" title="interface in coins.ir">IR</A>&nbsp;p1,
                        <A HREF="../../../coins/ir/IR.html" title="interface in coins.ir">IR</A>&nbsp;p2)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setChildren(coins.ir.IR, coins.ir.IR, coins.ir.IR)"><!-- --></A><H3>
setChildren</H3>
<PRE>
public void <B>setChildren</B>(<A HREF="../../../coins/ir/IR.html" title="interface in coins.ir">IR</A>&nbsp;p1,
                        <A HREF="../../../coins/ir/IR.html" title="interface in coins.ir">IR</A>&nbsp;p2,
                        <A HREF="../../../coins/ir/IR.html" title="interface in coins.ir">IR</A>&nbsp;p3)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="hirNodeClone()"><!-- --></A><H3>
hirNodeClone</H3>
<PRE>
public <A HREF="../../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A> <B>hirNodeClone</B>()</PRE>
<DL>
<DD>Make a copy of this HIR node
 without copying children.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the copy of this node with null children.</DL>
</DD>
</DL>
<HR>

<A NAME="getSourceNode1()"><!-- --></A><H3>
getSourceNode1</H3>
<PRE>
public <A HREF="../../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A> <B>getSourceNode1</B>()</PRE>
<DL>
<DD>getSourceNode1
  Get the 1st source operand node of "this" node where the
  source is an operand used/refered in "this" operation.
  See getSourceNode1 of HIR interface and LIR interface.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>1st source operand of "this" node,
      return null if "this" has no source operand 1.
      If "this" is HIR node, its child 1 is returned.
      If "this" is LIR node, the node computing its operand 1
      is returned; If there is no such node, null is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="getSourceNode2()"><!-- --></A><H3>
getSourceNode2</H3>
<PRE>
public <A HREF="../../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A> <B>getSourceNode2</B>()</PRE>
<DL>
<DD>getSourceNode2
  Get the 2nd source operand node of "this" node.
  Other matters and conditions are just like those of getSourceNode1.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>2nd source operand of "this" node.
      return null if "this" has no 2nd source operand.</DL>
</DD>
</DL>
<HR>

<A NAME="getSourceNode(int)"><!-- --></A><H3>
getSourceNode</H3>
<PRE>
public <A HREF="../../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A> <B>getSourceNode</B>(int&nbsp;pNumber)</PRE>
<DL>
<DD>getSourceNode
  Get the pNumber-th source operand of "this" node.
  Other matters and conditions are just like those of getSourceNode1.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pNumber</CODE> - 1: source 1, 2: source 2, 3: source 3, ... .
<DT><B>Returns:</B><DD>the pNumber-th source operand of "this" node,
      return null if "this" has no pNumber-th source operand.</DL>
</DD>
</DL>
<HR>

<A NAME="replaceSource1(coins.ir.hir.HIR)"><!-- --></A><H3>
replaceSource1</H3>
<PRE>
public <A HREF="../../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A> <B>replaceSource1</B>(<A HREF="../../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pOperand)</PRE>
<DL>
<DD>replaceSource1
  Replace the source operand 1 of "this" node by pOperand.
  "this" should be a node that can have source operand 1,
  that is, nonleaf node if "this" is HIR node, etc.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pOperand</CODE> - node that take place of source operand 1.</DL>
</DD>
</DL>
<HR>

<A NAME="replaceSource2(coins.ir.hir.HIR)"><!-- --></A><H3>
replaceSource2</H3>
<PRE>
public <A HREF="../../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A> <B>replaceSource2</B>(<A HREF="../../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pOperand)</PRE>
<DL>
<DD>replaceSource2
  Replace the source operand 2 of "this" node by pOperand.
  Other matters and conditions are just like those of
  replaceSource1.
  "this" should be a node that can have source operand 2.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pOperand</CODE> - node that take place of source operand 2.</DL>
</DD>
</DL>
<HR>

<A NAME="replaceSource(int, coins.ir.IR)"><!-- --></A><H3>
replaceSource</H3>
<PRE>
public <A HREF="../../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A> <B>replaceSource</B>(int&nbsp;pNumber,
                         <A HREF="../../../coins/ir/IR.html" title="interface in coins.ir">IR</A>&nbsp;pOperand)</PRE>
<DL>
<DD>replaceSource
  Replace pNumber-th source operand of "this" node by pOperand.
  Other matters and conditions are just like those of
  replaceSource1.
  "this" should be a node that can have source operand,
  that is, nonleaf node if "this" is HIR node, etc.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pNumber</CODE> - 1: source 1, 2: source 2, 3: source 3, ... .<DD><CODE>pOperand</CODE> - node that take place of source operand.</DL>
</DD>
</DL>
<HR>

<A NAME="setChild1(coins.ir.IR)"><!-- --></A><H3>
setChild1</H3>
<PRE>
public void <B>setChild1</B>(<A HREF="../../../coins/ir/IR.html" title="interface in coins.ir">IR</A>&nbsp;p1)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setChild2(coins.ir.IR)"><!-- --></A><H3>
setChild2</H3>
<PRE>
public void <B>setChild2</B>(<A HREF="../../../coins/ir/IR.html" title="interface in coins.ir">IR</A>&nbsp;p2)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setParent(coins.ir.IR)"><!-- --></A><H3>
setParent</H3>
<PRE>
public void <B>setParent</B>(<A HREF="../../../coins/ir/IR.html" title="interface in coins.ir">IR</A>&nbsp;pParent)</PRE>
<DL>
<DD>setParent
  Set the parent of this node as pParent.
  This method should be used carefully so that consistency is kept.
  It is not recommended to use this method except in
  the methods built-in in coins/ir, coins/ir/hir, coins/ir/lir.
  Almost all HIR nodes has parent but some LIR node has no parent
  in which case, setParent will have no effect.
  (LIRTreeList, LIRTree have no parent.)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pParent</CODE> - node to be set as parent of this node.</DL>
</DD>
</DL>
<HR>

<A NAME="isTree()"><!-- --></A><H3>
isTree</H3>
<PRE>
public boolean <B>isTree</B>()</PRE>
<DL>
<DD>isTree
  Test if this does not violates tree structure, that is,
  detect node adherence in branches and
  handshake miss in parent-child relation.
  Issues message if some node is encountered twice in
  the process of traversing this subtree.
  If there is duplicated label definition, then return false. //##60
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true if this a tree else return false.</DL>
</DD>
</DL>
<HR>

<A NAME="checkLinkage(java.lang.String)"><!-- --></A><H3>
checkLinkage</H3>
<PRE>
public void <B>checkLinkage</B>(java.lang.String&nbsp;pCheckName)</PRE>
<DL>
<DD>Check parent-child linkage if debug level (ioRoot.dbgHir.getLevel())
 is greater than 0. If the linkage is incorrect, issue message.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pCheckName</CODE> - name of HIR modification operation.</DL>
</DD>
</DL>
<HR>

<A NAME="subpIterator()"><!-- --></A><H3>
subpIterator</H3>
<PRE>
public java.util.Iterator <B>subpIterator</B>()</PRE>
<DL>
<DD>subpIterator
  Make an iterator that traverses all subprogram definitions
  in the current compile unit.
  Sequence of SubpDefinition will be get by using next()
  of the iterator successively.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the iterator to traverse subprogram definitions.</DL>
</DD>
</DL>
<HR>

<A NAME="toStringShort()"><!-- --></A><H3>
toStringShort</H3>
<PRE>
public java.lang.String <B>toStringShort</B>()</PRE>
<DL>
<DD>toStringShort
  Get text string of this node showing node name and index only.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../coins/ir/IR.html#toStringShort()">toStringShort</A></CODE> in interface <CODE><A HREF="../../../coins/ir/IR.html" title="interface in coins.ir">IR</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="toStringDetail()"><!-- --></A><H3>
toStringDetail</H3>
<PRE>
public java.lang.String <B>toStringDetail</B>()</PRE>
<DL>
<DD>toStringDetail
  Get text string of this node showing detail information.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="toStringWithChildren()"><!-- --></A><H3>
toStringWithChildren</H3>
<PRE>
public java.lang.String <B>toStringWithChildren</B>()</PRE>
<DL>
<DD>toStringWithChildren
 Get the string of this node and its children traversing the children
 in depth-first order.
 The result is shown in compact form.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the string of this node and its children.</DL>
</DD>
</DL>
<HR>

<A NAME="getIndentSpace(int)"><!-- --></A><H3>
getIndentSpace</H3>
<PRE>
public java.lang.String <B>getIndentSpace</B>(int&nbsp;pIndent)</PRE>
<DL>
<DD>getIndentSace
  Get a sequence of spaces specified by pIndent.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pIndent</CODE> - number of spaces to be generated.
<DT><B>Returns:</B><DD>a string of spaces.</DL>
</DD>
</DL>
<HR>

<A NAME="setIndexNumberToAllNodes(int, boolean)"><!-- --></A><H3>
setIndexNumberToAllNodes</H3>
<PRE>
public int <B>setIndexNumberToAllNodes</B>(int&nbsp;pStartNumber,
                                    boolean&nbsp;pResetSymIndex)</PRE>
<DL>
<DD>Set index number to all nodes and if pResetSymIndex is true,
 reset Sym index by resetFlowAnalInf for FlowAnalSym nodes.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pStartNumber</CODE> - <DD><CODE>pResetSymIndex</CODE> - true if resetFlowAnalInf is to be done.
<DT><B>Returns:</B><DD>the largest index number set to nodes.</DL>
</DD>
</DL>
<HR>

<A NAME="getFlowAnalSym()"><!-- --></A><H3>
getFlowAnalSym</H3>
<PRE>
public <A HREF="../../../coins/sym/FlowAnalSym.html" title="interface in coins.sym">FlowAnalSym</A> <B>getFlowAnalSym</B>()</PRE>
<DL>
<DD>getFlowAnalSym
  Get the flow analysis symbol assigned to this node if it is given.
  FlowAnalSym is either Var, Reg, or ExpId.  (See coins.sym.FlowAnalSym.)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the flow analysis symbol assigned to this node,
      or return null if it is not assigned.</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public java.lang.String <B>toString</B>()</PRE>
<DL>
<DD>toString
  Get text representation of this node
  without traversing children.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the text string representing the node
      including operation name, type, node index,
      and symbol name if this represents a symbol or constant.</DL>
</DD>
</DL>
<HR>

<A NAME="getIrName()"><!-- --></A><H3>
getIrName</H3>
<PRE>
public java.lang.String <B>getIrName</B>()</PRE>
<DL>
<DD>getIrName
  Get operation name and node index
  to display node in compact form for flow analysis, debug, etc.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setIndex(int)"><!-- --></A><H3>
setIndex</H3>
<PRE>
public void <B>setIndex</B>(int&nbsp;pIndex)</PRE>
<DL>
<DD>setIndex
  Set an index number to "this" node.
  (The index number is used to refer the node in data flow analysis.)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pIndex</CODE> - the index number to be assigned to "this" node.</DL>
</DD>
</DL>
<HR>

<A NAME="copyInfListFrom(coins.ir.hir.HIR)"><!-- --></A><H3>
copyInfListFrom</H3>
<PRE>
public void <B>copyInfListFrom</B>(<A HREF="../../../coins/ir/hir/HIR.html" title="interface in coins.ir.hir">HIR</A>&nbsp;pFromHir)</PRE>
<DL>
<DD>Copy the contents of InfList attached to pFromHir
 to the InfList of this node. If this node has Inf
 of the same kind as that of pFromHir, then it is
 replaced by that of pFromHir. If this node has Inf
 that is not included in pFromHir, then the Inf
 remains unchanged.
 If pFromHir has no Inf, then do nothing.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pFromHir</CODE> - HIR node that may have InfList.</DL>
</DD>
</DL>
<HR>

<A NAME="getInfString()"><!-- --></A><H3>
getInfString</H3>
<PRE>
public java.lang.String <B>getInfString</B>()</PRE>
<DL>
<DD>Get the string image of Inf.
 If there is no Inf, return "".
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the string image of Inf.</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../coins/ir/hir/FunctionExp.html" title="interface in coins.ir.hir"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../coins/ir/hir/HIR0.html" title="interface in coins.ir.hir"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="HIR.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
