/*
 *  This software may only be used by you under license from AT&T Corp.
 *  ("AT&T").  A copy of AT&T's Source Code Agreement is available at
 *  AT&T's Internet website having the URL:
 *  <http://www.research.att.com/sw/tools/graphviz/license/source.html>
 *  If you received this software without first entering into a license
 *  with AT&T, you have an infringing copy of this software and cannot use
 *  it without violating AT&T's intellectual property rights.
 */

package att.grappa;

import java.io.*;
import java.util.*;
import java.awt.*;

/**
 * This class describes a subgraph, which can consist of
 * nodes, edges and other subgraphs.  Note: The topmost
 * or root subgraph is the entire graph (the Graph object), which is
 * an extension of this class.
 *
 * @version 1.1, 30 Sep 1999; Copyright 1996 - 1999 by AT&T Corp.
 * @author  <a href="mailto:john@research.att.com">John Mocenigo</a>, <a href="http://www.research.att.com">Research @ AT&T Labs</a>
 * @see Graph
 */
public class Subgraph extends Element implements Shape
{
  /**
   * Default graph name prefix used by setName().
   *
   * @see Subgraph#setName()
   */
  public final static String defaultNamePrefix = "G";

  // node, edge and graph dictionaries for this subgraph
  private Hashtable nodedict = null;
  private Hashtable edgedict = null;
  private Hashtable graphdict = null;

  // default node attributes
  private Hashtable nodeAttributes = null;

  // default edge attributes
  private Hashtable edgeAttributes = null;

  // for cluster subgraphs
  private boolean cluster = false;

  /**
   * This constructor is needed by the Graph constructor
   */
  Subgraph() {
    //super();
    cluster = true; // the root is a cluster subgraph
  }

  /**
   * Use this constructor when creating a subgraph within a subgraph.
   *
   * @param subg the parent subgraph.
   * @param name the name of this subgraph.
   */
  public Subgraph(Subgraph subg, String name) {
    super(Grappa.SUBGRAPH,subg);
    setName(name);

    Enumeration enum = subg.getNodeAttributePairs();
    while(enum.hasMoreElements()) {
      setNodeAttribute((Attribute)enum.nextElement());
    }
    enum = subg.getEdgeAttributePairs();
    while(enum.hasMoreElements()) {
      setEdgeAttribute((Attribute)enum.nextElement());
    }
    enum = subg.getLocalAttributePairs();
    while(enum.hasMoreElements()) {
      setAttribute((Attribute)enum.nextElement());
    }
  }

  /**
   * Use this constructor when creating a subgraph within a subgraph
   * with an automatically generated name.
   *
   * @param subg the parent subgraph.
   * @see Subgraph#setName()
   */
  public Subgraph(Subgraph subg) {
    this(subg,(String)(null));
  }

  /**
   * Check if this element is a subgraph.
   * Useful for testing the subclass type of a Element object.
   *
   * @return true if this object is a Subgraph.
   */
  public boolean isSubgraph() {
    return(true);
  }

  /**
   * Get the type of this element.
   * Useful for distinguishing Element objects.
   *
   * @return the class variable constant Grappa.SUBGRAPH.
   * @see Grappa
   */
  public int getType() {
    return(Grappa.SUBGRAPH);
  }

  /**
   * Generates and sets the name for this subgraph.
   * The generated name is the concatenation of the
   * Subgraph.defaultNamePrefix with the numeric
   * id of this subgraph Instance.
   * Implements the abstract Element method.
   *
   * @see Element#getId()
   */
  void setName() {
    String oldName = name;
    
    while(true) {
      name = Subgraph.defaultNamePrefix + getId() + "_" + System.currentTimeMillis();
      if(getGraph().findSubgraphByName(name) == null) {
	break;
      }
    }

    // update subgraph graph dictionary
    if(getSubgraph() != null) {
      if(oldName != null) {
	getSubgraph().removeGraph(oldName);
      }
      getSubgraph().addSubgraph(this);
    }
  }

  /**
   * Sets the subgraph name to a copy of the supplied argument.
   * When the argument is null, setName() is called.
   * When the name is not unique or when the name has the same format as
   * that generated by setName(), a IllegalArgumentException is thrown.
   *
   * @param newName the new name for the subgraph.
   * @see Subgraph#setName()
   */
  public void setName(String newName) throws IllegalArgumentException {
    if(newName == null) {
      setName();
      return;
    }

    String oldName = name;

    // test if the new name is the same as the old name (if any)
    if(oldName != null && oldName.equals(newName)) {
      return;
    }

    // is name unique?
    if(getGraph().findSubgraphByName(newName) != null) {
      throw new IllegalArgumentException("graph name (" + newName + ") is not unique");
    }
    name = newName;

    if(name.startsWith("cluster")) {
      cluster = true;
    }

    // update subgraph graph dictionary
    if(getSubgraph() != null) {
      if(oldName != null) {
	getSubgraph().removeGraph(oldName);
      }
      getSubgraph().addSubgraph(this);
    }
  }

  /**
   * Check if the subgraph is a cluster subgraph.
   *
   * @return true, if the graph is a cluster subgraph.
   */
  public boolean isCluster() {
    return cluster;
  }

  /**
   * Check if the subgraph is the root of the graph.
   *
   * @return true, if the graph is the root of the graph.
   */
  public boolean isRoot() {
    return (this == (Subgraph)getGraph());
  }

  /**
   * Gets the subgraph-specific default for the requested node attribute.
   *
   * @param key the name of the node attribute pair to be retrieved.
   * @return the requested Attribute object or null if not found.
   */
  public Attribute getNodeAttribute(String key) {
    if(nodeAttributes == null) return(null);
    return((Attribute)(nodeAttributes.get(key)));
  }

  /**
   * Gets an enumeration of the subgraph-specific node attribute keys
   *
   * @return an enumeration of String objects.
   */
  public Enumeration getNodeAttributeKeys() {
    if(nodeAttributes == null) return Grappa.emptyEnumeration.elements();
    return(nodeAttributes.keys());
  }

  /**
   * Gets an enumeration of the subgraph-specific node attributes
   *
   * @return an enumeration of Attribute objects.
   */
  public Enumeration getNodeAttributePairs() {
    if(nodeAttributes == null) return Grappa.emptyEnumeration.elements();
    return(nodeAttributes.elements());
  }

  /**
   * Gets an enumeration of the subgraph-specific edge attribute keys
   *
   * @return an enumeration of String objects.
   */
  public Enumeration getEdgeAttributeKeys() {
    if(edgeAttributes == null) return Grappa.emptyEnumeration.elements();
    return(edgeAttributes.keys());
  }

  /**
   * Gets an enumeration of the subgraph-specific edge attributes
   *
   * @return an enumeration of Attribute objects.
   */
  public Enumeration getEdgeAttributePairs() {
    if(edgeAttributes == null) return Grappa.emptyEnumeration.elements();
    return(edgeAttributes.elements());
  }

  /**
   * Sets the subgraph-specific default for the specified node attribute.
   * If the attribute is not from the parent subgraph, then
   * setNodeAttribute(attr.getName(), attr.getValue()) is called.
   *
   * @param attr the node Attribute object to set as a default.
   * @return the Attribute object previously stored for this attribute, if any.
   * @see Subgraph#setNodeAttribute(java.lang.String, java.lang.String)
   */
  public String setNodeAttribute(Attribute attr) {
    if(attr == null) return null;
    if(nodeAttributes == null) {
      nodeAttributes = new Hashtable();
    }
    // check to see if attr is being passed down the subgraph chain
    Subgraph sg = getSubgraph();
    Attribute prntAttr = (sg==null)?null:sg.getNodeAttribute(attr.getName());
    if(attr != prntAttr) {
      // it's not, so use the other method
      return setNodeAttribute(attr.getName(),attr.getValue());
    }
    String oldValue = null;
    Attribute newAttr = null;
    Attribute crntAttr =  getNodeAttribute(attr.getName());
    if(attr == crntAttr) return attr.getValue();
    if(crntAttr == null) {
      if(attr.getValue() == null) {
	return null;
      }
      nodeAttributes.put(attr.getName(),crntAttr = attr);
      //System.err.println("Adding passthru1 node attr("+attr.getName()+","+attr.getValue()+") to "+getName());
      // it's a pass down, so no need to set observers
    } else {
      oldValue = crntAttr.getValue();
      crntAttr.setChanged(); // so notifyObservers is sure to be called
      // it's a pass down, so pass it down
      nodeAttributes.put(attr.getName(),attr);
      //System.err.println("Adding passthru2 node attr("+attr.getName()+","+attr.getValue()+") to "+getName());
      // this is why we need notifyObservers called
      newAttr = attr;
    }
    // this should only be possible when "else" above has occurred
    if(crntAttr.hasChanged()) crntAttr.notifyObservers(newAttr);
    return oldValue;
  }

  /**
   * Sets the subgraph-specific default using the specified name/value
   * pair.  A new attribute will be created if needed.
   *
   * @param name the node attribute name
   * @param value the node attribute value
   * @return the Attribute object previously stored for this attribute, if any.
   */
  public String setNodeAttribute(String name, String value) {
    if(nodeAttributes == null) {
      nodeAttributes = new Hashtable();
    }
    if(name == null) {
      throw new IllegalArgumentException("cannot set an attribute using a null name");
    }
    // check to see if this name value is the same as the parent default
    Subgraph sg = getSubgraph();
    Attribute prntAttr = (sg==null)?null:sg.getNodeAttribute(name);
    //if(prntAttr != null && value != null ) {
    //System.err.println("check new node attr ("+name+","+value+") against ("+prntAttr.getName()+","+prntAttr.getValue()+")");
    //if(name.equals(prntAttr.getName()) && value.equals(prntAttr.getValue())) {
    // it is, so call other form
    //System.err.println("set node attr to same as default ("+name+","+value+")");
    //return setNodeAttribute(prntAttr);
    //}
    //}
    String oldValue = null;
    Attribute crntAttr =  getNodeAttribute(name);
    if(crntAttr == null || crntAttr == prntAttr) {
      if(value == null) {
	return null;
      }
      nodeAttributes.put(name,(crntAttr = new Attribute(name,value)));
      //System.err.println("adding new node attr("+name+","+value+") to "+getName());
      /*
       * just concerned with subgraphs that share the same default (or null)
       * and nodes that do not have a local attribute
       */
      Subgraph subg = null;
      Attribute nsub = null;
      Node node = null;
      Enumeration enumNode = null;
      Enumeration enumGraph = elements(Grappa.SUBGRAPH);
      while(enumGraph.hasMoreElements()) {
	subg = (Subgraph)enumGraph.nextElement();
	if(this == subg || (nsub = subg.getNodeAttribute(name)) == null || nsub == prntAttr) {
	  enumNode = subg.nodeElements();
	  while(enumNode.hasMoreElements()) {
	    node = (Node)enumNode.nextElement();
	    if(node.getAppObject() != null && node.getLocalAttribute(name) == null) {
	      node.getAppObject().iSpy(crntAttr,prntAttr);
	    }
	  }
	}
      }
    } else {
      oldValue = crntAttr.getValue();
      if(value == null) {
	if(prntAttr == null) {
	  removeNodeAttribute(name);
	  return oldValue;
	} else {
	  return setNodeAttribute(prntAttr);
	}
      } else {
	crntAttr.setValue(value);
	//System.err.println("changing node attr("+name+","+value+") in "+getName());
      }
    }
    if(crntAttr.hasChanged()) crntAttr.notifyObservers();
    return oldValue;
  }

  /*
   * Remove named default node attribute (assumes there is no default in
   * the subgraph chain).
   *
   * @param name the name of the attribute to remove
   */
  private void removeNodeAttribute(String name) {
    if(name == null || nodeAttributes == null) return;
    //System.err.println("Remove '" + name + "' from " + getName());
    Attribute attr = (Attribute)nodeAttributes.remove(name);
    if(attr == null) return;
    attr.setValue("");
    if(attr.hasChanged()) attr.notifyObservers();
    attr.deleteObservers();
  }

  /**
   * Sets the subgraph-specific default for the specified edge attribute.
   * If the attribute is not from the parent subgraph, then
   * setEdgeAttribute(attr.getName(), attr.getValue()) is called.
   *
   * @param attr the edge attribute pair to set.
   * @return the attribute pair previously stored for this attribute.
   * @see Subgraph#setEdgeAttribute(java.lang.String, java.lang.String)
   */
  public String setEdgeAttribute(Attribute attr) {
    if(attr == null) return null;
    if(edgeAttributes == null) {
      edgeAttributes = new Hashtable();
    }
    // check to see if attr is being passed down the subgraph chain
    Subgraph sg = getSubgraph();
    Attribute prntAttr = (sg==null)?null:sg.getEdgeAttribute(attr.getName());
    if(attr != prntAttr) {
      // it's not, so use the other method
      return setEdgeAttribute(attr.getName(),attr.getValue());
    }
    String oldValue = null;
    Attribute newAttr = null;
    Attribute crntAttr = getEdgeAttribute(attr.getName());
    if(attr == crntAttr) return attr.getValue();
    if(crntAttr == null) {
      if(attr.getValue() == null) {
	return null;
      }
      edgeAttributes.put(attr.getName(),crntAttr = attr);
      //System.err.println("Adding passthru1 edge attr("+attr.getName()+","+attr.getValue()+") to "+getName());
      // it's a pass down, so no need to set observers
    } else {
      oldValue = crntAttr.getValue();
      crntAttr.setChanged(); // so notifyObservers is sure to be called
      // it's a pass down, so pass it down
      edgeAttributes.put(attr.getName(),attr);
      //System.err.println("Adding passthru2 edge attr("+attr.getName()+","+attr.getValue()+") to "+getName());
      newAttr = attr;
    }
    // this should only be possible when "else" above has occurred
    if(crntAttr.hasChanged()) crntAttr.notifyObservers(newAttr);
    return oldValue;
  }

  /**
   * Sets the subgraph-specific default using the specified name/value
   * pair.  A new attribute will be created if needed.
   *
   * @param name the edge attribute name
   * @param value the edge attribute value
   * @return the attribute pair previously stored for this attribute.
   */
  public String setEdgeAttribute(String name, String value) {
    if(edgeAttributes == null) {
      edgeAttributes = new Hashtable();
    }
    if(name == null) {
      throw new IllegalArgumentException("cannot set an attribute using a null name");
    }
    // check to see if this name value is the same as the parent default
    Subgraph sg = getSubgraph();
    Attribute prntAttr = (sg==null)?null:sg.getEdgeAttribute(name);
    //if(prntAttr != null && value != null ) {
    //if(name.equals(prntAttr.getName()) && value.equals(prntAttr.getValue())) {
    // it is, so call other form
    //return setEdgeAttribute(prntAttr);
    //}
    //}
    String oldValue = null;
    Attribute crntAttr =  getEdgeAttribute(name);
    if(crntAttr == null || crntAttr == prntAttr) {
      if(value == null) {
	return null;
      }
      edgeAttributes.put(name,(crntAttr = new Attribute(name,value)));
      //System.err.println("adding new edge attr("+name+","+value+") to "+getName());
      /*
       * just concerned with subgraphs that share the same default (or null)
       * and edges that do not have a local attribute
       */
      Subgraph subg = null;
      Attribute esub = null;
      Edge edge = null;
      Enumeration enumEdge = null;
      Enumeration enumGraph = elements(Grappa.SUBGRAPH);
      while(enumGraph.hasMoreElements()) {
	subg = (Subgraph)enumGraph.nextElement();
	if(this == subg || (esub = subg.getEdgeAttribute(name)) == null || esub == prntAttr) {
	  enumEdge = subg.edgeElements();
	  while(enumEdge.hasMoreElements()) {
	    edge = (Edge)enumEdge.nextElement();
	    if(edge.getAppObject() != null && edge.getLocalAttribute(name) == null) {
	      edge.getAppObject().iSpy(crntAttr,prntAttr);
	    }
	  }
	}
      }
    } else {
      oldValue = crntAttr.getValue();
      if(value == null) {
	if(prntAttr == null) {
	  removeEdgeAttribute(name);
	  return oldValue;
	} else {
	  return setEdgeAttribute(prntAttr);
	}
      } else {
	crntAttr.setValue(value);
	//System.err.println("changing edge attr("+name+","+value+") in "+getName());
      }
    }
    if(crntAttr.hasChanged()) crntAttr.notifyObservers();
    return oldValue;
  }

  /*
   * Remove named default edge attribute (assumes there is no default in
   * the subgraph chain).
   *
   * @param name the name of the attribute to remove
   */
  private void removeEdgeAttribute(String name) {
    if(name == null || edgeAttributes == null) return;
    Attribute attr = (Attribute)edgeAttributes.remove(name);
    if(attr == null) return;
    attr.setValue("");
    if(attr.hasChanged()) attr.notifyObservers();
    attr.deleteObservers();
  }

  /**
   * Sets the subgraph-specific default for the specified graph attribute.
   * If the attribute is not from the parent subgraph, then
   * setAttribute(attr.getName(), attr.getValue()) is called.
   *
   * @param attr the graph attribute pair to set.
   * @return the attribute pair previously stored for this attribute.
   * @see Subgraph#setAttribute(java.lang.String, java.lang.String)
   */
  public String setAttribute(Attribute attr) {
    if(attr == null) return null;
    if(attributes == null) {
      attributes = new Hashtable();
    }
    // check to see if attr is being passed down the subgraph chain
    Subgraph sg = getSubgraph();
    Attribute prntAttr = (sg==null)?null:sg.getLocalAttribute(attr.getName());
    if(attr != prntAttr) {
      // it's not, so use the other method
      return setAttribute(attr.getName(),attr.getValue());
    }
    String oldValue = null;
    Attribute newAttr = null;
    Attribute crntAttr =  getLocalAttribute(attr.getName());
    if(attr == crntAttr) return attr.getValue();
    if(crntAttr == null) {
      if(attr.getValue() == null) {
	return null;
      }
      attributes.put(attr.getName(),crntAttr = attr);
      //System.err.println("Adding passthru1 graph attr("+attr.getName()+","+attr.getValue()+") to "+getName());
      // it's a pass down, so no need to set observers
    } else {
      oldValue = crntAttr.getValue();
      crntAttr.setChanged(); // so notifyObservers is sure to be called
      // it's a pass down, so pass it down
      attributes.put(attr.getName(),attr);
      //System.err.println("Adding passthru2 graph attr("+attr.getName()+","+attr.getValue()+") to "+getName());
      // this is why we need notifyObservers called
      newAttr = attr;
    }
    // this should only be possible when "else" above has occurred
    if(crntAttr.hasChanged()) crntAttr.notifyObservers(newAttr);
    return oldValue;
  }

  /**
   * Sets the subgraph-specific default using the specified name/value
   * pair.  A new attribute will be created if needed.
   * Overrides Element setAttribute(String,String).
   *
   * @param name the graph attribute name
   * @param value the graph attribute value
   * @return the attribute pair previously stored for this attribute.
   */
  public String setAttribute(String name, String value) {
    if(attributes == null) {
      attributes = new Hashtable();
    }
    if(name == null) {
      throw new IllegalArgumentException("cannot set an attribute using a null name");
    }
    // check to see if this name value is the same as the parent default
    Subgraph sg = getSubgraph();
    Attribute prntAttr = (sg==null)?null:sg.getLocalAttribute(name);
    //if(prntAttr != null && value != null ) {
    //if(name.equals(prntAttr.getName()) && value.equals(prntAttr.getValue())) {
    // it is, so call other form
    //return setAttribute(prntAttr);
    //}
    //}
    String oldValue = null;
    Attribute crntAttr = getLocalAttribute(name);
    if(crntAttr == null || crntAttr == prntAttr) {
      if(value == null) {
	return null;
      }
      attributes.put(name,(crntAttr = new Attribute(name,value)));
      //System.err.println("adding new graph attr("+name+","+value+") to "+getName());
      Enumeration enum = elements(Grappa.SUBGRAPH);
      while(enum.hasMoreElements()) {
	sg = (Subgraph)enum.nextElement();
	if(sg.getAppObject() != null) {
	  sg.getAppObject().iSpy(crntAttr,prntAttr);
	}
      }
      /*
       * just concerned with subgraphs that share the same default (or null)
       * and do not have a local attribute
       */
      Subgraph subg = null;
      Attribute gsub = null;
      Enumeration enumGraph = elements(Grappa.SUBGRAPH);
      while(enumGraph.hasMoreElements()) {
	subg = (Subgraph)enumGraph.nextElement();
	if(this == subg || (((gsub = subg.getSubgraph().getLocalAttribute(name)) == null || gsub == prntAttr) && subg.getLocalAttribute(name) == null)) {
	  if(subg.getAppObject() != null) {
	    subg.getAppObject().iSpy(crntAttr,prntAttr);
	  }
	}
      }
    } else {
      oldValue = crntAttr.getValue();
      if(value == null) {
	if(prntAttr == null) {
	  setAttribute(name,null);
	  return oldValue;
	} else {
	  return setAttribute(prntAttr);
	}
      } else {
	crntAttr.setValue(value);
	//System.err.println("changing graph attr("+name+","+value+") in "+getName());
      }
    }
    if(crntAttr.hasChanged()) {
      crntAttr.notifyObservers();
    }
    return oldValue;
  }

  /**
   * Gets the subgraph-specific default for the requested edge attribute.
   *
   * @param key the name of the edge attribute pair to be retrieved.
   * @return the requested attribute pair or null if not found.
   */
  public Attribute getEdgeAttribute(String key) {
    if(edgeAttributes == null) return(null);
    return((Attribute)(edgeAttributes.get(key)));
  }

  /**
   * Prints an ascii description of each graph element to the supplied stream.
   *
   * @param output the OutputStream for writing the graph description.
   */
  public void printSubgraph(PrintWriter out) {
    Graph graph = getGraph();
    String indent = new String(graph.getIndent());

    if(getSubgraph() == null) {
      // this subgraph is the root
      out.println(indent + (graph.isStrict()?"strict ":"") + (graph.isDirected()?"digraph":"graph") + " " + graph.toString() + " {");
    } else if(getName().startsWith(Grappa.ANONYMOUS_PREFIX)) {
      out.println(indent + "{");
    } else {
      out.println(indent + "subgraph " + this.toString() + " {");
    }

    graph.incrementIndent();

    printDflt(out,Grappa.SUBGRAPH);
    printDflt(out,Grappa.NODE);
    printDflt(out,Grappa.EDGE);

    if(graphdict != null && !graphdict.isEmpty()) {
      Enumeration elems = graphdict.elements();
      while(elems.hasMoreElements()) {
	((Subgraph)(elems.nextElement())).printSubgraph(out);
      }
    }

    if(nodedict != null && !nodedict.isEmpty()) {
      Enumeration elems = nodedict.elements();
      while(elems.hasMoreElements()) {
	((Node)(elems.nextElement())).printNode(out);
      }
    }

    if(edgedict != null && !edgedict.isEmpty()) {
      Enumeration elems = edgedict.elements();
      while(elems.hasMoreElements()) {
	((Edge)(elems.nextElement())).printEdge(out);
      }
    }

    graph.decrementIndent();

    out.println(indent + "}");
  }

  // print the subgraph default elements
  private void printDflt(PrintWriter out, int type) {
    String indent = new String(getGraph().getIndent());
    Hashtable attr = null;
    String label = null;

    switch(type) {
    case Grappa.SUBGRAPH:
      attr = attributes;
      label = "graph";
      break;
    case Grappa.NODE:
      attr = nodeAttributes;
      label = "node";
      break;
    case Grappa.EDGE:
      attr = edgeAttributes;
      label = "edge";
      break;
    }

    if(attr == null || attr.isEmpty()) {
      getGraph().printError("no " + label + " atrtibutes for " + getName());
      return;
    }

    getGraph().incrementIndent();
    printDfltAttr(out,attr,type,indent + label + " [", indent + "];");
    getGraph().decrementIndent();
  }

  // print the subgraph default element attribute values
  private void printDfltAttr(PrintWriter out, Hashtable dfltAttr, int type, String prefix, String suffix) {
    String indent = new String(getGraph().getIndent());
    String value;
    String key;
    Attribute attr;
    int nbr = 0;
    Enumeration attrs = dfltAttr.elements();
    Subgraph sg = getSubgraph();

    while(attrs.hasMoreElements()) {
      attr = (Attribute)(attrs.nextElement());
      if(attr == null) continue;
      key = attr.getName();
      value = attr.getValue();
      if(!attr.equalsValue(getParentDefault(type,key))) {
	nbr++;
	if(nbr == 1) {
	  out.println(prefix);
	  out.print(indent + key + " = " + canonString(value));
	} else {
	  out.println(",");
	  out.print(indent + key + " = " + canonString(value));
	}
      }
    }
    if(nbr > 0) {
      out.println();
      out.println(suffix);
      out.println();
    }
  }

  // get the parent default attribute value for the specified type and key
  private Attribute getParentDefault(int type, String key) {
    Attribute attr = null;
    Subgraph subg = getSubgraph();
    switch(type) {
    case Grappa.SUBGRAPH:
      while(subg != null && (attr = subg.getLocalAttribute(key)) == null) {
	subg = subg.getSubgraph();
      }
      if(attr == null) {
	attr = getGraph().getGlobalAttribute(Grappa.SUBGRAPH,key);
      }
      return attr;
    case Grappa.NODE:
      while(subg != null && (attr = subg.getNodeAttribute(key)) == null) {
	subg = subg.getSubgraph();
      }
      if(attr == null) {
	attr = getGraph().getGlobalAttribute(Grappa.NODE,key);
      }
      return attr;
    case Grappa.EDGE:
      while(subg != null && (attr = subg.getEdgeAttribute(key)) == null) {
	subg = subg.getSubgraph();
      }
      if(attr == null) {
	attr = getGraph().getGlobalAttribute(Grappa.EDGE,key);
      }
      return attr;
    }
    return null;
  }

  /*
   * Find an Element by name.
   *
   * @param type the type of the element
   * @param name the name of the element
   * @return the found element or null
   *
   * @see Subgraph#findNodeByName(java.lang.String)
   * @see Subgraph#findEdgeByName(java.lang.String)
   * @see Subgraph#findSubgraphByName(java.lang.String)
   */
  private Element findElementByName(int type, String name) {
    if(name == null) {
      return(null);
    }

    return findElementInSubgraphByName(type,name);
  }

  private Element findElementInSubgraphByName(int type, String name) {
    Element elem = null;

    switch(type) {
    case Grappa.NODE:
      if(nodedict != null) elem = (Element)nodedict.get(name);
      break;
    case Grappa.EDGE:
      if(edgedict != null) elem = (Element)edgedict.get(name);
      break;
    case Grappa.SUBGRAPH:
      if(graphdict != null) elem = (Element)graphdict.get(name);
      break;
    }

    if(elem != null || graphdict == null) return elem;

    Enumeration enum = graphdict.elements();
    while(enum.hasMoreElements()) {
      if((elem = ((Subgraph)enum.nextElement()).findElementInSubgraphByName(type,name)) != null) {
	return elem;
      }
    }

    return elem;
  }

  /**
   * Searches current subgraph and, by recursion, descendent subgraphs
   * for the node matching the supplied name.
   *
   * @param nodeName the name of the node to be found.
   * @return the Node matching the name or null, if there is no match.
   */
  public Node findNodeByName(String nodeName) {
    return (Node)findElementByName(Grappa.NODE,nodeName);
  }

  /**
   * Searches current subgraph and, by recursion, descendent subgraphs
   * for the edge matching the supplied name.
   *
   * @param edgeName the name of the edge to be found.
   * @return the Edge matching the name or null, if there is no match.
   */
  public Edge findEdgeByName(String edgeName) {
    return (Edge)findElementByName(Grappa.EDGE,edgeName);
  }

  /**
   * Searches current subgraph and, by recursion, descendent subgraphs
   * for the subgraph matching the supplied name.
   *
   * @param graphName the name of the subgraph to be found.
   * @return the Subgraph matching the name or null, if there is no match.
   */
  public Subgraph findSubgraphByName(String graphName) {
    return (Subgraph)findElementByName(Grappa.SUBGRAPH,graphName);
  }

  /**
   * Creates a new element and adds it to the subgraph's element dictionary.
   * For nodes, the <I>info</I> vector can be null or contains:
   * <ul>
   *   <li> String - name of the node (optional, for automatic name generation)
   * </ul>
   * For edges, the <I>info</I> vector must contain (in this order) at least:
   * <ul>
   *   <li> Node - head node,
   *   <li> String - headport tag (or null),
   *   <li> Node - tail node,
   * </ul>
   * Optionally, the <I>info</I> vector can also contain at its end (in this order):
   * <ul>
   *   <li> String - tailport tag (or null),
   *   <li> String - a key for distinguishing multiple edges between the same nodes (or null),
   * </ul>
   * For subgraphs, the <I>info</I> vector can be null or contains:
   * <ul>
   *   <li> String - name of the subgraph (optional, for automatic name generation)
   * </ul>
   *
   * @param type type of the element to be added
   * @param info a vector specifics for the particular type of element being created
   * @param attrs attributes describing the element to be created
   * @exception InstantiationException whenever element cannot be created
   */
  public Element createElement(int type, Vector info, Vector attrs) throws InstantiationException {
    Element elem = null;

    switch(type) {
    case Grappa.NODE:
      String nodeName = null;
      if(info != null && info.size() >= 1) {
	nodeName = (String)info.firstElement();
      }
      Node node = new Node(this,nodeName);
      if(attrs != null) {
	Enumeration attr_enum = attrs.elements();
	while(attr_enum.hasMoreElements()) {
	  node.setAttribute((Attribute)attr_enum.nextElement());
	}
      }
      elem =  (Element)node;
      break;
    case Grappa.EDGE:
      if(info == null || info.size() < 3) {
	throw new IllegalArgumentException("insufficient info supplied for edge creation");
      }
      Node head = (Node)info.elementAt(0);
      String headPort = (String)info.elementAt(1);
      Node tail = (Node)info.elementAt(2);
      String tailPort = null;
      String key = null;
      if(info.size() > 3) {
	tailPort = (String)info.elementAt(3);
	if(info.size() > 4) {
	  key = (String)info.elementAt(4);
	}
      }
      Edge edge = new Edge(this,tail,tailPort,head,headPort,key);
      if(attrs != null) {
	Enumeration attr_enum = attrs.elements();
	while(attr_enum.hasMoreElements()) {
	  edge.setAttribute((Attribute)attr_enum.nextElement());
	}
      }
      elem =  (Element)edge;
      break;
    case Grappa.SUBGRAPH:
      String subgName = null;
      if(info != null && info.size() >= 1) {
	subgName = (String)info.elementAt(0);
      }
      Subgraph newSubg = new Subgraph(this,subgName);
      if(attrs != null) {
	Enumeration attr_enum = attrs.elements();
	while(attr_enum.hasMoreElements()) {
	  newSubg.setAttribute((Attribute)attr_enum.nextElement());
	}
      }
      elem =  (Subgraph)newSubg;
      break;
    default:
      return null;
    }
    if(elem != null) {
      AppObject.setAppObject(elem);
      if(getGraph().hasDrawObjects()) {
	DrawObject.setDrawObject(elem);
      }
    }
    return elem;
  }

  /**
   * Adds the specified node to the subgraph's Node dictionary.
   *
   * @param newNode the node to be added to the dictionary.
   */
  public void addNode(Node newNode) {
    if(newNode == null) return;
    if(nodedict == null) {
      nodedict = new Hashtable();
    }
    nodedict.put(newNode.getName(),newNode);
  }

  /**
   * Removes the node matching the specified name from the subgraph's Node dictionary.
   *
   * @param nodeName the name of the node to be removed from the dictionary.
   * @return the node that was removed.
   */
  public Node removeNode(String nodeName) {
    if(nodedict == null) return(null);
    return((Node)(nodedict.remove(nodeName)));
  }

  /**
   * Adds the specified edge to the subgraph's Edge dictionary.
   *
   * @param newEdge the edge to be added to the dictionary.
   */
  public void addEdge(Edge newEdge) {
    if(newEdge == null) return;
    if(edgedict == null) {
      edgedict = new Hashtable();
    }
    edgedict.put(newEdge.getName(),newEdge);
  }

  /**
   * Removes the edge matching the specified name from the subgraph's Edge dictionary.
   *
   * @param edgeName the name of the edge to be removed from the dictionary.
   * @return the edge that was removed.
   */
  public Edge removeEdge(String edgeName) {
    if(edgedict == null) return(null);
    return((Edge)(edgedict.remove(edgeName)));
  }

  /**
   * Adds the specified subgraph to the subgraph's graph dictionary.
   *
   * @param newGraph the subgraph to be added to the dictionary.
   */
  public void addSubgraph(Subgraph newGraph) {
    if(newGraph == null) return;
    if(graphdict == null) {
      graphdict = new Hashtable();
    }
    graphdict.put(newGraph.getName(),newGraph);
  }

  /**
   * Removes the subgraph matching the specified name from the
   * subgraph's graph dictionary.
   *
   * @param graphName the name of the subgraph to be removed from the dictionary.
   * @return the subgraph that was removed.
   */
  public Subgraph removeGraph(String graphName) {
    if(graphdict == null) return(null);
    return((Subgraph)(graphdict.remove(graphName)));
  }

  /**
   * Check if the orientation of this subgraph is LR (left-to-right) as opposed
   * to TB (top-to-bottom).
   *
   * @return true if the orientation is left-to-right.
   */
  public boolean isLR() {
    DrawSubgraph drwsbg = (DrawSubgraph)(getDrawObject());
    if(drwsbg == null) {
      Attribute attr = getAttribute("rankdir");

      if(attr == null) return false; // the default
      String value = attr.getValue();
      if(value == null) return false; // the default
      if(value.equals("LR")) return true;
      return false;
    } else {
      return drwsbg.isLR();
    }
  }

  private boolean appObjects = false;
  private boolean drawObjects = false;

  /**
   * Set the AppObject instantiation indicator.
   * The assumption is that if the subgraph has an AppObject, then
   * elements within it do as well.
   */
  void setAppObjects() {
    appObjects = (getAppObject() != null);
    if(appObjects) {
      getGraph().setAppObjectsSomewhere(true);
    } else {
      boolean atLeastOne = false;
      Enumeration enum = getGraph().elements(Grappa.SUBGRAPH);
      while(enum.hasMoreElements()) {
	if(((Subgraph)enum.nextElement()).hasAppObjects()) {
	  atLeastOne = true;
	  break;
	}
      }
      getGraph().setAppObjectsSomewhere(atLeastOne);
    }
  }

  /**
   * Set the DrawObject instantiation indicator.
   * The assumption is that if the subgraph has a DrawObject, then
   * elements within it do as well.
   */
  void setDrawObjects() {
    drawObjects = (getDrawObject() != null);
    if(drawObjects) {
      getGraph().setDrawObjectsSomewhere(true);
    } else {
      boolean atLeastOne = false;
      Enumeration enum = getGraph().elements(Grappa.SUBGRAPH);
      while(enum.hasMoreElements()) {
	if(((Subgraph)enum.nextElement()).hasDrawObjects()) {
	  atLeastOne = true;
	  break;
	}
      }
      getGraph().setDrawObjectsSomewhere(atLeastOne);
    }
  }

  /**
   * Check if AppObjects have been instantiated.
   *
   * @return true once AppObjects have been instantiated
   */
  public boolean hasAppObjects() {
    return appObjects;
  }

  /**
   * Check if DrawObjects have been instantiated.
   *
   * @return true once DrawObjects have been instantiated
   */
  public boolean hasDrawObjects() {
    return drawObjects;
  }

  /**
   * Builds the application components associated with the graph elements
   *
   * @exception InstantiationException occurs if there is a problem instantiating the AppObjects for this graph
   */
  public void buildAppObjects() throws InstantiationException {
    AppObject.buildAppObjects(this);
  }

  /**
   * Builds the drawing components associated with the graph elements; if
   * the application components have not been built yet, those are constructed
   * as well.
   *
   * @exception InstantiationException occurs if there is a problem instantiating the DrawObjects or AppObjects for this graph
   */
  public void buildDrawObjects() throws InstantiationException {
    DrawObject.buildDrawObjects(this);
  }

  /**
   * Instantiates both the application and drawing components of each of
   * the graph elements within the graph.  Equivalent to buildDrawObjects().
   *
   * @exception InstantiationException occurs if there is a problem instantiating the DrawObjects or AppObjects for this graph
   * @see Graph#buildDrawObjects()
   */
  public void buildObjects() throws InstantiationException {
    buildDrawObjects();
  }

  /**
   * Draws the graph onto the DrawPanes.
   */
  public void drawGraph() {
    DrawPane.drawGraph(this);
  }

  /**
   * Redraws the graph, as needed, onto the DrawPanes.
   */
  public void redrawGraph() {
    DrawPane.redrawGraph(this);
  }

  // start bounding box methods

  private Rectangle BBox = null;
  private Rectangle baseBBox = null;
  private Rectangle cropBBox = null;

  private boolean boundsFlag = true;

  /**
   * Set the minimal dimensions of the graph bounding box.
   *
   * @param box the Rectangle to use as the minimal bounding box dimensions.
   * @return the previous value of the minimal bounding box
   * @see Graph#getBounds()
   */
  public Rectangle setBaseBBox(Rectangle box) {
    Rectangle old = baseBBox;
    baseBBox = box;
    return old;
  }

  /**
   * Get the minimal dimensions of the graph bounding box.
   *
   * @return the current value of the minimal bounding box
   * @see Graph#setBaseBBox(java.awt.Rectangle)
   */
  public Rectangle getBaseBBox() {
    return baseBBox;
  }

  /**
   * Set the dimensions of the cropping box.  The cropping box is intersected
   * with the graph bounding box whenever the bounding box is requested.  In
   * this way, zooming is easily accomplished.
   *
   * @param box the Rectangle to use as the cropping box.
   * @return the previous value of the cropping box
   * @see Graph#getBounds()
   */
  public Rectangle setCropBBox(Rectangle box) {
    Rectangle old = cropBBox;
    cropBBox = box;
    return old;
  }

  /**
   * Get the cropping box.
   *
   * @return the current value of the cropping box
   * @see Graph#setCropBBox(java.awt.Rectangle)
   */
  public Rectangle getCropBBox() {
    return cropBBox;
  }

  Rectangle getBBox() {
    return BBox;
  }

  /**
   * Adds the given rectangle to graph bounding box.
   * A null argument just returns the current BBox.
   *
   * @param bbox bounding box to be added to graph bounding box.
   * @return the augmented graph bounding box.
   */
  public Rectangle addToBBox(Rectangle bbox) {
    if(bbox == null) return BBox;
    bbox.setSize(bbox.width,bbox.height);
    if(BBox == null) {
      BBox = new Rectangle(bbox.x,bbox.y,bbox.width,bbox.height);
    } else {
      BBox.add(bbox);
    }
    return BBox;
  }

  /**
   * Get the bounding box of the graph, possibly intersected with a
   * previously specified cropping box.
   *
   * @return the graph bounding box, possibly intersected with a non-null cropping box
   * @see Graph#setCropBBox(java.awt.Rectangle)
   */
  public Rectangle getBounds() {
    Rectangle bbox = BBox;
    if(boundsFlag || BBox == null) bbox = computeBBox();
    if(getCropBBox() != null) {
      bbox = bbox.intersection(getCropBBox());
    }
    return bbox;
  }

  // used in getBounds()
  private Rectangle computeBBox() {
    if(!boundsFlag && BBox != null) return BBox;
    BBox = getBaseBBox();
    if(graphdict != null) {
      Enumeration elems = graphdict.elements();
      Subgraph subg = null;
      Rectangle ebbox = null;
      while(elems.hasMoreElements()) {
	subg = (Subgraph)elems.nextElement();
	ebbox = subg.computeBBox();
	if(ebbox == null) {
	  continue;
	}
	addToBBox(ebbox);
      }
    }
    DrawObject drawable = getDrawObject();
    Rectangle ebbox = null;
    if(drawable != null) {
      ebbox = drawable.getBounds();
      if(ebbox != null) {
	addToBBox(ebbox);
      }
    }
    GraphEnumeration elems = elements(Grappa.NODE|Grappa.EDGE);
    Element elem = null;
    while(elems.hasMoreElements()) {
      elem = (Element)elems.nextElement();
      drawable = elem.getDrawObject();
      if(drawable == null) {
	continue;
      }
      ebbox = drawable.getBounds();
      if(ebbox == null) {
	continue;
      }
      addToBBox(ebbox);
    }
    boundsFlag = false;
    if(BBox == null) BBox = new Rectangle(0,0,1,1);
    return BBox;
  }

  /**
   * Sets bounding box to null.
   *
   * @return previous (possibly null) value
   */
  Rectangle resetBBox() {
    Rectangle old = BBox;
    BBox = null;
    return old;
  }
  
  
  /**
   * Set an indicator regarding the need to re-compute the graph
   * bounding box.
   *
   * @param mode use true to indicate that recomputation is needed
   */
  public void setBoundsFlag(boolean mode) {
    boundsFlag = mode;
  }
  
  /**
   * Get the bounding box recomputation indicator.
   *
   * @return true if the bounding box should be recomputed.
   */
  public boolean getBoundsFlag() {
    return boundsFlag;
  }
  // end bounding box methods

  /**
   * Get a count of elements in this subgraph.  No recursion to descendants
   * is done.
   *
   * @param types a bitwise-oring of Grappa.NODE, Grappa.EDGE, Grappa.SUBGRAPH to
   *        determine which element types should be in the count
   * @return a count of the specified elements in this subgraph.
   * @see Grappa#NODE
   * @see Grappa#EDGE
   * @see Grappa#SUBGRAPH
   */
  public int countOfLocalElements(int types) {
    int count = 0;
    if((types&Grappa.NODE) != 0 && nodedict != null) count += nodedict.size(); 
    if((types&Grappa.EDGE) != 0 && edgedict != null) count += edgedict.size(); 
    if((types&Grappa.SUBGRAPH) != 0 && graphdict != null) count += graphdict.size(); 
    return count;
  }

  /**
   * Get a count of elements in this subgraph and, by recursion, descendant
   * subgraphs.
   *
   * @param types a bitwise-oring of Grappa.NODE, Grappa.EDGE, Grappa.SUBGRAPH to
   *        determine which element types should be in the count
   * @return a count of the specified elements in this subgraph and its descendants.
   * @see Grappa#NODE
   * @see Grappa#EDGE
   * @see Grappa#SUBGRAPH
   */
  public int countOfElements(int types) {
    int count = 0;
    if((types&Grappa.NODE) != 0 && nodedict != null) count += nodedict.size(); 
    if((types&Grappa.EDGE) != 0 && edgedict != null) count += edgedict.size(); 
    if(graphdict != null) {
      if((types&Grappa.SUBGRAPH) != 0) count += graphdict.size(); 
      Enumeration enum = graphdict.elements();
      while(enum.hasMoreElements()) {
	count += ((Subgraph)enum.nextElement()).countOfElements(types);
      }
    }
    return count;
  }

  /**
   * Get an enumeration of the node elements in this subgraph.
   *
   * @return an Enumeration of Node objects
   */
  public Enumeration nodeElements() {
    if(nodedict == null) {
      return Grappa.emptyEnumeration.elements();
    }
    return nodedict.elements();
  }

  /**
   * Get an enumeration of the edge elements in this subgraph.
   *
   * @return an Enumeration of Edge objects
   */
  public Enumeration edgeElements() {
    if(edgedict == null) {
      return Grappa.emptyEnumeration.elements();
    }
    return edgedict.elements();
  }

  /**
   * Get an enumeration of the subgraph elements in this subgraph.
   *
   * @return an Enumeration of Subgraph objects
   */
  public Enumeration subgraphElements() {
    if(graphdict == null) {
      return Grappa.emptyEnumeration.elements();
    }
    return graphdict.elements();
  }
  
  /**
   * Get an enumeration of elements in this subgraph and any subgraphs under this one.
   *
   * @param types a bitwise-oring of Grappa.NODE, Grappa.EDGE, Grappa.SUBGRAPH to
   *        determine which element types should be in the enumeration
   * @return a GraphEnumeration containing Element objects.
   * @see Grappa#NODE
   * @see Grappa#EDGE
   * @see Grappa#SUBGRAPH
   */
  public GraphEnumeration elements(int types) {
    return new Enumerator(types);
  }
  
  /**
   * Get an enumeration of all elements in this subgraph and any subgraphs under this one.
   * A convenience method equivalent to:
   * <code>
   * elements(Grappa.NODE|Grappa.EDGE|Grappa.SUBGRAPH)
   * </code>
   *
   * @return a GraphEnumeration containing Element objects.
   * @see Subgraph#elements(int)
   */
  public GraphEnumeration elements() {
    return new Enumerator(Grappa.NODE|Grappa.EDGE|Grappa.SUBGRAPH);
  }

  class Enumerator implements GraphEnumeration {
    private Subgraph root = null;
    private int types = 0;
    private Enumeration enum = null;
    private GraphEnumeration subEnum = null;
    private Element elem = null;
    private int dictType = 0;
    
    Enumerator(int t) {
      root = Subgraph.this;
      types = t;

      if((types&Grappa.SUBGRAPH) != 0) {
	elem = (Element)(root);
      } else {
	elem = null;
      }
      enum = subgraphElements();
      if(enum.hasMoreElements()) {
	dictType = Grappa.SUBGRAPH;
	while(enum.hasMoreElements()) {
	  subEnum = ((Subgraph)(enum.nextElement())).new Enumerator(types);
	  if(subEnum.hasMoreElements()) {
	    if(elem == null) {
	      elem = (Element)subEnum.nextElement();
	    }
	    break;
	  }
	}
      } else {
	dictType = 0;
	enum = null;
	subEnum = null;
      }
      if(enum == null) {
	if((types&Grappa.NODE) != 0 && (enum = nodeElements()).hasMoreElements()) {
	  dictType = Grappa.NODE;
	  if(elem == null) {
	    elem = (Element)enum.nextElement();
	  }
	} else if((types&Grappa.EDGE) != 0 && (enum = edgeElements()).hasMoreElements()) {
	  dictType = Grappa.EDGE;
	  if(elem == null) {
	    elem = (Element)enum.nextElement();
	  }
	} else {
	  enum = null;
	}
      }
    }

    public boolean hasMoreElements() {
      return elem != null;
    }

    public Object nextElement() {
      if(elem == null) {
	throw new NoSuchElementException("Subgraph$Enumerator");
      }
      Element el = elem;
      if(subEnum != null && subEnum.hasMoreElements()) {
	elem = (Element)subEnum.nextElement();
      } else if(enum != null && enum.hasMoreElements()) {
	do {
	  elem = (Element)enum.nextElement();
	  if(elem.isSubgraph()) {
	    subEnum = ((Subgraph)elem).new Enumerator(getEnumerationTypes());
	    if(subEnum.hasMoreElements()) {
	      elem = (Element)subEnum.nextElement();
	      break;
	    } else {
	      elem = null;
	    }
	  } else {
	    break;
	  }
	} while(enum.hasMoreElements());
      } else {
	elem = null;
      }
      if(elem == null) {
	if(dictType != 0) {
	  if(dictType == Grappa.SUBGRAPH) {
	    if((getEnumerationTypes()&Grappa.NODE) != 0 && (enum = nodeElements()).hasMoreElements()) {
	      dictType = Grappa.NODE;
	      elem = (Element)enum.nextElement();
	    } else if((getEnumerationTypes()&Grappa.EDGE) != 0 && (enum = edgeElements()).hasMoreElements()) {
	      dictType = Grappa.EDGE;
	      elem = (Element)enum.nextElement();
	    } else {
	      dictType = 0;
	      enum = null;
	    }
	  } else if(dictType == Grappa.NODE) {
	    if((getEnumerationTypes()&Grappa.EDGE) != 0 && (enum = edgeElements()).hasMoreElements()) {
	      dictType = Grappa.EDGE;
	      elem = (Element)enum.nextElement();
	    } else {
	      dictType = 0;
	      enum = null;
	    }
	  } else {
	    dictType = 0;
	    enum = null;
	  }
	}
      }
      return el;
    }

    public Element nextGraphElement() {
      return (Element)nextElement();
    }

    public Subgraph getSubgraphRoot() {
      return root;
    }

    public int getEnumerationTypes() {
      return types;
    }
  }

    /**
     * Get a vector of elements in this subgraph and, by recursion, descendant
     * subgraphs.
     *
     * @param types a bitwise-oring of Grappa.NODE, Grappa.EDGE, Grappa.SUBGRAPH to
     *        determine which element types should be in the count
     * @return a vector of the specified elements in this subgraph and its descendants (excluding the current subgraph itself).
     * @see Grappa#NODE
     * @see Grappa#EDGE
     * @see Grappa#SUBGRAPH
     */
    public Vector vectorOfElements(int types) {
	Vector retVec = new Vector();
	int count = 0;
	Enumeration elems = null;
	if((types&Grappa.NODE) != 0 && nodedict != null) {
	    count += nodedict.size(); 
	    retVec.ensureCapacity(count);
	    elems = nodedict.elements();
	    while(elems.hasMoreElements()) {
		retVec.addElement(elems.nextElement());
	    }
	}
	if((types&Grappa.EDGE) != 0 && edgedict != null) {
	    count += edgedict.size(); 
	    retVec.ensureCapacity(count);
	    elems = edgedict.elements();
	    while(elems.hasMoreElements()) {
		retVec.addElement(elems.nextElement());
	    }
	}
	if(graphdict != null) {
	    if((types&Grappa.SUBGRAPH) != 0) {
		count += graphdict.size(); 
		retVec.ensureCapacity(count);
	    }
	    elems = graphdict.elements();
	    while(elems.hasMoreElements()) {
		((Subgraph)(elems.nextElement())).recurseVectorOfElements(types,retVec,count);
	    }
	}
	return(retVec);
    }

    void recurseVectorOfElements(int types, Vector retVec, int count) {
	if((types&Grappa.SUBGRAPH) != 0) retVec.addElement(this);
	Enumeration elems = null;
	if((types&Grappa.NODE) != 0 && nodedict != null) {
	    count += nodedict.size(); 
	    retVec.ensureCapacity(count);
	    elems = nodedict.elements();
	    while(elems.hasMoreElements()) {
		retVec.addElement(elems.nextElement());
	    }
	}
	if((types&Grappa.EDGE) != 0 && edgedict != null) {
	    count += edgedict.size(); 
	    retVec.ensureCapacity(count);
	    elems = edgedict.elements();
	    while(elems.hasMoreElements()) {
		retVec.addElement(elems.nextElement());
	    }
	}
	if(graphdict != null) {
	    if((types&Grappa.SUBGRAPH) != 0) {
		count += graphdict.size(); 
		retVec.ensureCapacity(count);
	    }
	    elems = graphdict.elements();
	    while(elems.hasMoreElements()) {
		((Subgraph)(elems.nextElement())).recurseVectorOfElements(types,retVec,count);
	    }
	}
    }

  Hashtable getNodedictTable() {
    return(nodedict);
  }

  Hashtable getEdgedictTable() {
    return(edgedict);
  }

  Hashtable getGraphdictTable() {
    return(graphdict);
  }

  Hashtable getNodeAttributesTable() {
    return(nodeAttributes);
  }

  Hashtable getEdgeAttributesTable() {
    return(edgeAttributes);
  }

  void possessSubgraph(Subgraph demon) {
    possessElement((Element)demon);

    nodedict = demon.getNodedictTable();
    edgedict = demon.getEdgedictTable();
    graphdict = demon.getGraphdictTable();

    Graph grf = getGraph();
    Enumeration enum = null;
    enum = nodeElements();
    while(enum.hasMoreElements()) {
      ((Element)enum.nextElement()).rawSetSubgraph(grf);
    }
    enum = edgeElements();
    while(enum.hasMoreElements()) {
      ((Element)enum.nextElement()).rawSetSubgraph(grf);
    }
    enum = subgraphElements();
    while(enum.hasMoreElements()) {
      ((Element)enum.nextElement()).rawSetSubgraph(grf);
    }
    GraphEnumeration genum = elements();
    while(genum.hasMoreElements()) {
      genum.nextGraphElement().setGraph(grf);
    }

    nodeAttributes = demon.getNodeAttributesTable();
    edgeAttributes = demon.getEdgeAttributesTable();
    BBox = demon.getBBox();
    baseBBox = demon.getBaseBBox();
    cropBBox = demon.getCropBBox();
  }
}
