/*
 *  This software may only be used by you under license from AT&T Corp.
 *  ("AT&T").  A copy of AT&T's Source Code Agreement is available at
 *  AT&T's Internet website having the URL:
 *  <http://www.research.att.com/sw/tools/graphviz/license/source.html>
 *  If you received this software without first entering into a license
 *  with AT&T, you have an infringing copy of this software and cannot use
 *  it without violating AT&T's intellectual property rights.
 */

package att.grappa;

import java.io.*;
import java.util.*;

/**
 * This class describes a dot subgraph, which can consist of
 * nodes, edges and other subgraphs.  In practice, the topmost
 * or root DotSubgraph object describes the entire dot graph.
 *
 * @version 0.3, 05 Dec 1996; Copyright 1996 by AT&T Corp.
 * @author  John Mocenigo (john@research.att.com)
 */
public class DotSubgraph extends DotElement
{
  /**
   * Initial capacity of node, edge and graph dictionaries.
   *
   * @see Hashtable
   */
  public final static int initialDictionaryCapacity = 8;
  /**
   * Size increment for node, edge and graph dictionaries.
   *
   * @see Hashtable
   */
  public final static int dictionaryIncrement = 8;

  /**
   * Default graph name prefix.
   */
  public final static String defaultGraphNamePrefix = "G";

  // node, edge and graph dictionaries for this subgraph
  private Hashtable nodedict = null;
  private Hashtable edgedict = null;
  private Hashtable graphdict = null;

  // default node attributes
  private Hashtable nodeAttributes = null;

  // default edge attributes
  private Hashtable edgeAttributes = null;

  /**
   * Use this constructor when creating the root subgraph
   *
   * @param graph the DotGraph object representing the dot graph.
   * @param name the name of the graph.
   */
  public DotSubgraph(DotGraph graph, String graphName) {
    setGraph(graph);
    setSubgraph(null);
    setId(graph.nextGraphId());
    setName(graphName);
  }

  /**
   * Use this constructor when creating the root subgraph with an
   * automatically generated name.
   *
   * @param graph the DotGraph object representing the dot graph. 
   * @see DotSubgraph#setName()
   */
  public DotSubgraph(DotGraph graph) {
    this(graph,(String)(null));
  }

  /**
   * Use this constructor when creating a subgraph within a subgraph.
   *
   * @param subg the parent subgraph.
   * @param name the name of this subgraph.
   */
  public DotSubgraph(DotSubgraph subg, String graphName) {
    setGraph(subg.getGraph());
    setSubgraph(subg);
    setId(getGraph().nextGraphId());
    setName(graphName);
  }

  /**
   * Use this constructor when creating a subgraph within a subgraph
   * with an automatically generated name.
   *
   * @param subg the parent subgraph.
   * @see DotSubgraph#setName()
   */
  public DotSubgraph(DotSubgraph subg) {
    this(subg,(String)(null));
  }

  /**
   * Useful for testing the subclass type of a DotElement object.
   *
   * @return true if this object is a DotSubgraph.
   */
  public boolean isGraph() {
    return(true);
  }

  /**
   * Useful for distinguishing DotElement objects.
   * Implements the abstract DotElement method.
   *
   * @return the class variable constant Grappa.DOT_GRAPH.
   * @see Grappa
   */
  public int typeFlag() {
    return(Grappa.DOT_GRAPH);
  }

  /**
   * Generates and sets the name for this subgraph.
   * The generated name is the concatenation of the
   * DotSubgraph.defaultGraphNamePrefix with the numeric
   * id of this subgraph Instance.
   * Implements the abstract DotElement method.
   *
   * @see DotElement#getId()
   */
  public void setName() {
    name = DotSubgraph.defaultGraphNamePrefix + getId();
  }

  /**
   * Sets the subgraph name to a copy of the supplied argument.
   * When the argument is null, setName() is called.
   * When the name is not unique or when the name has the same format as
   * that generated by setName(), a IllegalArgumentException is thrown.
   *
   * @param newName the new name for the subgraph.
   * @see DotSubgraph#setName()
   */
  public void setName(String newName) throws IllegalArgumentException {
    String oldName = name;
    
    if(newName == null) {
      setName();
    } else {
      name = new String(newName);
    }

    // test if the new name is the same as the old name (if any)
    if(oldName != null && oldName.equals(name)) {
      return;
    }

    // is name unique?
    DotSubgraph subg = getGraph().getRoot();
    if(subg != null && subg.findGraphByName(name) != null) {
      newName = name;
      name = oldName;
      throw new IllegalArgumentException("graph name (" + newName + ") is not unique");
    }

    // check name format
    if(newName != null) {
      if(newName.startsWith(DotSubgraph.defaultGraphNamePrefix)) {
	String remainder = newName.substring(DotSubgraph.defaultGraphNamePrefix.length());
	boolean badFormat = true;
	try {
	  int nbr = Integer.parseInt(remainder);
	} catch(NumberFormatException nfe) {
	  badFormat = false;
	}

	if(badFormat) {
	  name = oldName;
	  throw new IllegalArgumentException("graph name (" + newName + ") resembles setName() generated name");
	}
      }
    }

    // update subgraph graph dictionary
    if(getSubgraph() != null) {
      if(oldName != null) {
	getSubgraph().removeGraph(oldName);
      }
      getSubgraph().addGraph(this);
    }
  }

  /**
   * Gets the subgraph-specific default for the requested node attribute.
   *
   * @param key the name of the node attribute pair to be retrieved.
   * @return the requested attribute pair or null if not found.
   */
  public Attribute getNodeAttribute(String key) {
    if(nodeAttributes == null) return(null);
    return((Attribute)(nodeAttributes.get(key)));
  }

  /**
   * Gets an enumeration of the subgraph-specific node attributes
   *
   * @return the requested enumeration or null if there are no node attributes.
   */
  public Enumeration getNodeAttributePairs() {
    if(nodeAttributes == null) return(null);
    return(nodeAttributes.elements());
  }

  /**
   * Gets an enumeration of the subgraph-specific edge attributes
   *
   * @return the requested enumeration or null if there are no edge attributes.
   */
  public Enumeration getEdgeAttributePairs() {
    if(edgeAttributes == null) return(null);
    return(edgeAttributes.elements());
  }

  /**
   * Gets an enumeration of the subgraph-specific graph attributes
   *
   * @return the requested enumeration or null if there are no graph attributes.
   */
  public Enumeration getGraphAttributePairs() {
    if(attributes == null) return(null);
    return(attributes.elements());
  }

  /**
   * Sets the subgraph-specific default for the specified node attribute.
   *
   * @param attr the node attribute pair to set.
   * @return the attribute pair previously stored for this attribute.
   */
  public Attribute setNodeAttribute(Attribute attr) {
    if(nodeAttributes == null) {
      nodeAttributes = new Hashtable(initialAttributesCapacity,attributesIncrement);
    }
    if(attr == null) {
      return null;
    }
    return((Attribute)nodeAttributes.put(attr.getName(),attr));
  }

  /**
   * Gets the subgraph-specific default for the requested edge attribute.
   *
   * @param key the name of the edge attribute pair to be retrieved.
   * @return the requested attribute pair or null if not found.
   */
  public Attribute getEdgeAttribute(String key) {
    if(edgeAttributes == null) return(null);
    return((Attribute)(edgeAttributes.get(key)));
  }

  /**
   * Sets the subgraph-specific default for the specified edge attribute.
   *
   * @param attr the edge attribute pair to set.
   * @return the attribute pair previously stored for this attribute.
   */
  public Attribute setEdgeAttribute(Attribute attr) {
    if(edgeAttributes == null) {
      edgeAttributes = new Hashtable(initialAttributesCapacity,attributesIncrement);
    }
    return((Attribute)edgeAttributes.put(attr.getName(),attr));
  }

  /**
   * Gets the subgraph-specific default for the requested graph attribute.
   *
   * @param key the name of the graph attribute pair to be retrieved.
   * @return the requested attribute pair or null if not found.
   */
  public Attribute getGraphAttribute(String key) {
    if(attributes == null) return(null);
    return((Attribute)(attributes.get(key)));
  }

  /**
   * Sets the subgraph-specific default value of the specified subgraph attribute.
   *
   * @param attr the subgraph attribute pair being set.
   * @return the attribute pair previously stored for this attribute.
   */
  public Attribute setGraphAttribute(Attribute attr) {
    return(setAttribute(attr));
  }

  /**
   * Instantiates the physical representation of each graph element
   * within this subgraph.
   */
  public void instantiateGraph() throws InstantiationException {
    Enumeration elems;

    if(graphdict != null && !graphdict.isEmpty()) {
      DotSubgraph subg;
      elems = graphdict.elements();
      while(elems.hasMoreElements()) {
	subg = (DotSubgraph)elems.nextElement();
	subg.instantiateGraph();
      }
    }
    if(nodedict != null && !nodedict.isEmpty()) {
      DotNode node;
      elems = nodedict.elements();
      while(elems.hasMoreElements()) {
	node = (DotNode)elems.nextElement();
	node.setAppObject(false);
      }
    }
    if(edgedict != null && !edgedict.isEmpty()) {
      DotEdge edge;
      elems = edgedict.elements();
      while(elems.hasMoreElements()) {
	edge = (DotEdge)elems.nextElement();
	edge.setAppObject(false);
      }
    }
    this.setAppObject(false);
  }

  /**
   * Prints the dot description of each graph element to the supplied stream.
   *
   * @param output the OutputStream for writing the graph description.
   */
  public void printSubgraph(PrintStream out) {
    DotGraph graph = getGraph();
    String indent = new String(graph.getIndent());

    if(getSubgraph() == null) {
      // this subgraph is the root
      out.println(indent + graph.getType() + " " + graph.toString() + " {");
    } else if(getName().startsWith(Grappa.ANONYMOUS_PREFIX)) {
      out.println(indent + "{");
    } else {
      out.println(indent + "subgraph " + this.toString() + " {");
    }

    graph.incrementIndent();

    printElem(out,Grappa.DOT_GRAPH);
    printElem(out,Grappa.DOT_NODE);
    printElem(out,Grappa.DOT_EDGE);

    if(nodedict != null && !nodedict.isEmpty()) {
      Enumeration elems = nodedict.elements();
      while(elems.hasMoreElements()) {
	((DotNode)(elems.nextElement())).printNode(out);
      }
    }

    if(edgedict != null && !edgedict.isEmpty()) {
      Enumeration elems = edgedict.elements();
      while(elems.hasMoreElements()) {
	((DotEdge)(elems.nextElement())).printEdge(out);
      }
    }

    if(graphdict != null && !graphdict.isEmpty()) {
      Enumeration elems = graphdict.elements();
      while(elems.hasMoreElements()) {
	((DotSubgraph)(elems.nextElement())).printSubgraph(out);
      }
    }

    graph.decrementIndent();

    out.println(indent + "}");
  }

  // print the subgraph default elements
  private void printElem(PrintStream out, int type) {
    String indent = new String(getGraph().getIndent());
    Hashtable attr = null;
    String label = null;

    switch(type) {
    case Grappa.DOT_GRAPH:
      attr = attributes;
      label = "graph";
      break;
    case Grappa.DOT_NODE:
      attr = nodeAttributes;
      label = "node";
      break;
    case Grappa.DOT_EDGE:
      attr = edgeAttributes;
      label = "edge";
      break;
    }

    if(attr == null || attr.isEmpty()) {
      return;
    }

    getGraph().incrementIndent();
    printElemAttr(out,attr,type,indent + label + " [", indent + "];");
    getGraph().decrementIndent();
  }

  // print the subgraph default element attribute values
  private void printElemAttr(PrintStream out, Hashtable dfltAttr, int type, String prefix, String suffix) {
    String indent = new String(getGraph().getIndent());
    String value;
    String key;
    Attribute attr;
    int nbr = 0;
    Enumeration attrs = dfltAttr.elements();

    while(attrs.hasMoreElements()) {
      attr = (Attribute)(attrs.nextElement());
      key = attr.getName();
      value = attr.getValue();
      if(attr != null && !attr.equalsValue(getDefaultAttr(type,key))) {
	nbr++;
	if(nbr == 1) {
	  out.println(prefix);
	}
	if(attrs.hasMoreElements()) {
	  out.println(indent + key + " = " + canonString(value) + ",");
	} else {
	  out.println(indent + key + " = " + canonString(value));
	}
      }
    }
    if(nbr > 0) {
      out.println(suffix);
      out.println();
    }
  }

  // get the default (parent) attribute value for the specified type and key
  private Attribute getDefaultAttr(int type, String key) {
    Attribute attr = null;
    DotSubgraph subg = getSubgraph();

    switch(type) {
    case Grappa.DOT_GRAPH:
      while(subg != null && (attr = subg.getGraphAttribute(key)) == null) {
	subg = subg.getSubgraph();
      }
      if(attr == null) {
	attr = DotGraph.getGraphAttribute(key);
      }
      return attr;
    case Grappa.DOT_NODE:
      while(subg != null && (attr = subg.getNodeAttribute(key)) == null) {
	subg = subg.getSubgraph();
      }
      if(attr == null) {
	attr = DotGraph.getNodeAttribute(key);
      }
      return attr;
    case Grappa.DOT_EDGE:
      while(subg != null && (attr = subg.getEdgeAttribute(key)) == null) {
	subg = subg.getSubgraph();
      }
      if(attr == null) {
	attr = DotGraph.getEdgeAttribute(key);
      }
      return attr;
    }

    return(null);
  }

  /**
   * Searches current subgraph and, by recursion, descendent subgraphs
   * for the node matching the supplied name.
   *
   * @param nodeName the name of the node to be found.
   * @return the DotNode matching the name or null, if there is no match.
   */
  public DotNode findNodeByName(String nodeName) {
    DotNode match = null;
    
    if(nodeName == null) {
      return(null);
    }
    if(nodedict != null && (match = (DotNode)(nodedict.get(nodeName))) != null) {
      return(match);
    }
    if(graphdict == null || graphdict.isEmpty()) {
      return(null);
    }
    Enumeration subgraphs = graphdict.elements();
    while(subgraphs.hasMoreElements()) {
      if((match = ((DotSubgraph)(subgraphs.nextElement())).findNodeByName(nodeName)) != null) {
	return(match);
      }
    }
    return(null);
  }

  /**
   * Adds the specified node to the subgraph's Node dictionary.
   *
   * @param newNode the node to be added to the dictionary.
   */
  public void addNode(DotNode newNode) {
    if(newNode == null) return;
    if(nodedict == null) {
      nodedict = new Hashtable(initialDictionaryCapacity,dictionaryIncrement);
    }
    nodedict.put(newNode.getName(),newNode);
  }

  /**
   * Creates a new element and adds it to the subgraph's element dictionary.
   *
   * @param subg subgraph that will contain the new element
   * @param type type of the element
   * @param name name of the element
   * @param attrs attributes describing the element to be created
   */
  public DotElement createElement(int type, Vector info, Vector attrs) throws InstantiationException {
    DotElement elem = null;

    switch(type) {
    case Grappa.DOT_NODE:
      String name = null;
      if(info != null) {
	name = (String)info.firstElement();
      }
      DotNode node = new DotNode(this,name);
      if(attrs != null) {
	Enumeration attr_enum = attrs.elements();
	while(attr_enum.hasMoreElements()) {
	  node.setAttribute((Attribute)attr_enum.nextElement());
	}
      }
      node.setAppObject(true);
      elem =  (DotElement)node;
      break;
    case Grappa.DOT_EDGE:
      if(info == null || info.size() < 5) return null;
      DotNode head = (DotNode)info.elementAt(0);
      String headPort = (String)info.elementAt(1);
      DotNode tail = (DotNode)info.elementAt(2);
      String tailPort = (String)info.elementAt(3);
      Integer directed = (Integer)info.elementAt(4);
      DotEdge edge = new DotEdge(this,tail,tailPort,head,headPort,directed.intValue() == 1);
      if(attrs != null) {
	Enumeration attr_enum = attrs.elements();
	while(attr_enum.hasMoreElements()) {
	  edge.setAttribute((Attribute)attr_enum.nextElement());
	}
      }
      edge.setAppObject(true);
      elem =  (DotElement)edge;
      break;
    case Grappa.DOT_GRAPH:
      break;
    default:
      return null;
    }

    return elem;
  }

  /**
   * Removes the node matching the specified name from the subgraph's Node dictionary.
   *
   * @param nodeName the name of the node to be removed from the dictionary.
   * @return the node that was removed.
   */
  public DotNode removeNode(String nodeName) {
    if(nodedict == null) return(null);
    return((DotNode)(nodedict.remove(nodeName)));
  }

  /**
   * Searches current subgraph and, by recursion, descendent subgraphs
   * for the edge matching the supplied name.
   *
   * @param edgeName the name of the edge to be found.
   * @return the DotEdge matching the name or null, if there is no match.
   */
  public DotEdge findEdgeByName(String edgeName) {
    DotEdge match = null;
    
    if(edgeName == null) {
      return(null);
    }
    if(edgedict != null && (match = (DotEdge)(edgedict.get(edgeName))) != null) {
      return(match);
    }
    if(graphdict == null || graphdict.isEmpty()) {
      return(null);
    }
    Enumeration subgraphs = graphdict.elements();
    while(subgraphs.hasMoreElements()) {
      if((match = ((DotSubgraph)(subgraphs.nextElement())).findEdgeByName(edgeName)) != null) {
	return(match);
      }
    }
    return(null);
  }

  /**
   * Adds the specified edge to the subgraph's Edge dictionary.
   *
   * @param newEdge the edge to be added to the dictionary.
   */
  public void addEdge(DotEdge newEdge) {
    if(newEdge == null) return;
    if(edgedict == null) {
      edgedict = new Hashtable(initialDictionaryCapacity,dictionaryIncrement);
    }
    edgedict.put(newEdge.getName(),newEdge);
  }

  /**
   * Removes the edge matching the specified name from the subgraph's Edge dictionary.
   *
   * @param edgeName the name of the edge to be removed from the dictionary.
   * @return the edge that was removed.
   */
  public DotEdge removeEdge(String edgeName) {
    if(edgedict == null) return(null);
    return((DotEdge)(edgedict.remove(edgeName)));
  }

  /**
   * Searches current subgraph and, by recursion, descendent subgraphs
   * for the subgraph matching the supplied name.
   *
   * @param graphName the name of the subgraph to be found.
   * @return the DotSubgraph matching the name or null, if there is no match.
   */
  public DotSubgraph findGraphByName(String graphName) {
    DotSubgraph match = null;

    if(graphName == null) {
      return(null);
    }
    if(graphName.equals(getName())) {
      return(this);
    }
    if(graphdict == null || graphdict.isEmpty()) {
      return(null);
    }
    if((match = (DotSubgraph)(graphdict.get(graphName))) != null) {
      return(match);
    }
    Enumeration subgraphs = graphdict.elements();
    while(subgraphs.hasMoreElements()) {
      if((match = ((DotSubgraph)(subgraphs.nextElement())).findGraphByName(graphName)) != null) {
	return(match);
      }
    }
    return(null);
  }

  /**
   * Adds the specified subgraph to the subgraph's graph dictionary.
   *
   * @param newGraph the subgraph to be added to the dictionary.
   */
  public void addGraph(DotSubgraph newGraph) {
    if(newGraph == null) return;
    if(graphdict == null) {
      graphdict = new Hashtable(initialDictionaryCapacity,dictionaryIncrement);
    }
    graphdict.put(newGraph.getName(),newGraph);
  }

  /**
   * Removes the subgraph matching the specified name from the
   * subgraph's graph dictionary.
   *
   * @param graphName the name of the subgraph to be removed from the dictionary.
   * @return the subgraph that was removed.
   */
  public DotSubgraph removeGraph(String graphName) {
    if(graphdict == null) return(null);
    return((DotSubgraph)(graphdict.remove(graphName)));
  }
  
  /*
  public void insertSubgraph(DotSubgraph subg) {
    subg.setSubgraph(this);

    DotGraph thisGraph = getGraph();
    // it is okay to compare references only
    if(subg.getGraph() != thisGraph) {
      subg.setGraph(this.getGraph());
      graphdict.addElement(subg);
    }
  }

  public boolean deleteSubgraph(String graphName) {
    DotSubgraph tmpSubg;

    for (int i = 0; i < graphdict.size(); i++) {
      tmpSubg = (DotSubgraph) graphdict.elementAt(i);
      if (graph_name.equals(tmp_graph.getName()) == true) {
        tmp_graph.deleteSelf();
        subgraphs.removeElementAt(i);
        return true;
      } else if (tmp_graph.deleteSubGraph(graph_name) == true) {
        return true;
      }
    }
    return false;
  }
  */

  protected Enumeration elements(boolean nodes, boolean edges, boolean subgs) {
    return new SubgraphEnumerator(this,nodes,edges,subgs);
  }

  public Enumeration elements() {
    return elements(true,true,true);
  }

  public boolean isLR() {
    Subgraph subg = (Subgraph)(getDrawObject());
    if(subg == null) {
      Attribute attr = getAttribute("rankdir");

      if(attr == null) return false; // the default
      String value = attr.getValue();
      if(value == null) return false; // the default
      if(value.equals("LR")) return true;
      return false;
    } else {
      return subg.isLR();
    }
  }

  protected Hashtable getGraphdict() {
    return graphdict;
  }

  protected Hashtable getNodedict() {
    return nodedict;
  }

  protected Hashtable getEdgedict() {
    return edgedict;
  }
}

final class SubgraphEnumerator implements Enumeration {
  boolean nodes = false;
  boolean edges = false;
  boolean subgs = false;
  Enumeration enum = null;
  Enumeration subEnum = null;
  DotElement elem = null;
  Hashtable dict = null;
  Hashtable graphdict = null;
  Hashtable nodedict = null;
  Hashtable edgedict = null;
    
  SubgraphEnumerator(DotSubgraph caller, boolean n, boolean e, boolean s) {
    nodes = n;
    edges = e;
    subgs = s;

    graphdict = caller.getGraphdict();
    nodedict = caller.getNodedict();
    edgedict = caller.getEdgedict();

    if(subgs) {
      elem = caller;
    } else {
      elem = null;
    }
    if(graphdict != null && graphdict.size() > 0) {
      dict = graphdict;
      enum = dict.elements();
      while(enum.hasMoreElements()) {
	subEnum = ((DotSubgraph)(enum.nextElement())).elements(nodes,edges,subgs);
	if(subEnum.hasMoreElements()) {
	  if(elem == null) {
	    elem = (DotElement)subEnum.nextElement();
	  }
	  break;
	}
      }
    } else {
      dict = null;
      enum = null;
      subEnum = null;
    }
    if(dict == null) {
      if(nodes && nodedict != null && nodedict.size() > 0) {
	dict = nodedict;
	enum = dict.elements();
	if(elem == null) {
	  elem = (DotElement)enum.nextElement();
	}
      } else if(edges && edgedict != null && edgedict.size() > 0) {
	dict = edgedict;
	enum = dict.elements();
	if(elem == null) {
	  elem = (DotElement)enum.nextElement();
	}
      }
    }
  }

  public boolean hasMoreElements() {
    return elem != null;
  }

  public Object nextElement() {
    if(elem == null) {
      throw new NoSuchElementException("DotSubgraph$Enumerator");
    }
    DotElement el = elem;
    if(subEnum != null && subEnum.hasMoreElements()) {
      elem = (DotElement)subEnum.nextElement();
    } else if(enum != null && enum.hasMoreElements()) {
      do {
	elem = (DotElement)enum.nextElement();
	if(elem.isGraph()) {
	  subEnum = ((DotSubgraph)elem).elements(nodes,edges,subgs);
	  if(subEnum.hasMoreElements()) {
	    elem = (DotElement)subEnum.nextElement();
	    break;
	  } else {
	    elem = null;
	  }
	} else {
	  break;
	}
      } while(enum.hasMoreElements());
    } else {
      elem = null;
    }
    if(elem == null) {
      if(dict != null) {
	if(dict == graphdict) {
	  if(nodes && nodedict != null && nodedict.size() > 0) {
	    dict = nodedict;
	    enum = dict.elements();
	    elem = (DotElement)enum.nextElement();
	  } else if(edges && edgedict != null && edgedict.size() > 0) {
	    dict = edgedict;
	    enum = dict.elements();
	    elem = (DotElement)enum.nextElement();
	  }
	} else if(dict == nodedict) {
	  if(edges && edgedict != null && edgedict.size() > 0) {
	    dict = edgedict;
	    enum = dict.elements();
	    elem = (DotElement)enum.nextElement();
	  }
	}
      }
    }
    return el;
  }
}
