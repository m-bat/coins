/*
 *  This software may only be used by you under license from AT&T Corp.
 *  ("AT&T").  A copy of AT&T's Source Code Agreement is available at
 *  AT&T's Internet website having the URL:
 *  <http://www.research.att.com/sw/tools/graphviz/license/source.html>
 *  If you received this software without first entering into a license
 *  with AT&T, you have an infringing copy of this software and cannot use
 *  it without violating AT&T's intellectual property rights.
 */

package att.grappa;

import java.util.*;
import java.io.*;
import java.awt.*;


/**
 * This class describes a dot node.
 *
 * @version 0.3, 05 Dec 1996; Copyright 1996 by AT&T Corp.
 * @author  John Mocenigo (john@research.att.com)
 */
public class DotNode extends DotElement
{
  /**
   * Initial capacity of the edge dictionaries.
   *
   * @see Vector
   */
  public final static int initialEdgesCapacity = 2;
  /**
   * Size increment of the edge dictionaries.
   *
   * @see Vector
   */
  public final static int edgesIncrement = 3;

  /**
   * Default node name prefix.
   */
  public final static String defaultNodeNamePrefix = "N";

  private Vector inEdges = null;
  private Vector outEdges = null;

  private Vector Ports = null;

  /**
   * Use this constructor when creating a node within a subgraph.
   *
   * @param subg the parent subgraph.
   * @param name the name of this node.
   */
  public DotNode(DotSubgraph subg, String name) {
    setSubgraph(subg);
    setGraph(subg.getGraph());
    // must set id before calling setName
    setId(getGraph().nextNodeId());
    setName(name);
  }

  /**
   * Use this constructor when creating a node within a subgraph
   * with an automatically generated name.
   *
   * @param subg the parent subgraph.
   * @see DotNode#setName()
   */
  public DotNode(DotSubgraph subg) {
    this(subg,(String)null);
  }

  // override DotElement methods

  /*
  public DotElement makeImage() {
    DotNodePeer nodePeer = new DotNodePeer(getSubgraph(),getName(),getId());
    nodePeer.inEdges = inEdges.clone();
    nodePeer.outEdges = outEdges.clone();
    nodePeer.attributes = attributes.clone();
    nodePeer.representation = getRepresentation();
  }
  */
  
  /**
   * Useful for testing the subclass type of a DotElement object.
   *
   * @return true if this object is a DotNode.
   */
  public boolean isNode() {
    return(true);
  }

  /**
   * Useful for distinguishing DotElement objects.
   * Implements the abstract DotElement method.
   *
   * @return the class variable constant Grappa.DOT_NODE.
   * @see Grappa
   */
  public int typeFlag() {
    return(Grappa.DOT_NODE);
  }

  /**
   * Generates and sets the name for this node.
   * The generated name is the concatenation of DotNode.defaultNodeNamePrefix
   * with the numeric id of this node Instance.
   * Implements the corresponding abstract DotElement method.
   *
   * @see DotNode#defaultNodeNamePrefix()
   * @see DotElement#getId()
   */
  public void setName() {
    String oldName = name;
    
    while(true) {
      name = DotNode.defaultNodeNamePrefix + "_" + System.currentTimeMillis() + "." + getId();
      if(getGraph().getRoot().findNodeByName(name) == null) {
	break;
      }
    }

    // update subgraph node dictionary
    if(oldName != null) {
      getSubgraph().removeNode(oldName);
    }
    getSubgraph().addNode(this);
  }

  /**
   * Sets the node name to a copy of the supplied argument.
   * When the argument is null, setName() is called.
   * When the name is not unique or when the name has the same format as
   * that generated by setName(), a IllegalArgumentException is thrown.
   *
   * @param newName the new name for the node.
   * @see DotSubgraph#setName()
   */
  public void setName(String newName) throws IllegalArgumentException {
    if(newName == null) {
      setName();
      return;
    }

    String oldName = name;
    
    name = new String(newName);

    // test if name is the same as the old name (if any)
    if(oldName != null && oldName.equals(name)) {
      return;
    }

    // is name unique?
    if(getGraph().getRoot().findNodeByName(name) != null) {
      newName = name;
      name = oldName;
      throw new IllegalArgumentException("node name (" + newName + ") is not unique");
    }

    /* check name format
    if(newName != null) {
      if(newName.startsWith(DotNode.defaultNodeNamePrefix)) {
	String remainder = newName.substring(DotNode.defaultNodeNamePrefix.length());
	boolean badFormat = true;
	try {
	  int nbr = Integer.parseInt(remainder);
	} catch(NumberFormatException nfe) {
	  badFormat = false;
	}

	if(badFormat) {
	  name = oldName;
	  throw new IllegalArgumentException("node name (" + newName + ") resembles setName() generated name");
	}
      }
    }
    */

    // update subgraph node dictionary
    if(oldName != null) {
      getSubgraph().removeNode(oldName);
    }
    getSubgraph().addNode(this);
  }

  /**
   * Add the given edge to this node's inEdges or outEdges dictionaries.
   * The boolean indicates whether the edge terminates at (inEdge) or
   * emanates from (outEdge) the node.
   *
   * @param edge the edge to be added to this node's dictionary.
   * @param inEdge if set true, add to inEdges dictionary otherwise add
   *               to outEdges dictionary.
   * @see DotEdge
   */
  public void addEdge(DotEdge edge, boolean inEdge) {
    if(edge == null) return;
    if(inEdge) {
      if(inEdges == null) {
	inEdges = new Vector(initialEdgesCapacity,edgesIncrement);
      }
      inEdges.addElement(edge);
    } else {
      if(outEdges == null) {
	outEdges = new Vector(initialEdgesCapacity,edgesIncrement);
      }
      outEdges.addElement(edge);
    }
  }

  /**
   * Remove the given edge from this node's inEdges or outEdges dictionaries.
   * The boolean indicates whether the edge terminates at (inEdge) or
   * emanates from (outEdge) the node.
   *
   * @param edge the edge to be removed from this node's dictionary.
   * @param inEdge if set true, remove from inEdges dictionary otherwise
   *               remove from outEdges dictionary.
   * @see DotEdge
   */
  public void removeEdge(DotEdge edge, boolean inEdge) {
    if(edge == null) return;
    if(inEdge) {
      if(inEdges == null) return;
      inEdges.removeElement(edge);
    } else {
      if(outEdges == null) return;
      outEdges.removeElement(edge);
    }
  }

  /*
  public void deleteEdge(String edge) {
    String edge_name;
    for (int i = 0; i < this.edges.size(); i++) {
      edge_name = (String) this.edges.elementAt(i);
      if (edge_name.equals(edge)) {
        this.edges.removeElementAt(i);
        break;
      }
    }
  }
  */

  /**
   * Print the node description to the provided stream.
   *
   * @param out the output stream for writing the description.
   */
  public void printNode(PrintStream out) {
    this.printElement(out);
  }

  /**
   * Return the node's inEdges (terminating edges) dictionary.
   *
   * @return the node's inEdges dictionary.
   */
  public Vector getInEdges() {
    return(inEdges);
  }

  /**
   * Return the node's outEdges (emanating edges) dictionary.
   *
   * @return the node's outEdges dictionary.
   */
  public Vector getOutEdges() {
    return(outEdges);
  }

  public synchronized Enumeration edgeElements() {
    return new EdgeEnumeration(getInEdges(),getOutEdges());
  }
}

final class EdgeEnumeration implements Enumeration
{
  Vector storage = null;
  int elementPos = 0;
  int sz = 0;
  
  EdgeEnumeration(Vector in, Vector out) {
    if(in != null && in.size() > 0) {
      sz += in.size();
    }
    if(out != null && out.size() > 0) {
      sz += out.size();
    }

    if(sz > 0) {
      storage = new Vector(sz);
      if(in != null) {
	for(int i = 0; i < in.size(); i++) {
	  storage.addElement(in.elementAt(i));
	}
      }
      if(out != null) {
	for(int i = 0; i < out.size(); i++) {
	  storage.addElement(out.elementAt(i));
	}
      }
    }
  }

  public boolean hasMoreElements() {
    return(elementPos < sz);
  }

  public Object nextElement() {
    if(elementPos >= sz) {
      throw new NoSuchElementException("EdgeEnumerator");
    }
    return(storage.elementAt(elementPos++));
  }
}
